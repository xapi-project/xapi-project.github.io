<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.127.0"><meta name=generator content="Relearn 7.3.2"><meta name=description content="The xcp-networkd daemon (hereafter simply called “networkd”) is a component in the xapi toolstack that is responsible for configuring network interfaces and virtual switches (bridges) on a host.
The code is in ocaml/networkd.
Principles Distro-agnostic. Networkd is meant to work on at least CentOS/RHEL as well a Debian/Ubuntu based distros. It therefore should not use any network configuration features specific to those distros.
Stateless. By default, networkd should not maintain any state."><meta name=author content><meta name=twitter:card content="summary"><meta name=twitter:title content="Networkd :: XAPI Toolstack Developer Documentation"><meta name=twitter:description content="The xcp-networkd daemon (hereafter simply called “networkd”) is a component in the xapi toolstack that is responsible for configuring network interfaces and virtual switches (bridges) on a host.
The code is in ocaml/networkd.
Principles Distro-agnostic. Networkd is meant to work on at least CentOS/RHEL as well a Debian/Ubuntu based distros. It therefore should not use any network configuration features specific to those distros.
Stateless. By default, networkd should not maintain any state."><meta property="og:url" content="https://xapi-project.github.io/new-docs/xcp-networkd/index.html"><meta property="og:site_name" content="XAPI Toolstack Developer Documentation"><meta property="og:title" content="Networkd :: XAPI Toolstack Developer Documentation"><meta property="og:description" content="The xcp-networkd daemon (hereafter simply called “networkd”) is a component in the xapi toolstack that is responsible for configuring network interfaces and virtual switches (bridges) on a host.
The code is in ocaml/networkd.
Principles Distro-agnostic. Networkd is meant to work on at least CentOS/RHEL as well a Debian/Ubuntu based distros. It therefore should not use any network configuration features specific to those distros.
Stateless. By default, networkd should not maintain any state."><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta itemprop=name content="Networkd :: XAPI Toolstack Developer Documentation"><meta itemprop=description content="The xcp-networkd daemon (hereafter simply called “networkd”) is a component in the xapi toolstack that is responsible for configuring network interfaces and virtual switches (bridges) on a host.
The code is in ocaml/networkd.
Principles Distro-agnostic. Networkd is meant to work on at least CentOS/RHEL as well a Debian/Ubuntu based distros. It therefore should not use any network configuration features specific to those distros.
Stateless. By default, networkd should not maintain any state."><meta itemprop=wordCount content="1333"><title>Networkd :: XAPI Toolstack Developer Documentation</title>
<link href=https://xapi-project.github.io/new-docs/xcp-networkd/index.html rel=canonical type=text/html title="Networkd :: XAPI Toolstack Developer Documentation"><link href=/new-docs/xcp-networkd/index.xml rel=alternate type=application/rss+xml title="Networkd :: XAPI Toolstack Developer Documentation"><link href=/new-docs/images/favicon.png?1761579849 rel=icon type=image/png><link href=/new-docs/css/fontawesome-all.min.css?1761579849 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/fontawesome-all.min.css?1761579849 rel=stylesheet></noscript><link href=/new-docs/css/auto-complete.css?1761579849 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/auto-complete.css?1761579849 rel=stylesheet></noscript><link href=/new-docs/css/perfect-scrollbar.min.css?1761579849 rel=stylesheet><link href=/new-docs/css/theme.min.css?1761579849 rel=stylesheet><link href=/new-docs/css/format-print.min.css?1761579849 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://xapi-project.github.io/new-docs",window.relearn.min=`.min`,window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.themevariants=["auto","zen-light","zen-dark","red","blue","green","learn","neon","relearn-light","relearn-bright","relearn-dark"],window.relearn.customvariantname="my-custom-variant",window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.localStorage.setItem(window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}}))},window.relearn.markVariant=function(){var t=window.localStorage.getItem(window.relearn.absBaseUri+"/variant"),e=document.querySelector("#R-select-variant");e&&(e.value=t)},window.relearn.initVariant=function(){var e=window.localStorage.getItem(window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.localStorage.setItem(window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant(),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link rel=stylesheet href=https://xapi-project.github.io/new-docs/css/misc.css></head><body class="mobile-support print" data-url=/new-docs/xcp-networkd/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#principles>Principles</a></li><li><a href=#usage>Usage</a></li><li><a href=#network-interface-api>Network Interface API</a></li><li><a href=#bridge-api>Bridge API</a></li><li><a href=#backends>Backends</a></li><li><a href=#low-level-interfaces>Low-level Interfaces</a></li><li><a href=#configuration-on-startup>Configuration on Startup</a></li><li><a href=#monitoring>Monitoring</a></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/new-docs/index.html><span itemprop=name>XAPI Toolstack Developer Guide</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Networkd</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/xapi-project/xen-api/edit/master/doc/content/xcp-networkd/_index.md target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/new-docs/xcp-networkd/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/new-docs/xenopsd/walkthroughs/live-migration/index.html title="Live Migration Sequence Diagram (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/new-docs/xcp-networkd/host-network-device-ordering-on-networkd/index.html title="Host Network Device Ordering on Networkd (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable xcp-networkd" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=networkd>Networkd</h1><p>The <code>xcp-networkd</code> daemon (hereafter simply called &ldquo;networkd&rdquo;) is a component in the xapi toolstack that is responsible for configuring network interfaces and virtual switches (bridges) on a host.</p><p>The code is in <code>ocaml/networkd</code>.</p><h2 id=principles>Principles</h2><ol><li><p><strong>Distro-agnostic</strong>. Networkd is meant to work on at least CentOS/RHEL as well a Debian/Ubuntu based distros. It therefore should not use any network configuration features specific to those distros.</p></li><li><p><strong>Stateless</strong>. By default, networkd should not maintain any state. If you ask networkd anything about a network interface or bridge, or any other network sub-system property, it will always query the underlying system (e.g. an IP address), rather than returning any cached state. However, if you want networkd to configure networking at host boot time, the you can ask it to remember your configuration you have set for any interface or bridge you choose.</p></li><li><p><strong>Idempotent</strong>. It should be possible to call any networkd function multiple times without breaking things. For example, calling a function to set an IP address on an interface twice in a row should have the same outcome as calling it just once.</p></li><li><p><strong>Do no harm</strong>. Networkd should only configure what you ask it to configure. This means that it can co-exist with other network managers.</p></li></ol><h2 id=usage>Usage</h2><p>Networkd is a daemon that is typically started at host-boot time. In the same way as the other daemons in the xapi toolstack, it is controlled by RPC requests. It typically receives requests from the xapi daemon, on behalf of which it configures host networking.</p><p>Networkd&rsquo;s RCP API is fully described by the <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi-idl/network/network_interface.ml rel=external target=_blank>network_interface.ml</a> file. The API has two main namespaces: <code>Interface</code> and <code>Bridge</code>, which are implemented in two modules in <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/networkd/bin/network_server.ml rel=external target=_blank>network_server.ml</a>.</p><p>In line with other xapi daemons, all API functions take an argument of type <code>debug_info</code> (a string) as their first argument. The debug string appears in any log lines that are produced as a side effort of calling the function.</p><h2 id=network-interface-api>Network Interface API</h2><p>The Interface API has functions to query and configure properties of Linux network devices, such as IP addresses, and bringing them up or down. Most Interface functions take a <code>name</code> string as a reference to a network interface as their second argument, which is expected to be the name of the Linux network device. There is also a special function, called <code>Interface.make_config</code>, that is able to configure a number of interfaces at once. It takes an argument called <code>config</code> of type <code>(iface * interface_config_t) list</code>, where <code>iface</code> is an interface name, and <code>interface_config_t</code> is a compound type containing the full configuration for an interface (as far as networkd is able to configure them), currently defined as follows:</p><div class="highlight wrap-code"><pre tabindex=0><code>type interface_config_t = {
	ipv4_conf: ipv4;
	ipv4_gateway: Unix.inet_addr option;
	ipv6_conf: ipv6;
	ipv6_gateway: Unix.inet_addr option;
	ipv4_routes: (Unix.inet_addr * int * Unix.inet_addr) list;
	dns: Unix.inet_addr list * string list;
	mtu: int;
	ethtool_settings: (string * string) list;
	ethtool_offload: (string * string) list;
	persistent_i: bool;
}</code></pre></div><p>When the function returns, it should have completely configured the interface, and have brought it up. The idempotency principle applies to this function, which means that it can be used to successively modify interface properties; any property that has not changed will effectively be ignored. In fact, <code>Interface.make_config</code> is the main function that xapi uses to configure interfaces, e.g. as a result of a <code>PIF.plug</code> or a <code>PIF.reconfigure_ip</code> call.</p><p>Also note the <code>persistent</code> property in the interface config. When an interface is made &ldquo;persistent&rdquo;, this means that any configuration that is set on it is remembered by networkd, and the interface config is written to disk. When networkd is started, it will read the persistent config and call <code>Interface.make_config</code> on it in order to apply it (see Startup below).</p><p><em>The full networkd API should be documented separately somewhere on this site.</em></p><h2 id=bridge-api>Bridge API</h2><p>The Bridge API functions are all about the management of virtual switches, also known as &ldquo;bridges&rdquo;. The shape of the Bridge API roughly follows that of the Open vSwitch in that it treats a bridge as a collection of &ldquo;ports&rdquo;, where a port can contain one or more &ldquo;interfaces&rdquo;.</p><p>NIC bonding and VLANs are all configured on the Bridge level. There are functions for creating and destroying bridges, adding and removing ports, and configuring bonds and VLANs. Like interfaces, bridges and ports are addressed by name in the Bridge functions. Analogous to the Interface function with the same name, there is a <code>Bridge.make_config</code> function, and bridges can be made <code>persistent</code>.</p><div class="highlight wrap-code"><pre tabindex=0><code>type port_config_t = {
	interfaces: iface list;
	bond_properties: (string * string) list;
	bond_mac: string option;
}
type bridge_config_t = {
	ports: (port * port_config_t) list;
	vlan: (bridge * int) option;
	bridge_mac: string option;
	other_config: (string * string) list;
	persistent_b: bool;
}</code></pre></div><h2 id=backends>Backends</h2><p>Networkd currently has two different backends: the &ldquo;Linux bridge&rdquo; backend and the &ldquo;Open vSwitch&rdquo; backend. The former is the &ldquo;classic&rdquo; backend based on the bridge module that is available in the Linux kernel, plus additional standard Linux functionality for NIC bonding and VLANs. The latter backend is newer and uses the <a href=http://www.openvswitch.org rel=external target=_blank>Open vSwitch (OVS)</a> for bridging as well as other functionality. Which backend is currently in use is defined by the file <code>/etc/xensource/network.conf</code>, which is read by networkd when it starts. The choice of backend (currently) only affects the Bridge API: every function in it has a separate implementation for each backend.</p><h2 id=low-level-interfaces>Low-level Interfaces</h2><p>Networkd uses standard networking commands and interfaces that are available in most modern Linux distros, rather than relying on any distro-specific network tools (see the distro-agnostic principle). These are tools such as <code>ip</code> (iproute2), <code>dhclient</code> and <code>brctl</code>, as well as the <code>sysfs</code> files system, and <code>netlink</code> sockets. To control the OVS, the <code>ovs-*</code> command line tools are used. All low-level functions are called from <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/networkd/lib/network_utils.ml rel=external target=_blank>network_utils.ml</a>.</p><h2 id=configuration-on-startup>Configuration on Startup</h2><p>Networkd, periodically as well as on shutdown, writes the current configuration of all bridges and interfaces (see above) in a JSON format to a file called <code>networkd.db</code> (currently in <code>/var/lib/xcp</code>). The contents of the file are completely described by the following type:</p><div class="highlight wrap-code"><pre tabindex=0><code>type config_t = {
	interface_config: (iface * interface_config_t) list;
	bridge_config: (bridge * bridge_config_t) list;
	gateway_interface: iface option;
	dns_interface: iface option;
}</code></pre></div><p>The <code>gateway_interface</code> and <code>dns_interface</code> in the config are global host-level options to define from which interfaces the default gateway and DNS configuration is taken. This is especially important when multiple interfaces are configured by DHCP.</p><p>When networkd starts up, it first reads <code>network.conf</code> to determine the network backend. It subsequently attempts to parse <code>networkd.db</code>, and tries to call <code>Bridge.make_config</code> and <code>Interface.make_config</code> on it, with a special options to only apply the config for <code>persistent</code> bridges and interfaces, as well as bridges related to those (for example, if a VLAN bridge is configured, then also its parent bridge must be configured).</p><p>Networkd also supports upgrades from older versions of XenServer that used a network configuration script called <code>interface-configure</code>. If <code>networkd.db</code> is not found on startup, then networkd attempts to call this tool (via the <code>/etc/init.d/management-interface</code> script) in order to set up networking at boot time. This is normally followed immediately by a call from xapi instructing networkd to take over.</p><p>Finally, if no network config (old or new) is found on disk at all, networkd looks for a XenServer &ldquo;firstboot&rdquo; data file, which is written by XenServer&rsquo;s host installer, and tries to apply it to set up the management interface.</p><h2 id=monitoring>Monitoring</h2><p>Besides the ability to configure bridges and network interfaces, networkd has facilities for monitoring interfaces and bonds. When networkd starts, a monitor thread is started, which does several things (see <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/networkd/bin/network_monitor_thread.ml rel=external target=_blank>network_monitor_thread.ml</a>):</p><ul><li>Every 5 seconds, it gathers send/receive counters and link state of all network interfaces. It then writes these stats to a shared-memory file, to be picked up by other components such as <code>xcp-rrdd</code> and <code>xapi</code> (see documentation about &ldquo;xenostats&rdquo; elsewhere).</li><li>It monitors NIC bonds, and sends alerts through xapi in case of link state changes within a bond.</li><li>It uses <code>ip monitor address</code> to watch for an IP address changes, and if so, it calls xapi (<code>Host.signal_networking_change</code>) for it to update the IP addresses of the PIFs in its database that were configured by DHCP.</li></ul><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Networkd</h1><article class=default><header class=headline></header><h1 id=host-network-device-ordering-on-networkd>Host Network Device Ordering on Networkd</h1><h2 id=purpose>Purpose</h2><p>One of the Toolstack&rsquo;s functions is to maintain a pool of hosts. A pool can be
constructed by joining a host into an existing pool. One challenge in this
process is determining which pool-wide network a network device on the joining
host should connect to.</p><p>At first glance, this could be resolved by specifying a mapping between an
individual network device and a pool-wide network. However, this approach
would be burdensome for administrators when managing many hosts. It would be
more efficient if the Toolstack could determine this automatically.</p><p>To achieve this, the Toolstack components on two hosts need to independently
work out consistent identifications for the host network devices and connect
the network devices with the same identification to the same pool-wide network.
The identifications on a host can be considered as an order, with each network
device assigned a unique position in the order as its identification. Network
devices with the same position will connect to the same network.</p><h2 id=the-assumption>The assumption</h2><p>Why can the Toolstack components on two hosts independently work out an expected
order without any communication? This is possible only under the assumption that
the hosts have identical hardware, firmware, software, and the way
network devices are plugged into them. For example, an administrator will always
plug the network devices into the same PCI slot position on multiple hosts if
they want these network devices to connect to the same network.</p><p>The ordering is considered consistent if the positions of such network devices
(plugged into the same PCI slot position) in the generated orders are the same.</p><h2 id=the-biosdevname>The biosdevname</h2><p>Particularly, when the assumption above holds, a consistent initial order can be
worked out on multiple hosts independently with the help of <code>biosdevname</code>. The
&ldquo;all_ethN&rdquo; policy of the <code>biosdevname</code> utility can generate a device order based
on whether the device is embedded or not, PCI cards in ascending slot order, and
ports in ascending PCI bus/device/function order breadth-first. Since the hosts
are identical, the orders generated by the <code>biosdevname</code> are consistent across
the hosts.</p><p>An example of <code>biosdevname</code>&rsquo;s output is as the following. The initial order can
be derived from the <code>BIOS device</code> field.</p><div class="highlight wrap-code"><pre tabindex=0><code># biosdevname --policy all_ethN -d -x
BIOS device: eth0
Kernel name: enp5s0
Permanent MAC: 00:02:C9:ED:FD:F0
Assigned MAC : 00:02:C9:ED:FD:F0
Bus Info: 0000:05:00.0
...

BIOS device: eth1
Kernel name: enp5s1
Permanent MAC: 00:02:C9:ED:FD:F1
Assigned MAC : 00:02:C9:ED:FD:F1
Bus Info: 0000:05:01.0
...</code></pre></div><p>However, the <code>BIOS device</code> of a particular network device may change with the
addition or removal of devices. For example:</p><div class="highlight wrap-code"><pre tabindex=0><code># biosdevname --policy all_ethN -d -x
BIOS device: eth0
Kernel name: enp4s0
Permanent MAC: EC:F4:BB:E6:D7:BB
Assigned MAC : EC:F4:BB:E6:D7:BB
Bus Info: 0000:04:00.0
...

BIOS device: eth1
Kernel name: enp5s0
Permanent MAC: 00:02:C9:ED:FD:F0
Assigned MAC : 00:02:C9:ED:FD:F0
Bus Info: 0000:05:00.0
...

BIOS device: eth2
Kernel name: enp5s1
Permanent MAC: 00:02:C9:ED:FD:F1
Assigned MAC : 00:02:C9:ED:FD:F1
Bus Info: 0000:05:01.0
...</code></pre></div><p>Therefore, the order derived from these values is used solely for determining
the initial order and the order of newly added devices.</p><h2 id=principles>Principles</h2><ul><li><p>Initially, the order is aligned with PCI slots. This is to make the connection
between cabling and order predictable: The network devices in identical PCI
slots have the same position. The rationale is that PCI slots are more
predictable than MAC addresses and correspond to physical locations.</p></li><li><p>Once a previous order has been established, the ordering should be maintained
as stable as possible despite changes to MAC addresses or PCI addresses. The
rationale is that the assumption is less likely to hold as long as the hosts are
experiencing updates and maintenance. Therefore, maintaining the stable order is
the best choice for automatic ordering.</p></li></ul><h2 id=notation>Notation</h2><div class="highlight wrap-code"><pre tabindex=0><code>mac:pci:position
!mac:pci:position</code></pre></div><p>A network device is characterised by</p><ul><li>MAC address, which is unique.</li><li>PCI slot, which is not unique and multiple network devices can share a PCI
slot. PCI addresses correspond to hardware PCI slots and thus are physically
observable.</li><li>position, the position assigned to this network device by xcp-networkd. At any
given time, no position is assigned twice but the sequence of positions may have
holes.</li><li>The <code>!mac:pci:position</code> notation indicates that this postion was previously
used but currently is free because the device it was assgined was removed.</li></ul><p>On a Linux system, MAC and PCI addresses have specific formats. However, for
simplicity, symbolic names are used here: MAC addresses use lowercase letters,
PCI addresses use uppercase letters, and positions use numbers.</p><h2 id=scenarios>Scenarios</h2><h3 id=the-initial-order>The initial order</h3><p>As mentioned above, the <code>biosdevname</code> can be used to generate consistent orders
for the network devices on multiple hosts.</p><div class="highlight wrap-code"><pre tabindex=0><code>current input: a:A   b:D   c:C
initial order: a:A:0 c:C:1 b:D:2</code></pre></div><p>This only works if the assumption of identical hardware, firmware, software, and
network device placement holds. And it is considered that the assumption will
hold for the majority of the use cases.</p><p>Otherwise, the order can be generated from a user&rsquo;s configuration. The user can
specify the order explicilty for individual hosts. However, administrators would
prefer to avoid this as much as possible when managing many hosts.</p><div class="highlight wrap-code"><pre tabindex=0><code>user spec:     a::0  c::1  b::2
current input: a:A   b:D   c:C
initial order: a:A:0 c:C:1 b:D:2</code></pre></div><h3 id=keep-the-order-as-stable-as-possible>Keep the order as stable as possible</h3><p>Once an initial order is created on an individual host, it should be kept as
stable as possible across host boot-ups and at runtime. For example, unless
there are hardware changes, the position of a network device in the initial
order should remain the same regardless of how many times the host is rebooted.</p><p>To achieve this, the initial order should be saved persistently on the host&rsquo;s
local storage so it can be referenced in subsequent orderings. When performing
another ordering after the initial order has been saved, the position of a
currently unordered network device should be determined by finding its position
in the last saved order. The MAC address of the network device is a reliable
attribute for this purpose, as it is considered unique for each network device
globally.</p><p>Therefore, the network devices in the saved order should have their MAC
addresses saved together, effectively mapping each position to a MAC address.
When performing an ordering, the stable position can be found by searching the
last saved order using the MAC address.</p><div class="highlight wrap-code"><pre tabindex=0><code>last order:    a:A:0  c:C:1  b:D:2
current input: a:A    b:D    c:C
new order:     a:A:0  c:C:1  b:D:2</code></pre></div><p>Name labels of the network devices are not considered reliable enough to
identify particular devices. For example, if the name labels are determined by
the PCI address via systemd, and a firmware update changes the PCI addresses of
the network devices, the name labels will also change.</p><p>The PCI addresses are not considered reliable as well. They may change due to
the firmeware update/setting changes or even plugging/unpluggig other devices.</p><div class="highlight wrap-code"><pre tabindex=0><code>last order:    a:A:0  c:C:1  b:D:2
current input: a:A    b:B    c:E
new order:     a:A:0  c:E:1  b:B:2</code></pre></div><h3 id=replacement>Replacement</h3><p>However, what happens when the MAC address of an unordered network device cannot
be found in the last saved order? There are two possible scenarios:</p><ol><li>It&rsquo;s a newly added network device since the last ordering.</li><li>It&rsquo;s a new device that replaces an existing network device.</li></ol><p>Replacement is a supported scenario, as an administrator might replace a broken
network device with a new one.</p><p>This can be recognized by comparing the PCI address where the network device is
located. Therefore, the PCI address of each network device should also be saved
in the order. In this case, searching the PCI address in the order results in
one of the following:</p><ol><li>Not found: This means the PCI address was not occupied during the last
ordering, indicating a newly added network device.</li><li>Found with a MAC address, but another device with this MAC address is still
present in the system: This suggests that the PCI address of an existing
network device (with the same MAC address) has changed since the last ordering.
This may be caused by either a device move or others like a firmware update. In
this case, the current unordered network device is considered newly added.</li></ol><div class="highlight wrap-code"><pre tabindex=0><code>last order:    a:A:0  c:C:1  b:D:2
current input: a:A    b:B    c:C    d:D
new order:     a:A:0  c:C:1  b:B:2  d:D:3</code></pre></div><ol start=3><li>Found with a MAC address, and no current devices have this MAC address: This
indicates that a new network device has replaced the old one in the same PCI
slot.
The replacing network device should be assigned the same position as the
replaced one.</li></ol><div class="highlight wrap-code"><pre tabindex=0><code>last order:    a:A:0  c:C:1  b:D:2
current input: a:A    c:C    d:D
new order:     a:A:0  c:C:1  d:D:2</code></pre></div><h3 id=removed-devices>Removed devices</h3><p>A network device can be removed or unplugged since the last ordering. Its
position, MAC address, and PCI address are saved for future reference, and its
position will be reserved. This means there may be a gap in the order: a
position that was previously assigned to a network device is now vacant because
the device has been removed.</p><div class="highlight wrap-code"><pre tabindex=0><code>last order:    a:A:0  c:C:1  b:D:2
current input: a:A    b:D
new order:     a:A:0  !c:C:1 d:D:2</code></pre></div><h3 id=newly-added-devices>Newly added devices</h3><p>As long as <code>the assumption</code> holds, newly added devices since the last ordering
can be assigned positions consistently across multiple hosts. Newly added
devices will not be assigned the positions reserved for removed devices.</p><div class="highlight wrap-code"><pre tabindex=0><code>last order:    a:A:0 !c:C:1  d:D:2
current input: a:A           d:D    e:E
new order:     a:A:0 !c:C:1  d:D:2  e:E:3</code></pre></div><h3 id=removed-and-then-added-back>Removed and then added back</h3><p>It is a supported scenario for a removed device to be plugged back in,
regardless of whether it is in the same PCI slot or not. This can be recognized
by searching for the device in the saved removed devices using its MAC address.
The reserved position will be reassigned to the device when it is added back.</p><div class="highlight wrap-code"><pre tabindex=0><code>last order:    a:A:0 !c:C:1 d:D:2
current input: a:A   c:F    d:D   e:E
new order:     a:A:0 c:F:1  d:D:2 e:E:3</code></pre></div><h3 id=multinic-functions>Multinic functions</h3><p>The multinic function is a special kind of network device. When this type of
physical device is plugged into a PCI slot, multiple network devices are
reported at a single PCI address. Additionally, the number of reported network
devices may change due to driver updates.</p><div class="highlight wrap-code"><pre tabindex=0><code>current input: a:A b:A c:A d:A
initial order: a:A:0 b:A:1 c:A:2 d:A:3</code></pre></div><p>As long as <code>the assumption</code> holds, the initial order of these devices can be
generated automatically and kept stable by using MAC addresses to identify
individual devices. However, <code>biosdevname</code> cannot reliably generate an order for
all devices reported at one PCI address. For devices located at the same PCI
address, their MAC addresses are used to generate the initial order.</p><div class="highlight wrap-code"><pre tabindex=0><code>last order:    a:A:0 b:A:1 c:A:2 d:A:3 m:M:4 n:N:5
current input: a:A   b:A   c:A   d:A   e:A   f:A   m:M   n:N
new order:     a:A:0 b:A:1 c:A:2 d:A:3 m:M:4 n:N:5 e:A:6 f:A:7</code></pre></div><p>For example, suppose <code>biosdevname</code> generates an order for a multinic function
and other non-multinic devices. Within this order, the N devices of the
multinic function with MAC addresses mac[1], &mldr;, mac[N] are assigned positions
pos[1], &mldr;, pos[N] correspondingly. <code>biosdevname</code> cannot ensure that the device
with mac[1] is always assigned position pos[1]. Instead, it ensures that the
entire set of positions pos[1], &mldr;, pos[N] remains stable for the devices of
the multinic function. Therefore, to ensure the order follows the MAC address
order, the devices of the multinic function need to be sorted by their MAC
addresses within the set of positions.</p><div class="highlight wrap-code"><pre tabindex=0><code>last order:    a:A:0 b:A:1 c:A:2 d:A:3 m:M:4
current input: e:A   f:A   g:A   h:A   m:M
new order:     e:A:0 f:A:1 g:A:2 h:A:3 m:M:4</code></pre></div><h2 id=rare-cases-that-can-not-be-handled-automatically>Rare cases that can not be handled automatically</h2><p>In summary, to keep the order stable, the auto-generated order needs to be saved
for the next ordering. When performing an automatic ordering for the current
network devices, either the MAC address or the PCI address is used to recognize
the device that was assigned the same position in the last ordering. If neither
the MAC address nor the PCI address can be used to find a position from the last
ordering, the device is considered newly added and is assigned a new position.</p><p>However, following this sorting logic, the ordering result may not always be as
expected. In practice, this can be caused by various rare cases, such as
switching an existing network device to connect to another network, performing
firmware updates, changing firmware settings, or plugging/unplugging network
devices. It is not worth complicating the entire function for these rare cases.
Instead, the initial user&rsquo;s configuration can be used to handle these rare
scenarios.</p><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article></section></div></main></div><script src=/new-docs/js/clipboard.min.js?1761579849 defer></script><script src=/new-docs/js/perfect-scrollbar.min.js?1761579849 defer></script><script src=/new-docs/js/theme.js?1761579849 defer></script><script>function apply_image_invert_filter(e){document.querySelectorAll("img").forEach(function(t){if(t.classList.contains("no-invert"))return;t.style="filter: invert("+e+");"})}function darkThemeUsed(){const t=window.getComputedStyle(document.querySelector("body")),n=t.getPropertyValue("background-color");var e=n.match(/\d+/g).map(function(e){return parseInt(e,10)});return e.length===3&&.2126*e[0]+.7152*e[1]+.0722*e[2]<165}const invertToDarkGray=.85;darkThemeUsed()&&apply_image_invert_filter(invertToDarkGray),document.addEventListener("themeVariantLoaded",function(e){apply_image_invert_filter(e.detail.variant.endsWith("dark")?invertToDarkGray:0)})</script></body></html>