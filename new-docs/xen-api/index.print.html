<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.127.0"><meta name=generator content="Relearn 5.20.0+tip"><meta name=description content><title>XenAPI :: XAPI Toolstack Developer Documentation</title>
<link href=https://xapi-project.github.io/new-docs/xen-api/index.html rel=canonical type=text/html title="XenAPI :: XAPI Toolstack Developer Documentation"><link href=/new-docs/xen-api/index.xml rel=alternate type=application/rss+xml title="XenAPI :: XAPI Toolstack Developer Documentation"><link href=/new-docs/images/favicon.png?1729773854 rel=icon type=image/png><link href=/new-docs/css/fontawesome-all.min.css?1729773859 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/fontawesome-all.min.css?1729773859 rel=stylesheet></noscript><link href=/new-docs/css/nucleus.css?1729773859 rel=stylesheet><link href=/new-docs/css/auto-complete.css?1729773859 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/auto-complete.css?1729773859 rel=stylesheet></noscript><link href=/new-docs/css/perfect-scrollbar.min.css?1729773859 rel=stylesheet><link href=/new-docs/css/fonts.css?1729773859 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/fonts.css?1729773859 rel=stylesheet></noscript><link href=/new-docs/css/theme.css?1729773859 rel=stylesheet><link href=/new-docs/css/theme-auto.css?1729773859 rel=stylesheet id=variant-style><link href=/new-docs/css/variant.css?1729773859 rel=stylesheet><link href=/new-docs/css/print.css?1729773859 rel=stylesheet media=print><link href=/new-docs/css/format-print.css?1729773859 rel=stylesheet><link href=/new-docs/css/ie.css?1729773859 rel=stylesheet><script src=/new-docs/js/url.js?1729773859></script><script src=/new-docs/js/variant.js?1729773859></script><script>window.index_js_url="/new-docs/index.search.js";var baseUriFull,root_url="/",baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copy to clipboard",window.T_Copied_to_clipboard="Copied to clipboard!",window.T_Copy_link_to_clipboard="Copy link to clipboard",window.T_Link_copied_to_clipboard="Copied link to clipboard!",window.T_No_results_found='No results found for "{0}"',window.T_N_results_found='{1} results found for "{0}"',baseUriFull="https://xapi-project.github.io/new-docs/",window.variants&&variants.init(["auto","zen-light","zen-dark","red","blue","green","learn","neon","relearn-light","relearn-bright","relearn-dark"])</script><link rel=stylesheet href=https://xapi-project.github.io/new-docs/css/misc.css></head><body class="mobile-support print" data-url=/new-docs/xen-api/index.html><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle class=topbar-link title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/new-docs/index.html><span itemprop=name>XAPI Toolstack Developer Guide</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>XenAPI</span><meta itemprop=position content="2"></li></ol></div></div></nav><main id=body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=xenapi>XenAPI</h1><ul class="children children-li children-sort-"><li><a href=/new-docs/xen-api/basics/index.html>XenAPI Basics</a></li><li><a href=/new-docs/xen-api/wire-protocol/index.html>Wire Protocol</a></li><li><a href=/new-docs/xen-api/overview/index.html>Overview of the XenAPI</a></li><li><a href=/new-docs/xen-api/evolution/index.html>API evolution</a></li><li><a href=/new-docs/xen-api/usage/index.html>Using the API</a></li><li><a href=/new-docs/xen-api/classes/index.html>XenAPI Reference</a></li><li><a href=/new-docs/xen-api/releases/index.html>XenAPI Releases</a></li><li><a href=/new-docs/xen-api/topics/index.html>Topics</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of XenAPI</h1><article class=default><header class=headline></header><h1 id=xenapi-basics>XenAPI Basics</h1><p>This document contains a description of the Xen Management API – an interface for
remotely configuring and controlling virtualised guests running on a
Xen-enabled host.</p><p>The XenAPI is presented here as a set of Remote Procedure Calls, with a wire
format based upon <a href=http://xmlrpc.scripting.com target=_blank>XML-RPC</a>.
No specific language bindings are prescribed,
although examples will be given in the python programming language.</p><p>Although we adopt some terminology from object-oriented programming,
future client language bindings may or may not be object oriented.
The API reference uses the terminology <em>classes</em> and <em>objects</em>.
For our purposes a <em>class</em> is simply a hierarchical namespace;
an <em>object</em> is an instance of a class with its fields set to
specific values. Objects are persistent and exist on the server-side.
Clients may obtain opaque references to these server-side objects and then
access their fields via get/set RPCs.</p><p>For each class we specify a list of fields along with their <em>types</em> and <em>qualifiers</em>. A
qualifier is one of:</p><ul><li><em>RO/runtime</em>: the field is Read
Only. Furthermore, its value is automatically computed at runtime.
For example: current CPU load and disk IO throughput.</li><li><em>RO/constructor</em>: the field must be manually set
when a new object is created, but is then Read Only for
the duration of the object&rsquo;s life.
For example, the maximum memory addressable by a guest is set
before the guest boots.</li><li><em>RW</em>: the field is Read/Write. For example, the name of a VM.</li></ul><h2 id=types>Types</h2><p>The following types are used to specify methods and fields in the API Reference:</p><ul><li><code>string</code>: Text strings.</li><li><code>int</code>: 64-bit integers.</li><li><code>float</code>: IEEE double-precision floating-point numbers.</li><li><code>bool</code>: Boolean.</li><li><code>datetime</code>: Date and timestamp.</li><li><code>c ref</code>: Reference to an object of class <code>c</code>.</li><li><code>t set</code>: Arbitrary-length set of values of type <code>t</code>.</li><li><code>(k → v) map</code>: Mapping from values of type <code>k</code> to values of type <code>v</code>.</li><li><code>e enum</code>: Enumeration type with name <code>e</code>. Enums are defined in the API Reference together with classes that use them.</li></ul><p>Note that there are a number of cases where <code>ref</code>s are <em>doubly
linked</em> – e.g. a VM has a field called <code>VIFs</code> of type
<code>VIF ref set</code>; this field lists
the network interfaces attached to a particular VM. Similarly, the VIF
class has a field called <code>VM</code> of type <code>VM ref</code> which references the VM to which the interface is connected.
These two fields are <em>bound together</em>, in the sense that
creating a new VIF causes the <code>VIFs</code> field of the corresponding
VM object to be updated automatically.</p><p>The API reference explicitly lists the fields that are
bound together in this way. It also contains a diagram that shows
relationships between classes. In this diagram an edge signifies the
existance of a pair of fields that are bound together, using standard
crows-foot notation to signify the type of relationship (e.g.
one-many, many-many).</p><h2 id=rpcs-associated-with-fields>RPCs associated with fields</h2><p>Each field, <code>f</code>, has an RPC accessor associated with it
that returns <code>f</code>&rsquo;s value:</p><ul><li><code>get_f (r)</code>: Takes a <code>ref</code>, <code>r</code>, that refers to an object and returns the value of <code>f</code>.</li></ul><p>Each field, <code>f</code>, with attribute <code>RW</code> and whose outermost type is <code>set</code> has the following
additional RPCs associated with it:</p><ul><li><p><code>add_f (r, v)</code>: Adds a new element <code>v</code> to the set. Since sets cannot contain duplicate values this operation has no action in the case
that <code>v</code> was already in the set.</p></li><li><p><code>remove_f (r, v)</code>: Removes element <code>v</code> from the set.</p></li></ul><p>Each field, <code>f</code>, with attribute RW and whose outermost type is <code>map</code> has the following
additional RPCs associated with it:</p><ul><li><code>add_to_f (r, k, v)</code>: Adds new pair <code>(k → v)</code> to the mapping stored in <code>f</code> in object <code>r</code>. Attempting to add a new pair for duplicate
key, <code>k</code>, fails with an <code>MAP_DUPLICATE_KEY</code> error.</li><li><code>remove_from_f (r, k)</code>: Removes the pair with key <code>k</code> from the mapping stored in <code>f</code> in object <code>r</code>.</li></ul><p>Each field whose outermost type is neither <code>set</code> nor <code>map</code>,
but whose attribute is RW has an RPC accessor associated with it
that sets its value:</p><ul><li><code>set_f (r, v)</code>: Sets field <code>f</code> on object <code>r</code> to value <code>v</code>.</li></ul><h2 id=rpcs-associated-with-classes>RPCs associated with classes</h2><ul><li>Most classes have a <em>constructor</em> RPC named <code>create</code> that
takes as parameters all fields marked RW and
RO/constructor. The result of this RPC is that a new <em>persistent</em> object is
created on the server-side with the specified field values.</li><li>Each class has a <code>get_by_uuid (uuid)</code> RPC that returns the object
of that class that has the specified UUID.</li><li>Each class that has a <code>name_label</code> field has a <code>get_by_name_label (name_label)</code> RPC that returns a set of objects of that
class that have the specified <code>name_label</code>.</li><li>Most classes have a <code>destroy (r)</code> RPC that explicitly deletes the persistent object specified by <code>r</code> from the system. This is a
non-cascading delete – if the object being removed is referenced by another
object then the <code>destroy</code> call will fail.</li></ul><h2 id=additional-rpcs>Additional RPCs</h2><p>As well as the RPCs enumerated above, most classes have additional RPCs
associated with them. For example, the VM class has RPCs for cloning,
suspending, starting etc. Such additional RPCs are described explicitly
in the API reference.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=wire-protocol>Wire Protocol</h1><p>API calls are sent over a network to a Xen-enabled host using the
<a href=http://xmlrpc.scripting.com/spec.html target=_blank>XML-RPC</a> protocol. On this page, we describe how the higher-level types
used in our API Reference are mapped to primitive XML-RPC types.</p><p>We specify the signatures of API functions in the following style:</p><pre><code>(VM ref set)  VM.get_all ()
</code></pre><p>This specifies that the function with name <code>VM.get_all</code>
takes no parameters and returns a <code>set</code> of <code>VM ref</code>s. These
types are mapped onto XML-RPC types in a straight-forward manner:</p><ul><li><p><code>float</code>s, <code>bool</code>s, <code>datetime</code>s and <code>string</code>s map directly to the XML-RPC
<code>&lt;double></code>, <code>&lt;boolean></code>, <code>&lt;dateTime.iso8601></code>, and <code>&lt;string></code> elements.</p></li><li><p>all <code>ref</code> types are opaque references, encoded as the
XML-RPC’s <code>&lt;string></code> type. Users of the API should not make
assumptions about the concrete form of these strings and should not
expect them to remain valid after the client’s session with the
server has terminated.</p></li><li><p>fields named <code>uuid</code> of type <code>string</code> are
mapped to the XML-RPC <code>&lt;string></code> type. The string itself is
the OSF DCE UUID presentation format (as output by
<code>uuidgen</code>, etc).</p></li><li><p><code>int</code>s are all assumed to be 64-bit in our API and are encoded as a
string of decimal digits (rather than using XML-RPC’s built-in
32-bit <code>&lt;i4></code> type).</p></li><li><p>values of <code>enum</code> types are encoded as strings. For example, a value of
<code>destroy</code> of type <code>enum on_normal_exit</code>, would be
conveyed as:</p><pre><code>&lt;value&gt;&lt;string&gt;destroy&lt;/string&gt;&lt;/value&gt;
</code></pre></li><li><p>for all our types, <code>t</code>, our type <code>t set</code>
simply maps to XML-RPC’s <code>&lt;array></code> type, so for example a
value of type <code>string set</code> would be transmitted like
this:</p><pre><code>&lt;value&gt;
  &lt;array&gt;
    &lt;data&gt;
      &lt;value&gt;&lt;string&gt;CX8&lt;/string&gt;&lt;/value&gt;
      &lt;value&gt;&lt;string&gt;PSE36&lt;/string&gt;&lt;/value&gt;
      &lt;value&gt;&lt;string&gt;FPU&lt;/string&gt;&lt;/value&gt;
    &lt;/data&gt;
  &lt;/array&gt; 
&lt;/value&gt;
</code></pre></li><li><p>for types <code>k</code> and <code>v</code>, our type <code>(k → v) map</code> maps onto an XML-RPC <code>&lt;struct></code>, with the key as the name of
the struct. Note that the <code>(k → v) map</code> type is only valid
when <code>k</code> is a <code>string</code>, <code>ref</code>, or <code>int</code>, and in each case the keys of the maps are
stringified as above. For example, the <code>(string → double) map</code> containing a the mappings <code>"Mike" → 2.3</code> and
<code>"John" → 1.2</code> would be represented as:</p><pre><code>&lt;value&gt;
  &lt;struct&gt;
    &lt;member&gt;
      &lt;name&gt;Mike&lt;/name&gt;
      &lt;value&gt;&lt;double&gt;2.3&lt;/double&gt;&lt;/value&gt;
    &lt;/member&gt;
    &lt;member&gt;
      &lt;name&gt;John&lt;/name&gt;
      &lt;value&gt;&lt;double&gt;1.2&lt;/double&gt;&lt;/value&gt;
    &lt;/member&gt;
  &lt;/struct&gt;
&lt;/value&gt;
</code></pre></li><li><p>our <code>void</code> type is transmitted as an empty string.</p></li></ul><h2 id=note-on-references-vs-uuids>Note on References vs UUIDs</h2><p>References are opaque types — encoded as XML-RPC strings on the wire —
understood only by the particular server which generated them. Servers
are free to choose any concrete representation they find convenient;
clients should not make any assumptions or attempt to parse the string
contents. References are not guaranteed to be permanent identifiers for
objects; clients should not assume that references generated during one
session are valid for any future session. References do not allow
objects to be compared for equality. Two references to the same object
are not guaranteed to be textually identical.</p><p>UUIDs are intended to be permanent names for objects. They are
guaranteed to be in the OSF DCE UUID presentation format (as output by
<code>uuidgen</code>. Clients may store UUIDs on disk and use them to
lookup objects in subsequent sessions with the server. Clients may also
test equality on objects by comparing UUID strings.</p><p>The API provides mechanisms for translating between UUIDs and opaque
references. Each class that contains a UUID field provides:</p><ul><li><p>A <code>get_by_uuid</code> method that takes a UUID, and
returns an opaque reference to the server-side object that has that
UUID;</p></li><li><p>A <code>get_uuid</code> function (a regular “field getter” RPC)
that takes an opaque reference and returns the UUID of the
server-side object that is referenced by it.</p></li></ul><h2 id=return-valuesstatus-codes>Return Values/Status Codes</h2><p>The return value of an RPC call is an XML-RPC <code>&lt;struct></code>.</p><ul><li>The first element of the struct is named <code>"Status"</code>; it
contains a string value indicating whether the result of the call
was a <code>"Success"</code> or a <code>"Failure"</code>.</li></ul><p>If <code>"Status"</code> was set to <code>"Success"</code> then the Struct
contains a second element named <code>"Value"</code>:</p><ul><li>The element of the struct named <code>"Value"</code> contains the
function’s return value.</li></ul><p>In the case where <code>"Status"</code> is set to <code>"Failure"</code>
then the struct contains a second element named
<code>"ErrorDescription"</code>:</p><ul><li>The element of the struct named <code>"ErrorDescription"</code>
contains an array of string values. The first element of the array
is an error code; the remainder of the array are strings
representing error parameters relating to that code.</li></ul><p>For example, an XML-RPC return value from the
<code>host.get_resident_VMs</code> function above may look like this:</p><pre><code>&lt;struct&gt;
   &lt;member&gt;
     &lt;name&gt;Status&lt;/name&gt;
     &lt;value&gt;Success&lt;/value&gt;
   &lt;/member&gt;
   &lt;member&gt;
      &lt;name&gt;Value&lt;/name&gt;
      &lt;value&gt;
        &lt;array&gt;
           &lt;data&gt;
             &lt;value&gt;81547a35-205c-a551-c577-00b982c5fe00&lt;/value&gt;
             &lt;value&gt;61c85a22-05da-b8a2-2e55-06b0847da503&lt;/value&gt;
             &lt;value&gt;1d401ec4-3c17-35a6-fc79-cee6bd9811fe&lt;/value&gt;
           &lt;/data&gt;
        &lt;/array&gt;
     &lt;/value&gt;
   &lt;/member&gt;
&lt;/struct&gt;
</code></pre><h1 id=making-xml-rpc-calls>Making XML-RPC Calls</h1><h2 id=transport-layer>Transport Layer</h2><p>The following transport layers are currently supported:</p><ul><li><p>HTTPS for remote administration</p></li><li><p>HTTP over Unix domain sockets for local administration</p></li></ul><h2 id=session-layer>Session Layer</h2><p>The XML-RPC interface is session-based; before you can make arbitrary
RPC calls you must login and initiate a session. For example:</p><pre><code>(session ref)  session.login_with_password(string  uname, string  pwd, string  version, string  originator)
</code></pre><p>Where <code>uname</code> and <code>password</code> refer to your
username and password respectively, as defined by the Xen administrator.
The <code>session ref</code> returned by <code>session.login_with_password</code> is passed to subequent RPC
calls as an authentication token.</p><p>A session can be terminated with the <code>session.logout</code> function:</p><pre><code>(void)  session.logout (session ref)
</code></pre><h2 id=synchronous-and-asynchronous-invocation>Synchronous and Asynchronous invocation</h2><p>Each method call (apart from methods on <code>session</code> and <code>task</code> objects and
“getters” and “setters” derived from fields) can be made either
synchronously or asynchronously. A synchronous RPC call blocks until the
return value is received; the return value of a synchronous RPC call is
exactly as specified above.</p><p>Only synchronous API calls are listed explicitly in this document. All
asynchronous versions are in the special <code>Async</code> namespace.
For example, synchronous call <code>VM.clone (...)</code> has an asynchronous counterpart,
<code>Async.VM.clone (...)</code>, that is non-blocking.</p><p>Instead of returning its result directly, an asynchronous RPC call
returns a task ID (of type <code>task ref</code>); this identifier is subsequently used to
track the status of a running asynchronous RPC. Note that an asychronous
call may fail immediately, before a task has even been
created. To represent this eventuality, the returned <code>task ref</code>
is wrapped in an XML-RPC struct with a <code>Status</code>,
<code>ErrorDescription</code> and <code>Value</code> fields, exactly as
specified above.</p><p>The <code>task ref</code> is provided in the <code>Value</code> field if
<code>Status</code> is set to <code>Success</code>.</p><p>The RPC call</p><pre><code>(task ref set)  task.get_all (session ref)
</code></pre><p>returns a set of all task IDs known to the system. The status (including
any returned result and error codes) of these tasks can then be queried
by accessing the fields of the Task object in the usual way. Note that,
in order to get a consistent snapshot of a task’s state, it is advisable
to call the <code>get_record</code> function.</p><h1 id=example-interactive-session>Example interactive session</h1><p>This section describes how an interactive session might look, using the
python XML-RPC client library.</p><p>First, initialise python and import the library <code>xmlrpc.client</code>:</p><pre><code>$ python
...
&gt;&gt;&gt; import xmlrpc.client
</code></pre><p>Create a python object referencing the remote server:</p><pre><code>&gt;&gt;&gt; xen = xmlrpc.client.Server(&quot;https://localhost:443&quot;)
</code></pre><p>Acquire a session reference by logging in with a username and password
(error-handling ommitted for brevity; the session reference is returned
under the key <code>'Value'</code> in the resulting dictionary)</p><pre><code>&gt;&gt;&gt; session = xen.session.login_with_password(&quot;user&quot;, &quot;passwd&quot;)['Value']
</code></pre><p>When serialised, this call looks like the following:</p><pre><code>&lt;?xml version='1.0'?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;session.login_with_password&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;&lt;string&gt;user&lt;/string&gt;&lt;/value&gt;
    &lt;/param&gt;
    &lt;param&gt;
      &lt;value&gt;&lt;string&gt;passwd&lt;/string&gt;&lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;
</code></pre><p>Next, the user may acquire a list of all the VMs known to the system:
(Note the call takes the session reference as the only parameter)</p><pre><code>&gt;&gt;&gt; all_vms = xen.VM.get_all(session)['Value']
&gt;&gt;&gt; all_vms
['OpaqueRef:1', 'OpaqueRef:2', 'OpaqueRef:3', 'OpaqueRef:4']
</code></pre><p>The VM references here have the form <code>OpaqueRef:X</code>, though
they may not be that simple in the future, and you should treat them as
opaque strings. <em>Templates</em> are VMs with the
<code>is_a_template</code> field set to <code>true</code>. We can find the subset
of template VMs using a command like the following:</p><pre><code>&gt;&gt;&gt; all_templates = filter(lambda x: xen.VM.get_is_a_template(session, x)['Value'], all_vms)
</code></pre><p>Once a reference to a VM has been acquired a lifecycle operation may be
invoked:</p><pre><code>&gt;&gt;&gt; xen.VM.start(session, all_templates[0], False, False)
{'Status': 'Failure', 'ErrorDescription': ['VM_IS_TEMPLATE', 'OpaqueRef:X']}
</code></pre><p>In this case the <code>start</code> message has been rejected, because
the VM is a template, and so an error response has been returned. These
high-level errors are returned as structured data (rather than as
XML-RPC faults), allowing them to be internationalised.</p><p>Rather than querying fields individually, whole <em>records</em>
may be returned at once. To retrieve the record of a single object as a
python dictionary:</p><pre><code>&gt;&gt;&gt; record = xen.VM.get_record(session, all_templates[0])['Value']
&gt;&gt;&gt; record['power_state']
'Halted'
&gt;&gt;&gt; record['name_label']
'XenSource P2V Server'
</code></pre><p>To retrieve all the VM records in a single call:</p><pre><code>&gt;&gt;&gt; records = xen.VM.get_all_records(session)['Value']
&gt;&gt;&gt; records.keys()
['OpaqueRef:1', 'OpaqueRef:2', 'OpaqueRef:3', 'OpaqueRef:4' ]
&gt;&gt;&gt; records['OpaqueRef:1']['name_label']
'RHEL 4.1 Autoinstall Template'
</code></pre><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=overview-of-the-xenapi>Overview of the XenAPI</h1><p>This chapter introduces the XenAPI and its associated object model. The API has the following key features:</p><ul><li><p><em>Management of all aspects of the XenServer Host</em>.
The API allows you to manage VMs, storage, networking, host configuration and pools. Performance and status metrics can also be queried from the API.</p></li><li><p><em>Persistent Object Model</em>.
The results of all side-effecting operations (e.g. object creation, deletion and parameter modifications) are persisted in a server-side database that is managed by the XenServer installation.</p></li><li><p><em>An event mechanism</em>.
Through the API, clients can register to be notified when persistent (server-side) objects are modified. This enables applications to keep track of datamodel modifications performed by concurrently executing clients.</p></li><li><p><em>Synchronous and asynchronous invocation</em>.
All API calls can be invoked synchronously (that is, block until completion); any API call that may be long-running can also be invoked <em>asynchronously</em>. Asynchronous calls return immediately with a reference to a <em>task</em> object. This task object can be queried (through the API) for progress and status information. When an asynchronously invoked operation completes, the result (or error code) is available from the task object.</p></li><li><p><em>Remotable and Cross-Platform</em>.
The client issuing the API calls does not have to be resident on the host being managed; nor does it have to be connected to the host over ssh in order to execute the API. API calls make use of the XML-RPC protocol to transmit requests and responses over the network.</p></li><li><p><em>Secure and Authenticated Access</em>.
The XML-RPC API server executing on the host accepts secure socket connections. This allows a client to execute the APIs over the https protocol. Further, all the API calls execute in the context of a login session generated through username and password validation at the server. This provides secure and authenticated access to the XenServer installation.</p></li></ul><h2 id=getting-started-with-the-api>Getting Started with the API</h2><p>We will start our tour of the API by describing the calls required to create a new VM on a XenServer installation, and take it through a start/suspend/resume/stop cycle. This is done without reference to code in any specific language; at this stage we just describe the informal sequence of RPC invocations that accomplish our &ldquo;install and start&rdquo; task.</p><h3 id=authentication-acquiring-a-session-reference>Authentication: acquiring a session reference</h3><p>The first step is to call <code>Session.login_with_password(, , , )</code>. The API is session based, so before you can make other calls you will need to authenticate with the server. Assuming the username and password are authenticated correctly, the result of this call is a <em>session reference</em>. Subsequent API calls take the session reference as a parameter. In this way we ensure that only API users who are suitably authorized can perform operations on a XenServer installation. You can continue to use the same session for any number of API calls. When you have finished the session, Citrix recommends that you call <code>Session.logout(session)</code> to clean up: see later.</p><h3 id=acquiring-a-list-of-templates-to-base-a-new-vm-installation-on>Acquiring a list of templates to base a new VM installation on</h3><p>The next step is to query the list of &ldquo;templates&rdquo; on the host. Templates are specially-marked VM objects that specify suitable default parameters for a variety of supported guest types. (If you want to see a quick enumeration of the templates on a XenServer installation for yourself then you can execute the <code>xe template-list</code> CLI command.) To get a list of templates from the API, we need to find the VM objects on the server that have their <code>is_a_template</code> field set to true. One way to do this by calling <code>VM.get_all_records(session)</code> where the session parameter is the reference we acquired from our <code>Session.login_with_password</code> call earlier. This call queries the server, returning a snapshot (taken at the time of the call) containing all the VM object references and their field values.</p><p>(Remember that at this stage we are not concerned about the particular mechanisms by which the returned object references and field values can be manipulated in any particular client language: that detail is dealt with by our language-specific API bindings and described concretely in the following chapter. For now it suffices just to assume the existence of an abstract mechanism for reading and manipulating objects and field values returned by API calls.)</p><p>Now that we have a snapshot of all the VM objects&rsquo; field values in the memory of our client application we can simply iterate through them and find the ones that have their &ldquo;<code>is_a_template</code>&rdquo; set to true. At this stage let&rsquo;s assume that our example application further iterates through the template objects and remembers the reference corresponding to the one that has its &ldquo;<code>name_label</code>&rdquo; set to &ldquo;Debian Etch 4.0&rdquo; (one of the default Linux templates supplied with XenServer).</p><h3 id=installing-the-vm-based-on-a-template>Installing the VM based on a template</h3><p>Continuing through our example, we must now install a new VM based on the template we selected. The installation process requires 4 API calls:</p><ul><li><p>First we must now invoke the API call <code>VM.clone(session, t_ref, "my first VM")</code>. This tells the server to clone the VM object referenced by <code>t_ref</code> in order to make a new VM object. The return value of this call is the VM reference corresponding to the newly-created VM. Let&rsquo;s call this <code>new_vm_ref</code>.</p></li><li><p>Next, we need to specify the UUID of the Storage Repository where the VM&rsquo;s
disks will be instantiated. We have to put this in the <code>sr</code> attribute in
the disk provisioning XML stored under the &ldquo;<code>disks</code>&rdquo; key in the
<code>other_config</code> map of the newly-created VM. This field can be updated by
calling its getter (<code>other_config &lt;- VM.get_other_config(session, new_vm_ref)</code>) and then its setter (<code>VM.set_other_config(session, new_vm_ref, other_config)</code>) with the modified <code>other_config</code> map.</p></li><li><p>At this stage the object referred to by <code>new_vm_ref</code> is still a template (just like the VM object referred to by <code>t_ref</code>, from which it was cloned). To make <code>new_vm_ref</code> into a VM object we need to call <code>VM.provision(session, new_vm_ref)</code>. When this call returns the <code>new_vm_ref</code> object will have had its <code>is_a_template</code> field set to false, indicating that <code>new_vm_ref</code> now refers to a regular VM ready for starting.</p></li></ul><blockquote><p><strong>Note</strong></p><p>The provision operation may take a few minutes, as it is as during this call that the template&rsquo;s disk images are created. In the case of the Debian template, the newly created disks are also at this stage populated with a Debian root filesystem.</p></blockquote><h3 id=taking-the-vm-through-a-startsuspendresumestop-cycle>Taking the VM through a start/suspend/resume/stop cycle</h3><p>Now we have an object reference representing our newly-installed VM, it is trivial to take it through a few lifecycle operations:</p><ul><li><p>To start our VM we can just call <code>VM.start(session, new_vm_ref)</code></p></li><li><p>After it&rsquo;s running, we can suspend it by calling <code>VM.suspend(session, new_vm_ref)</code>,</p></li><li><p>and then resume it by calling <code>VM.resume(session, new_vm_ref)</code>.</p></li><li><p>We can call <code>VM.shutdown(session, new_vm_ref)</code> to shutdown the VM cleanly.</p></li></ul><h3 id=logging-out>Logging out</h3><p>Once an application is finished interacting with a XenServer Host it is good practice to call <code>Session.logout(session)</code>. This invalidates the session reference (so it cannot be used in subsequent API calls) and simultaneously deallocates server-side memory used to store the session object.</p><p>Although inactive sessions will eventually timeout, the server has a hardcoded limit of 500 concurrent sessions for each <code>username</code> or <code>originator</code>. Once this limit has been reached fresh logins will evict the session objects that have been used least recently, causing their associated session references to become invalid. For successful interoperability with other applications, concurrently accessing the server, the best policy is:</p><ul><li><p>Choose a string that identifies your application and its version.</p></li><li><p>Create a single session at start-of-day, using that identifying string for the <code>originator</code> parameter to <code>Session.login_with_password</code>.</p></li><li><p>Use this session throughout the application (note that sessions can be used across multiple separate client-server <em>network connections</em>) and then explicitly logout when possible.</p></li></ul><p>If a poorly written client leaks sessions or otherwise exceeds the limit, then as long as the client uses an appropriate <code>originator</code> argument, it will be easily identifiable from the XenServer logs and XenServer will destroy the longest-idle sessions of the rogue client only; this may cause problems for that client but not for other clients. If the misbehaving client did not specify an <code>originator</code>, it would be harder to identify and would cause the premature destruction of sessions of any clients that also did not specify an <code>originator</code></p><h3 id=install-and-start-example-summary>Install and start example: summary</h3><p>We have seen how the API can be used to install a VM from a XenServer template and perform a number of lifecycle operations on it. You will note that the number of calls we had to make in order to affect these operations was small:</p><ul><li><p>One call to acquire a session: <code>Session.login_with_password()</code></p></li><li><p>One call to query the VM (and template) objects present on the XenServer installation: <code>VM.get_all_records()</code>. Recall that we used the information returned from this call to select a suitable template to install from.</p></li><li><p>Four calls to install a VM from our chosen template: <code>VM.clone()</code>, followed
by the getter and setter of the <code>other_config</code> field to specify where to
create the disk images of the template, and then <code>VM.provision()</code>.</p></li><li><p>One call to start the resultant VM: <code>VM.start()</code> (and similarly other single calls to suspend, resume and shutdown accordingly)</p></li><li><p>And then one call to logout <code>Session.logout()</code></p></li></ul><p>The take-home message here is that, although the API as a whole is complex and fully featured, common tasks (such as creating and performing lifecycle operations on VMs) are very straightforward to perform, requiring only a small number of simple API calls. Keep this in mind while you study the next section which may, on first reading, appear a little daunting!</p><h2 id=object-model-overview>Object Model Overview</h2><p>This section gives a high-level overview of the object model of the API. A more detailed description of the parameters and methods of each class outlined here can be found in the XenServer API Reference document.</p><p>We start by giving a brief outline of some of the core classes that make up the API. (Don&rsquo;t worry if these definitions seem somewhat abstract in their initial presentation; the textual description in subsequent sections, and the code-sample walk through in the next Chapter will help make these concepts concrete.)</p><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td>VM</td><td>A VM object represents a particular virtual machine instance on a XenServer Host or Resource Pool. Example methods include <code>start</code>, <code>suspend</code>, <code>pool_migrate</code>; example parameters include <code>power_state</code>, <code>memory_static_max</code>, and <code>name_label</code>. (In the previous section we saw how the VM class is used to represent both templates and regular VMs)</td></tr><tr><td>Host</td><td>A host object represents a physical host in a XenServer pool. Example methods include <code>reboot</code> and <code>shutdown</code>. Example parameters include <code>software_version</code>, <code>hostname</code>, and [IP] <code>address</code>.</td></tr><tr><td>VDI</td><td>A VDI object represents a <em>Virtual Disk Image</em>. Virtual Disk Images can be attached to VMs, in which case a block device appears inside the VM through which the bits encapsulated by the Virtual Disk Image can be read and written. Example methods of the VDI class include &ldquo;resize&rdquo; and &ldquo;clone&rdquo;. Example fields include &ldquo;virtual_size&rdquo; and &ldquo;sharable&rdquo;. (When we called <code>VM.provision</code> on the VM template in our previous example, some VDI objects were automatically created to represent the newly created disks, and attached to the VM object.)</td></tr><tr><td>SR</td><td>An SR (<em>Storage Repository</em>) aggregates a collection of VDIs and encapsulates the properties of physical storage on which the VDIs&rsquo; bits reside. Example parameters include <code>type</code> (which determines the storage-specific driver a XenServer installation uses to read/write the SR&rsquo;s VDIs) and <code>physical_utilisation</code>; example methods include <code>scan</code> (which invokes the storage-specific driver to acquire a list of the VDIs contained with the SR and the properties of these VDIs) and <code>create</code> (which initializes a block of physical storage so it is ready to store VDIs).</td></tr><tr><td>Network</td><td>A network object represents a layer-2 network that exists in the environment in which the XenServer Host instance lives. Since XenServer does not manage networks directly this is a lightweight class that serves merely to model physical and virtual network topology. VM and Host objects that are <em>attached</em> to a particular Network object (by virtue of VIF and PIF instances &ndash; see below) can send network packets to each other.</td></tr></tbody></table><p>At this point, readers who are finding this enumeration of classes rather terse may wish to skip to the code walk-throughs of the next chapter: there are plenty of useful applications that can be written using only a subset of the classes already described! For those who wish to continue this description of classes in the abstract, read on.</p><p>On top of the classes listed above, there are 4 more that act as <em>connectors</em>, specifying relationships between VMs and Hosts, and Storage and Networks. The first 2 of these classes that we will consider, <em>VBD</em> and <em>VIF</em>, determine how VMs are attached to virtual disks and network objects respectively:</p><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td>VBD</td><td>A VBD (<em>Virtual Block Device</em>) object represents an attachment between a VM and a VDI. When a VM is booted its VBD objects are queried to determine which disk images (VDIs) should be attached. Example methods of the VBD class include &ldquo;plug&rdquo; (which <em>hot plugs</em> a disk device into a running VM, making the specified VDI accessible therein) and &ldquo;unplug&rdquo; (which <em>hot unplugs</em> a disk device from a running guest); example fields include &ldquo;device&rdquo; (which determines the device name inside the guest under which the specified VDI will be made accessible).</td></tr><tr><td>VIF</td><td>A VIF (<em>Virtual network InterFace</em>) object represents an attachment between a VM and a Network object. When a VM is booted its VIF objects are queried to determine which network devices should be created. Example methods of the VIF class include &ldquo;plug&rdquo; (which <em>hot plugs</em> a network device into a running VM) and &ldquo;unplug&rdquo; (which <em>hot unplugs</em> a network device from a running guest).</td></tr></tbody></table><p>The second set of &ldquo;connector classes&rdquo; that we will consider determine how Hosts are attached to Networks and Storage.</p><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td>PIF</td><td>A PIF (<em>Physical InterFace</em>) object represents an attachment between a Host and a Network object. If a host is connected to a Network (over a PIF) then packets from the specified host can be transmitted/received by the corresponding host. Example fields of the PIF class include &ldquo;device&rdquo; (which specifies the device name to which the PIF corresponds &ndash; e.g. <em>eth0</em>) and &ldquo;MAC&rdquo; (which specifies the MAC address of the underlying NIC that a PIF represents). Note that PIFs abstract both physical interfaces and VLANs (the latter distinguished by the existence of a positive integer in the &ldquo;VLAN&rdquo; field).</td></tr><tr><td>PBD</td><td>A PBD (<em>Physical Block Device</em>) object represents an attachment between a Host and a SR (Storage Repository) object. Fields include &ldquo;currently-attached&rdquo; (which specifies whether the chunk of storage represented by the specified SR object) is currently available to the host; and &ldquo;device_config&rdquo; (which specifies storage-driver specific parameters that determines how the low-level storage devices are configured on the specified host &ndash; e.g. in the case of an SR rendered on an NFS filer, device_config may specify the host-name of the filer and the path on the filer in which the SR files live.).</td></tr></tbody></table><p><a href=#image-d11c3d116b3ed5eaad8788f419081714 class=lightbox-link><img src=/new-docs/xen-api/overview/dia_class_overview.svg alt="Graphical overview of API classes for managing VMs, Hosts, Storage and Networking" class="figure-image noborder lightbox noshadow" style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=image-d11c3d116b3ed5eaad8788f419081714><img src=/new-docs/xen-api/overview/dia_class_overview.svg alt="Graphical overview of API classes for managing VMs, Hosts, Storage and Networking" class="lightbox-image noborder lightbox noshadow" loading=lazy></a></p><p>The figure above presents a graphical overview of the API classes involved in managing VMs, Hosts, Storage and Networking. From this diagram, the symmetry between storage and network configuration, and also the symmetry between virtual machine and host configuration is plain to see.</p><h2 id=working-with-vifs-and-vbds>Working with VIFs and VBDs</h2><p>In this section we walk through a few more complex scenarios, describing informally how various tasks involving virtual storage and network devices can be accomplished using the API.</p><h3 id=creating-disks-and-attaching-them-to-vms>Creating disks and attaching them to VMs</h3><p>Let&rsquo;s start by considering how to make a new blank disk image and attach it to a running VM. We will assume that we already have ourselves a running VM, and we know its corresponding API object reference (e.g. we may have created this VM using the procedure described in the previous section, and had the server return its reference to us.) We will also assume that we have authenticated with the XenServer installation and have a corresponding <code>session reference</code>. Indeed in the rest of this chapter, for the sake of brevity, we will stop mentioning sessions altogether.</p><h4 id=creating-a-new-blank-disk-image>Creating a new blank disk image</h4><p>The first step is to instantiate the disk image on physical storage. We do this by calling <code>VDI.create()</code>. The <code>VDI.create</code> call takes a number of parameters, including:</p><ul><li><p><code>name_label</code> and <code>name_description</code>: a human-readable name/description for the disk (e.g. for convenient display in the UI etc.). These fields can be left blank if desired.</p></li><li><p><code>SR</code>: the object reference of the Storage Repository representing the physical storage in which the VDI&rsquo;s bits will be placed.</p></li><li><p><code>read_only</code>: setting this field to true indicates that the VDI can <em>only</em> be attached to VMs in a read-only fashion. (Attempting to attach a VDI with its <code>read_only</code> field set to true in a read/write fashion results in error.)</p></li></ul><p>Invoking the <code>VDI.create</code> call causes the XenServer installation to create a blank disk image on physical storage, create an associated VDI object (the datamodel instance that refers to the disk image on physical storage) and return a reference to this newly created VDI object.</p><p>The way in which the disk image is represented on physical storage depends on the type of the SR in which the created VDI resides. For example, if the SR is of type &ldquo;lvm&rdquo; then the new disk image will be rendered as an LVM volume; if the SR is of type &ldquo;nfs&rdquo; then the new disk image will be a sparse VHD file created on an NFS filer. (You can query the SR type through the API using the <code>SR.get_type()</code> call.)</p><blockquote><p><strong>Note</strong></p><p>Some SR types might round up the <code>virtual-size</code> value to make it divisible by a configured block size.</p></blockquote><h4 id=attaching-the-disk-image-to-a-vm>Attaching the disk image to a VM</h4><p>So far we have a running VM (that we assumed the existence of at the start of this example) and a fresh VDI that we just created. Right now, these are both independent objects that exist on the XenServer Host, but there is nothing linking them together. So our next step is to create such a link, associating the VDI with our VM.</p><p>The attachment is formed by creating a new &ldquo;connector&rdquo; object called a VBD (<em>Virtual Block Device</em>). To create our VBD we invoke the <code>VBD.create()</code> call. The <code>VBD.create()</code> call takes a number of parameters including:</p><ul><li><p><code>VM</code> - the object reference of the VM to which the VDI is to be attached</p></li><li><p><code>VDI</code> - the object reference of the VDI that is to be attached</p></li><li><p><code>mode</code> - specifies whether the VDI is to be attached in a read-only or a read-write fashion</p></li><li><p><code>userdevice</code> - specifies the block device inside the guest through which applications running inside the VM will be able to read/write the VDI&rsquo;s bits.</p></li><li><p><code>type</code> - specifies whether the VDI should be presented inside the VM as a regular disk or as a CD. (Note that this particular field has more meaning for Windows VMs than it does for Linux VMs, but we will not explore this level of detail in this chapter.)</p></li></ul><p>Invoking <code>VBD.create</code> makes a VBD object on the XenServer installation and returns its object reference. However, this call in itself does not have any side-effects on the running VM (that is, if you go and look inside the running VM you will see that the block device has not been created). The fact that the VBD object exists but that the block device in the guest is not active, is reflected by the fact that the VBD object&rsquo;s <code>currently_attached</code> field is set to false.</p><p><a href=#image-172f6f3522cefec5815ff69a99a94a4e class=lightbox-link><img src=/new-docs/xen-api/overview/dia_vm_sr.svg alt="A VM object with 2 associated VDIs" class="figure-image noborder lightbox noshadow" style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=image-172f6f3522cefec5815ff69a99a94a4e><img src=/new-docs/xen-api/overview/dia_vm_sr.svg alt="A VM object with 2 associated VDIs" class="lightbox-image noborder lightbox noshadow" loading=lazy></a></p><p>For expository purposes, the figure above presents a graphical example that shows the relationship between VMs, VBDs, VDIs and SRs. In this instance a VM object has 2 attached VDIs: there are 2 VBD objects that form the connections between the VM object and its VDIs; and the VDIs reside within the same SR.</p><h4 id=hotplugging-the-vbd>Hotplugging the VBD</h4><p>If we rebooted the VM at this stage then, after rebooting, the block device corresponding to the VBD would appear: on boot, XenServer queries all VBDs of a VM and actively attaches each of the corresponding VDIs.</p><p>Rebooting the VM is all very well, but recall that we wanted to attach a newly created blank disk to a <em>running</em> VM. This can be achieved by invoking the <code>plug</code> method on the newly created VBD object. When the <code>plug</code> call returns successfully, the block device to which the VBD relates will have appeared inside the running VM &ndash; i.e. from the perspective of the running VM, the guest operating system is led to believe that a new disk device has just been <em>hot plugged</em>. Mirroring this fact in the managed world of the API, the <code>currently_attached</code> field of the VBD is set to true.</p><p>Unsurprisingly, the VBD <code>plug</code> method has a dual called &ldquo;<code>unplug</code>&rdquo;. Invoking the <code>unplug</code> method on a VBD object causes the associated block device to be <em>hot unplugged</em> from a running VM, setting the <code>currently_attached</code> field of the VBD object to false accordingly.</p><h3 id=creating-and-attaching-network-devices-to-vms>Creating and attaching Network Devices to VMs</h3><p>The API calls involved in configuring virtual network interfaces in VMs are similar in many respects to the calls involved in configuring virtual disk devices. For this reason we will not run through a full example of how one can create network interfaces using the API object-model; instead we will use this section just to outline briefly the symmetry between virtual <em>networking device</em> and virtual <em>storage device</em> configuration.</p><p>The networking analogue of the VBD class is the VIF class. Just as a VBD is the API representation of a block device inside a VM, a VIF (<em>Virtual network InterFace</em>) is the API representation of a network device inside a VM. Whereas VBDs associate VM objects with VDI objects, VIFs associate VM objects with Network objects. Just like VBDs, VIFs have a <code>currently_attached</code> field that determines whether or not the network device (inside the guest) associated with the VIF is currently active or not. And as we saw with VBDs, at VM boot-time the VIFs of the VM are queried and a corresponding network device for each created inside the booting VM. Similarly, VIFs also have <code>plug</code> and <code>unplug</code> methods for hot plugging/unplugging network devices in/out of running VMs.</p><h3 id=host-configuration-for-networking-and-storage>Host configuration for networking and storage</h3><p>We have seen that the VBD and VIF classes are used to manage configuration of block devices and network devices (respectively) inside VMs. To manage host configuration of storage and networking there are two analogous classes: PBD (<em>Physical Block Device</em>) and PIF (<em>Physical [network] InterFace</em>).</p><h4 id=host-storage-configuration-pbds>Host storage configuration: PBDs</h4><p>Let us start by considering the PBD class. A <code>PBD_create()</code> call takes a number of parameters including:</p><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>host</td><td>physical machine on which the PBD is available</td></tr><tr><td>SR</td><td>the Storage Repository that the PBD connects to</td></tr><tr><td>device_config</td><td>a string-to-string map that is provided to the host&rsquo;s SR-backend-driver, containing the low-level parameters required to configure the physical storage device(s) on which the SR is to be realized. The specific contents of the <code>device_config</code> field depend on the type of the SR to which the PBD is connected. (Executing <code>xe sm-list</code> will show a list of possible SR types; the <em>configuration</em> field in this enumeration specifies the <code>device_config</code> parameters that each SR type expects.)</td></tr></tbody></table><p>For example, imagine we have an SR object <em>s</em> of type &ldquo;nfs&rdquo; (representing a directory on an NFS filer within which VDIs are stored as VHD files); and let&rsquo;s say that we want a host, <em>h</em>, to be able to access <em>s</em>. In this case we invoke <code>PBD.create()</code> specifying host <em>h</em>, SR <em>s</em>, and a value for the <em>device_config</em> parameter that is the following map:</p><p><code>("server", "my_nfs_server.example.com"), ("serverpath", "/scratch/mysrs/sr1")</code></p><p>This tells the XenServer Host that SR <em>s</em> is accessible on host <em>h</em>, and further that to access SR <em>s</em>, the host needs to mount the directory <code>/scratch/mysrs/sr1</code> on the NFS server named <code>my_nfs_server.example.com</code>.</p><p>Like VBD objects, PBD objects also have a field called <code>currently_attached</code>. Storage repositories can be attached and detached from a given host by invoking <code>PBD.plug</code> and <code>PBD.unplug</code> methods respectively.</p><h4 id=host-networking-configuration-pifs>Host networking configuration: PIFs</h4><p>Host network configuration is specified by virtue of PIF objects. If a PIF object connects a network object, <em>n</em>, to a host object <em>h</em>, then the network corresponding to <em>n</em> is bridged onto a physical interface (or a physical interface plus a VLAN tag) specified by the fields of the PIF object.</p><p>For example, imagine a PIF object exists connecting host <em>h</em> to a network <em>n</em>, and that <code>device</code> field of the PIF object is set to <code>eth0</code>. This means that all packets on network <em>n</em> are bridged to the NIC in the host corresponding to host network device <code>eth0</code>.</p><h2 id=xml-rpc-notes>XML-RPC notes</h2><h3 id=datetimes>Datetimes</h3><p>The API deviates from the XML-RPC specification in handling of datetimes. The API appends a &ldquo;Z&rdquo; to the end of datetime strings, which is meant to indicate that the time is expressed in UTC.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=api-evolution>API evolution</h1><p>All APIs evolve as bugs are fixed, new features added and features are removed</p><ul><li>the XenAPI is no exception. This document lists policies describing how the
XenAPI evolves over time.</li></ul><p>The goals of XenAPI evolution are:</p><ul><li>to allow bugs to be fixed efficiently;</li><li>to allow new, innovative features to be added easily;</li><li>to keep old, unmodified clients working as much as possible; and</li><li>where backwards-incompatible changes are to be made, publish this
information early to enable affected parties to give timely feedback.</li></ul><h2 id=background>Background</h2><p>In this document, the term <em>XenAPI</em> refers to the XMLRPC-derived wire protocol
used by xapi. The XenAPI has <em>objects</em> which each have <em>fields</em> and
<em>messages</em>. The XenAPI is described in detail elsewhere.</p><h2 id=xenapi-lifecycle>XenAPI Lifecycle</h2><div class="mermaid align-center">graph LR
Prototype -->|1| Published -->|4| Deprecated -->|5| Removed
Published -->|2,3| Published</div><p>Each element of the XenAPI (objects, messages and fields) follows the lifecycle
diagram above. When an element is newly created and being still in development,
it is in the <em>Prototype</em> state. Elements in this state may be stubs: the
interface is there and can be used by clients for prototyping their new
features, but the actual implementation is not yet ready.</p><p>When the element subsequently becomes ready for use (the stub is replaced by a
real implementation), it transitions to the <em>Published</em> state. This is the only
state in which the object, message or field should be used. From this point
onwards, the element needs to have clearly defined semantics that are available
for reference in the XenAPI documentation.</p><p>If the XenAPI element becomes <em>Deprecated</em>, it will still function as it did
before, but its use is discouraged. The final stage of the lifecycle is the
<em>Removed</em> state, in which the element is not available anymore.</p><p>The numbered state changes in the diagram have the following meaning:</p><ol><li>Publish: declare that the XenAPI element is ready for people to use.</li><li>Extend: a <em>backwards-compatible</em> extension of the XenAPI, for example an
additional parameter in a message with an appropriate default value. If the
API is used as before, it still has the same effect.</li><li>Change: a <em>backwards-incompatible</em> change. That is, the message now behaves
differently, or the field has different semantics. Such changes are
discouraged and should only be considered in special cases (always consider
whether deprecation is a better solution). The use of a message can for
example be restricted for security or efficiency reasons, or the behaviour
can be changed simply to fix a bug.</li><li>Deprecate: declare that the use of this XenAPI element should be avoided from
now on. Reasons for doing this include: the element is redundant (it
duplicates functionality elsewhere), it is inconsistent with other parts of
the XenAPI, it is insecure or inefficient (for examples of deprecation
policies of other projects, see
<a href=http://developer.symbian.org/wiki/index.php/Public_API_Change_Control_Process target=_blank>symbian</a>
<a href=http://wiki.eclipse.org/Eclipse/API_Central/Deprecation_Policy target=_blank>eclipse</a>
<a href=http://oval.mitre.org/language/about/deprecation.html target=_blank>oval</a>.</li><li>Remove: the element is taken out of the public API and can no longer be used.</li></ol><p>Each lifecycle transition must be accompanied by an explanation describing the
change and the reason for the change. This message should be enough to
understand the semantics of the XenAPI element after the change, and in the case
of backwards-incompatible changes or deprecation, it should give directions
about how to modify a client to deal with the change (for example, how to avoid
using the deprecated field or message).</p><h2 id=releases>Releases</h2><p>Every release must be accompanied by <em>release notes</em> listing all objects, fields
and messages that are newly prototyped, published, extended, changed, deprecated
or removed in the release. Each item should have an explanation as implied
above, documenting the new or changed XenAPI element. The release notes for
every release shall be prominently displayed in the XenAPI HTML documentation.</p><h2 id=documentation>Documentation</h2><p>The XenAPI documentation will contain its complete lifecycle history for each
XenAPI element. Only the elements described in the documentation are
&ldquo;official&rdquo; and supported.</p><p>Each object, message and field in <code>datamodel.ml</code> will have lifecycle
metadata attached to it, which is a list of transitions (transition type *
release * explanation string) as described above. Release notes are automatically generated from this data.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=using-the-api>Using the API</h1><p>This chapter describes how to use the XenServer Management API from real programs to manage XenServer Hosts and VMs. The chapter begins with a walk-through of a typical client application and demonstrates how the API can be used to perform common tasks. Example code fragments are given in python syntax but equivalent code in the other programming languages would look very similar. The language bindings themselves are discussed afterwards and the chapter finishes with walk-throughs of two complete examples.</p><h2 id=anatomy-of-a-typical-application>Anatomy of a typical application</h2><p>This section describes the structure of a typical application using the XenServer Management API. Most client applications begin by connecting to a XenServer Host and authenticating (e.g. with a username and password). Assuming the authentication succeeds, the server will create a &ldquo;session&rdquo; object and return a reference to the client. This reference will be passed as an argument to all future API calls. Once authenticated, the client may search for references to other useful objects (e.g. XenServer Hosts, VMs, etc.) and invoke operations on them. Operations may be invoked either synchronously or asynchronously; special task objects represent the state and progress of asynchronous operations. These application elements are all described in detail in the following sections.</p><h3 id=choosing-a-low-level-transport>Choosing a low-level transport</h3><p>API calls can be issued over two transports:</p><ul><li><p>SSL-encrypted TCP on port 443 (https) over an IP network</p></li><li><p>plaintext over a local Unix domain socket: <code>/var/xapi/xapi</code></p></li></ul><p>The SSL-encrypted TCP transport is used for all off-host traffic while the Unix domain socket can be used from services running directly on the XenServer Host itself. In the SSL-encrypted TCP transport, all API calls should be directed at the Resource Pool master; failure to do so will result in the error <code>HOST_IS_SLAVE</code>, which includes the IP address of the master as an error parameter.</p><p>Because the master host of a pool can change, especially if HA is enabled on a pool, clients must implement the following steps to detect a master host change and connect to the new master as required:</p><p>Subscribe to updates in the list of hosts servers, and maintain a current list of hosts in the pool</p><p>If the connection to the pool master fails to respond, attempt to connect to all hosts in the list until one responds</p><p>The first host to respond will return the <code>HOST_IS_SLAVE</code> error message, which contains the identity of the new pool master (unless of course the host is the new master)</p><p>Connect to the new master</p><blockquote><p><strong>Note</strong></p><p>As a special-case, all messages sent through the Unix domain socket are transparently forwarded to the correct node.</p></blockquote><h3 id=authentication-and-session-handling>Authentication and session handling</h3><p>The vast majority of API calls take a session reference as their first parameter; failure to supply a valid reference will result in a <code>SESSION_INVALID</code> error being returned. Acquire a session reference by supplying a username and password to the <code>login_with_password</code> function.</p><blockquote><p><strong>Note</strong></p><p>As a special-case, if this call is executed over the local Unix domain socket then the username and password are ignored and the call always succeeds.</p></blockquote><p>Every session has an associated &ldquo;last active&rdquo; timestamp which is updated on every API call. The server software currently has a built-in limit of 500 active sessions and will remove those with the oldest &ldquo;last active&rdquo; field if this limit is exceeded for a given <code>username</code> or <code>originator</code>. In addition all sessions whose &ldquo;last active&rdquo; field is older than 24 hours are also removed. Therefore it is important to:</p><ul><li><p>Specify an appropriate <code>originator</code> when logging in; and</p></li><li><p>Remember to log out of active sessions to avoid leaking them; and</p></li><li><p>Be prepared to log in again to the server if a <code>SESSION_INVALID</code> error is caught.</p></li></ul><p>In the following Python fragment a connection is established over the Unix domain socket and a session is created:</p><pre><code>import XenAPI

    session = XenAPI.xapi_local()
    try:
        session.xenapi.login_with_password(&quot;root&quot;, &quot;&quot;, &quot;2.3&quot;, &quot;My Widget v0.1&quot;)
        ...
    finally:
        session.xenapi.session.logout()
</code></pre><h3 id=finding-references-to-useful-objects>Finding references to useful objects</h3><p>Once an application has authenticated the next step is to acquire references to objects in order to query their state or invoke operations on them. All objects have a set of &ldquo;implicit&rdquo; messages which include the following:</p><ul><li><p><code>get_by_name_label</code> : return a list of all objects of a particular class with a particular label;</p></li><li><p><code>get_by_uuid</code> : return a single object named by its UUID;</p></li><li><p><code>get_all</code> : return a set of references to all objects of a particular class; and</p></li><li><p><code>get_all_records</code> : return a map of reference to records for each object of a particular class.</p></li></ul><p>For example, to list all hosts:</p><pre><code>hosts = session.xenapi.host.get_all()
</code></pre><p>To find all VMs with the name &ldquo;my first VM&rdquo;:</p><pre><code>vms = session.xenapi.VM.get_by_name_label('my first VM')
</code></pre><blockquote><p><strong>Note</strong></p><p>Object <code>name_label</code> fields are not guaranteed to be unique and so the <code>get_by_name_label</code> API call returns a set of references rather than a single reference.</p></blockquote><p>In addition to the methods of finding objects described above, most objects also contain references to other objects within fields. For example it is possible to find the set of VMs running on a particular host by calling:</p><pre><code>vms = session.xenapi.host.get_resident_VMs(host)
</code></pre><h3 id=invoking-synchronous-operations-on-objects>Invoking synchronous operations on objects</h3><p>Once object references have been acquired, operations may be invoked on them. For example to start a VM:</p><pre><code>session.xenapi.VM.start(vm, False, False)
</code></pre><p>All API calls are by default synchronous and will not return until the operation has completed or failed. For example in the case of <code>VM.start</code> the call does not return until the VM has started booting.</p><blockquote><p><strong>Note</strong></p><p>When the <code>VM.start</code> call returns the VM will be booting. To determine when the booting has finished, wait for the in-guest agent to report internal statistics through the <code>VM_guest_metrics</code> object.</p></blockquote><h3 id=using-tasks-to-manage-asynchronous-operations>Using Tasks to manage asynchronous operations</h3><p>To simplify managing operations which take quite a long time (e.g. <code>VM.clone</code> and <code>VM.copy</code>) functions are available in two forms: synchronous (the default) and asynchronous. Each asynchronous function returns a reference to a task object which contains information about the in-progress operation including:</p><ul><li><p>whether it is pending</p></li><li><p>whether it is has succeeded or failed</p></li><li><p>progress (in the range 0-1)</p></li><li><p>the result or error code returned by the operation</p></li></ul><p>An application which wanted to track the progress of a <code>VM.clone</code> operation and display a progress bar would have code like the following:</p><pre><code>vm = session.xenapi.VM.get_by_name_label('my vm')
task = session.xenapi.Async.VM.clone(vm)
while session.xenapi.task.get_status(task) == &quot;pending&quot;:
        progress = session.xenapi.task.get_progress(task)
        update_progress_bar(progress)
        time.sleep(1)
session.xenapi.task.destroy(task)
</code></pre><blockquote><p><strong>Note</strong></p><p>Note that a well-behaved client should remember to delete tasks created by asynchronous operations when it has finished reading the result or error. If the number of tasks exceeds a built-in threshold then the server will delete the oldest of the completed tasks.</p></blockquote><h3 id=subscribing-to-and-listening-for-events>Subscribing to and listening for events</h3><p>With the exception of the task and metrics classes, whenever an object is modified the server generates an event. Clients can subscribe to this event stream on a per-class basis and receive updates rather than resorting to frequent polling. Events come in three types:</p><ul><li><p><code>add</code> - generated when an object has been created;</p></li><li><p><code>del</code> - generated immediately before an object is destroyed; and</p></li><li><p><code>mod</code> - generated when an object&rsquo;s field has changed.</p></li></ul><p>Events also contain a monotonically increasing ID, the name of the class of object and a snapshot of the object state equivalent to the result of a <code>get_record()</code>.</p><p>Clients register for events by calling <code>event.register()</code> with a list of class names or the special string &ldquo;*&rdquo;. Clients receive events by executing <code>event.next()</code> which blocks until events are available and returns the new events.</p><blockquote><p><strong>Note</strong></p><p>Since the queue of generated events on the server is of finite length a very slow client might fail to read the events fast enough; if this happens an <code>EVENTS_LOST</code> error is returned. Clients should be prepared to handle this by re-registering for events and checking that the condition they are waiting for hasn&rsquo;t become true while they were unregistered.</p></blockquote><p>The following python code fragment demonstrates how to print a summary of every event generated by a system: (similar code exists in <code>Xenserver-SDK/XenServerPython/samples/watch-all-events.py</code>)</p><pre><code>fmt = &quot;%8s  %20s  %5s  %s&quot;
session.xenapi.event.register([&quot;*&quot;])
while True:
    try:
        for event in session.xenapi.event.next():
            name = &quot;(unknown)&quot;
            if &quot;snapshot&quot; in event.keys():
                snapshot = event[&quot;snapshot&quot;]
                if &quot;name_label&quot; in snapshot.keys():
                    name = snapshot[&quot;name_label&quot;]
            print fmt % (event['id'], event['class'], event['operation'], name)           
    except XenAPI.Failure, e:
        if e.details == [ &quot;EVENTS_LOST&quot; ]:
            print &quot;Caught EVENTS_LOST; should reregister&quot;
</code></pre><h2 id=language-bindings>Language bindings</h2><h3 id=c>C</h3><p>The SDK includes the source to the C language binding in the directory <code>XenServer-SDK/libxenserver/src</code> together with a Makefile which compiles the binding into a library. Every API object is associated with a header file which contains declarations for all that object&rsquo;s API functions; for example the type definitions and functions required to invoke VM operations are all contained in <code>xen_vm.h</code>.</p><p><strong>C binding dependencies</strong></p><p>The following simple examples are included with the C bindings:</p><ul><li><p><code>test_vm_async_migrate</code>: demonstrates how to use asynchronous API calls to migrate running VMs from a slave host to the pool master.</p></li><li><p><code>test_vm_ops</code>: demonstrates how to query the capabilities of a host, create a VM, attach a fresh blank disk image to the VM and then perform various powercycle operations;</p></li><li><p><code>test_failures</code>: demonstrates how to translate error strings into enum_xen_api_failure, and vice versa;</p></li><li><p><code>test_event_handling</code>: demonstrates how to listen for events on a connection.</p></li><li><p><code>test_enumerate</code>: demonstrates how to enumerate the various API objects.</p></li></ul><h3 id=c35>C#</h3><p>The C# bindings are contained within the directory <code>XenServer-SDK/XenServer.NET</code> and include project files suitable for building under Microsoft Visual Studio. Every API object is associated with one C# file; for example the functions implementing the VM operations are contained within the file <code>VM.cs</code>.</p><p><strong>C# binding dependencies</strong></p><p>Three examples are included with the C# bindings in the directory <code>XenServer-SDK/XenServer.NET/samples</code> as separate projects of the <code>XenSdkSample.sln</code> solution:</p><ul><li><p><code>GetVariousRecords</code>: logs into a XenServer Host and displays information about hosts, storage and virtual machines;</p></li><li><p><code>GetVmRecords</code>: logs into a XenServer Host and lists all the VM records;</p></li><li><p><code>VmPowerStates</code>: logs into a XenServer Host, finds a VM and takes it through the various power states. Requires a shut-down VM to be already installed.</p></li></ul><h3 id=java>Java</h3><p>The Java bindings are contained within the directory <code>XenServer-SDK/XenServerJava</code> and include project files suitable for building under Microsoft Visual Studio. Every API object is associated with one Java file; for example the functions implementing the VM operations are contained within the file <code>VM.java</code>.</p><p><strong>Java binding dependencies</strong></p><p>Running the main file <code>XenServer-SDK/XenServerJava/samples/RunTests.java</code> will run a series of examples included in the same directory:</p><ul><li><p><code>AddNetwork</code>: Adds a new internal network not attached to any NICs;</p></li><li><p><code>SessionReuse</code>: Demonstrates how a Session object can be shared between multiple Connections;</p></li><li><p><code>AsyncVMCreate</code>: Makes asynchronously a new VM from a built-in template, starts and stops it;</p></li><li><p><code>VdiAndSrOps</code>: Performs various SR and VDI tests, including creating a dummy SR;</p></li><li><p><code>CreateVM</code>: Creates a VM on the default SR with a network and DVD drive;</p></li><li><p><code>DeprecatedMethod</code>: Tests a warning is displayed wehn a deprecated API method is called;</p></li><li><p><code>GetAllRecordsOfAllTypes</code>: Retrieves all the records for all types of objects;</p></li><li><p><code>SharedStorage</code>: Creates a shared NFS SR;</p></li><li><p><code>StartAllVMs</code>: Connects to a host and tries to start each VM on it.</p></li></ul><h3 id=powershell>PowerShell</h3><p>The PowerShell bindings are contained within the directory <code>XenServer-SDK/XenServerPowerShell</code>. We provide the PowerShell module <code>XenServerPSModule</code> and source code exposing the XenServer API as Windows PowerShell cmdlets.</p><p><strong>PowerShell binding dependencies</strong></p><p>These example scripts are included with the PowerShell bindings in the directory <code>XenServer-SDK/XenServerPowerShell/samples</code>:</p><ul><li><p><code>AutomatedTestCore.ps1</code>: demonstrates how to log into a XenServer host, create a storage repository and a VM, and then perform various powercycle operations;</p></li><li><p><code>HttpTest.ps1</code>: demonstrates how to log into a XenServer host, create a VM, and then perform operations such as VM importing and exporting, patch upload, and retrieval of performance statistics.</p></li></ul><h3 id=python>Python</h3><p>The python bindings are contained within a single file: <code>XenServer-SDK/XenServerPython/XenAPI.py</code>.</p><p><strong>Python binding dependencies</strong></p><p>|:&ndash;|:&ndash;|
|Platform supported:|Linux|
|Library:|XenAPI.py|
|Dependencies:|None|</p><p>The SDK includes 7 python examples:</p><ul><li><p><code>fixpbds.py</code> - reconfigures the settings used to access shared storage;</p></li><li><p><code>install.py</code> - installs a Debian VM, connects it to a network, starts it up and waits for it to report its IP address;</p></li><li><p><code>license.py</code> - uploads a fresh license to a XenServer Host;</p></li><li><p><code>permute.py</code> - selects a set of VMs and uses XenMotion to move them simultaneously between hosts;</p></li><li><p><code>powercycle.py</code> - selects a set of VMs and powercycles them;</p></li><li><p><code>shell.py</code> - a simple interactive shell for testing;</p></li><li><p><code>vm_start_async.py</code> - demonstrates how to invoke operations asynchronously;</p></li><li><p><code>watch-all-events.py</code> - registers for all events and prints details when they occur.</p></li></ul><h3 id=command-line-interface-cli>Command Line Interface (CLI)</h3><p>Besides using raw XML-RPC or one of the supplied language bindings, third-party software developers may integrate with XenServer Hosts by using the XE command line interface <code>xe</code>. The xe CLI is installed by default on XenServer hosts; a stand-alone remote CLI is also available for Linux. On Windows, the <code>xe.exe</code> CLI executable is installed along with XenCenter.</p><p><strong>CLI dependencies</strong></p><p>|:&ndash;|:&ndash;|
|Platform supported:|Linux and Windows|
|Library:|None|
|Binary:|xe (xe.exe on Windows)|
|Dependencies:|None|</p><p>The CLI allows almost every API call to be directly invoked from a script or other program, silently taking care of the required session management.
The XE CLI syntax and capabilities are described in detail in the <a href=https://docs.citrix.com/en-us/citrix-hypervisor/command-line-interface.html target=_blank>XenServer Administrator&rsquo;s Guide</a>. For additional resources and examples, visit the <a href=http://support.citrix.com target=_blank>Citrix Knowledge Center</a>.</p><blockquote><p><strong>Note</strong></p><p>When running the CLI from a XenServer Host console, tab-completion of both command names and arguments is available.</p></blockquote><h2 id=complete-application-examples>Complete application examples</h2><p>This section describes two complete examples of real programs using the API.</p><h3 id=simultaneously-migrating-vms-using-xenmotion>Simultaneously migrating VMs using XenMotion</h3><p>This python example (contained in <code>XenServer-SDK/XenServerPython/samples/permute.py</code>) demonstrates how to use XenMotion to move VMs simultaneously between hosts in a Resource Pool. The example makes use of asynchronous API calls and shows how to wait for a set of tasks to complete.</p><p>The program begins with some standard boilerplate and imports the API bindings module</p><pre><code>import sys, time
import XenAPI
</code></pre><p>Next the commandline arguments containing a server URL, username, password and a number of iterations are parsed. The username and password are used to establish a session which is passed to the function <code>main</code>, which is called multiple times in a loop. Note the use of <code>try: finally:</code> to make sure the program logs out of its session at the end.</p><pre><code>if __name__ == &quot;__main__&quot;:
    if len(sys.argv) &lt;&gt; 5:
        print &quot;Usage:&quot;
        print sys.argv[0], &quot; &lt;url&gt; &lt;username&gt; &lt;password&gt; &lt;iterations&gt;&quot;
        sys.exit(1)
    url = sys.argv[1]
    username = sys.argv[2]
    password = sys.argv[3]
    iterations = int(sys.argv[4])
    # First acquire a valid session by logging in:
    session = XenAPI.Session(url)
    session.xenapi.login_with_password(username, password, &quot;2.3&quot;,
                                       &quot;Example migration-demo v0.1&quot;)
    try:
        for i in range(iterations):
            main(session, i)
    finally:
        session.xenapi.session.logout()
</code></pre><p>The <code>main</code> function examines each running VM in the system, taking care to filter out <em>control domains</em> (which are part of the system and not controllable by the user). A list of running VMs and their current hosts is constructed.</p><pre><code>def main(session, iteration):
    # Find a non-template VM object
    all = session.xenapi.VM.get_all()
    vms = []
    hosts = []
    for vm in all:
        record = session.xenapi.VM.get_record(vm)
        if not(record[&quot;is_a_template&quot;]) and \
           not(record[&quot;is_control_domain&quot;]) and \
           record[&quot;power_state&quot;] == &quot;Running&quot;:
            vms.append(vm)
            hosts.append(record[&quot;resident_on&quot;])
    print &quot;%d: Found %d suitable running VMs&quot; % (iteration, len(vms))
</code></pre><p>Next the list of hosts is rotated:</p><pre><code># use a rotation as a permutation
    hosts = [hosts[-1]] + hosts[:(len(hosts)-1)]
</code></pre><p>Each VM is then moved using XenMotion to the new host under this rotation (i.e. a VM running on host at position 2 in the list will be moved to the host at position 1 in the list etc.) In order to execute each of the movements in parallel, the asynchronous version of the <code>VM.pool_migrate</code> is used and a list of task references constructed. Note the <code>live</code> flag passed to the <code>VM.pool_migrate</code>; this causes the VMs to be moved while they are still running.</p><pre><code>tasks = []
    for i in range(0, len(vms)):
        vm = vms[i]
        host = hosts[i]
        task = session.xenapi.Async.VM.pool_migrate(vm, host, { &quot;live&quot;: &quot;true&quot; })
        tasks.append(task)
</code></pre><p>The list of tasks is then polled for completion:</p><pre><code>finished = False
    records = {}
    while not(finished):
        finished = True
        for task in tasks:
            record = session.xenapi.task.get_record(task)
            records[task] = record
            if record[&quot;status&quot;] == &quot;pending&quot;:
                finished = False
        time.sleep(1)
</code></pre><p>Once all tasks have left the <em>pending</em> state (i.e. they have successfully completed, failed or been cancelled) the tasks are polled once more to see if they all succeeded:</p><pre><code>allok = True
    for task in tasks:
        record = records[task]
        if record[&quot;status&quot;] &lt;&gt; &quot;success&quot;:
            allok = False
</code></pre><p>If any one of the tasks failed then details are printed, an exception is raised and the task objects left around for further inspection. If all tasks succeeded then the task objects are destroyed and the function returns.</p><pre><code>if not(allok):
        print &quot;One of the tasks didn't succeed at&quot;, \
            time.strftime(&quot;%F:%HT%M:%SZ&quot;, time.gmtime())
        idx = 0
        for task in tasks:
            record = records[task]
            vm_name = session.xenapi.VM.get_name_label(vms[idx])
            host_name = session.xenapi.host.get_name_label(hosts[idx])
            print &quot;%s : %12s %s -&gt; %s [ status: %s; result = %s; error = %s ]&quot; % \
                  (record[&quot;uuid&quot;], record[&quot;name_label&quot;], vm_name, host_name,      \
                   record[&quot;status&quot;], record[&quot;result&quot;], repr(record[&quot;error_info&quot;]))
            idx = idx + 1
        raise &quot;Task failed&quot;
    else:
        for task in tasks:
            session.xenapi.task.destroy(task)
</code></pre><h3 id=cloning-a-vm-using-the-xe-cli>Cloning a VM using the XE CLI</h3><p>This example is a <code>bash</code> script which uses the XE CLI to clone a VM taking care to shut it down first if it is powered on.</p><p>The example begins with some boilerplate which first checks if the environment variable <code>XE</code> has been set: if it has it assumes that it points to the full path of the CLI, else it is assumed that the XE CLI is on the current path. Next the script prompts the user for a server name, username and password:</p><pre><code># Allow the path to the 'xe' binary to be overridden by the XE environment variable
if [ -z &quot;${XE}&quot; ]; then
  XE=xe
fi

if [ ! -e &quot;${HOME}/.xe&quot; ]; then
  read -p &quot;Server name: &quot; SERVER
  read -p &quot;Username: &quot; USERNAME
  read -p &quot;Password: &quot; PASSWORD
  XE=&quot;${XE} -s ${SERVER} -u ${USERNAME} -pw ${PASSWORD}&quot;
fi
</code></pre><p>Next the script checks its commandline arguments. It requires exactly one: the UUID of the VM which is to be cloned:</p><pre><code># Check if there's a VM by the uuid specified
${XE} vm-list params=uuid | grep -q &quot; ${vmuuid}$&quot;
if [ $? -ne 0 ]; then
        echo &quot;error: no vm uuid \&quot;${vmuuid}\&quot; found&quot;
        exit 2
fi
</code></pre><p>The script then checks the power state of the VM and if it is running, it attempts a clean shutdown. The event system is used to wait for the VM to enter state &ldquo;Halted&rdquo;.</p><blockquote><p><strong>Note</strong></p><p>The XE CLI supports a command-line argument <code>--minimal</code> which causes it to print its output without excess whitespace or formatting, ideal for use from scripts. If multiple values are returned they are comma-separated.</p></blockquote><pre><code># Check the power state of the vm
name=$(${XE} vm-list uuid=${vmuuid} params=name-label --minimal)
state=$(${XE} vm-list uuid=${vmuuid} params=power-state --minimal)
wasrunning=0

# If the VM state is running, we shutdown the vm first
if [ &quot;${state}&quot; = &quot;running&quot; ]; then
        ${XE} vm-shutdown uuid=${vmuuid}
        ${XE} event-wait class=vm power-state=halted uuid=${vmuuid}
        wasrunning=1
fi
</code></pre><p>The VM is then cloned and the new VM has its <code>name_label</code> set to <code>cloned_vm</code>.</p><pre><code># Clone the VM
newuuid=$(${XE} vm-clone uuid=${vmuuid} new-name-label=cloned_vm)
</code></pre><p>Finally, if the original VM had been running and was shutdown, both it and the new VM are started.</p><pre><code># If the VM state was running before cloning, we start it again
# along with the new VM.
if [ &quot;$wasrunning&quot; -eq 1 ]; then
        ${XE} vm-start uuid=${vmuuid}
        ${XE} vm-start uuid=${newuuid}
fi
</code></pre><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenapi-reference>XenAPI Reference</h1><div><h2 class=title>XenAPI Classes</h2><p>Click on a class to view the associated fields and messages.</p><img src=/new-docs/xen-api/classes/classes.png alt="Xen-api class diagram" usemap=#graph border=0>
<map id=graph name=graph><area shape=poly href=/new-docs/xen-api/classes/task title="an asynchronous server-side task" alt coords="408,233 406,227 402,222 395,217 387,214 378,213 369,214 360,217 354,222 349,227 348,233 349,240 354,245 360,250 369,252 378,253 387,252 395,250 402,245 406,240"><area shape=poly href=/new-docs/xen-api/classes/event title="allows event registration and reading" alt coords="408,296 406,289 402,284 395,279 387,277 378,276 369,277 360,279 354,284 349,289 348,296 349,302 354,307 360,312 369,315 378,316 387,315 395,312 402,307 406,302"><area shape=poly href=/new-docs/xen-api/classes/pool title="a Resource Pool" alt coords="470,78 469,72 464,66 458,62 449,59 440,58 431,59 422,62 416,66 411,72 410,78 411,84 416,90 422,94 431,97 440,98 449,97 458,94 464,90 469,84"><area shape=rect href=/new-docs/xen-api/classes/session title="an authenticated session" alt coords=92,211,152,251><area shape=rect href=/new-docs/xen-api/classes/user title="a user" alt coords=6,201,66,241><area shape=rect href=/new-docs/xen-api/classes/host title="a physical host" alt coords=187,223,247,263><area shape=rect href=/new-docs/xen-api/classes/vm title="a Virtual Machine" alt coords=508,279,568,319><area shape=poly href=/new-docs/xen-api/classes/vm_metrics title="dynamic VM configuration information" alt coords="673,301 671,295 665,289 656,285 644,282 631,281 618,282 607,285 597,289 591,295 589,301 591,307 597,313 607,317 618,320 631,321 644,320 656,317 665,313 671,307"><area shape=poly href=/new-docs/xen-api/classes/vm_guest_metrics title="dynamic information from inside the guest" alt coords="670,360 667,354 658,348 645,344 628,341 610,340 592,341 575,344 562,348 553,354 550,360 553,366 562,372 575,376 592,379 610,380 628,379 645,376 658,372 667,366"><area shape=poly href=/new-docs/xen-api/classes/crashdump title="VM crashdump" alt coords="650,246 648,239 642,234 633,229 622,227 609,226 596,227 585,229 576,234 570,239 568,246 570,252 576,257 585,262 596,265 609,266 622,265 633,262 642,257 648,252"><area shape=poly href=/new-docs/xen-api/classes/console title="location information for a guest's console" alt coords="590,387 589,380 584,375 577,370 569,368 559,367 549,368 540,370 533,375 529,380 527,387 529,393 533,398 540,403 549,406 559,407 569,406 577,403 584,398 589,393"><area shape=rect href=/new-docs/xen-api/classes/pbd title="the connection between an SR and a host" alt coords=244,147,304,187><area shape=poly href=/new-docs/xen-api/classes/host_metrics title="dynamic host information" alt coords="202,307 199,300 193,295 183,290 170,288 156,287 141,288 128,290 118,295 112,300 109,307 112,313 118,318 128,323 141,326 156,327 170,326 183,323 193,318 199,313"><area shape=poly href=/new-docs/xen-api/classes/host_cpu title="a physical CPU on a host" alt coords="206,164 204,158 199,153 191,148 182,145 171,144 160,145 151,148 143,153 138,158 136,164 138,171 143,176 151,181 160,183 171,184 182,183 191,181 199,176 204,171"><area shape=rect href=/new-docs/xen-api/classes/network title="an ethernet network" alt coords=331,331,391,371><area shape=rect href=/new-docs/xen-api/classes/vif title="a network interface for a Virtual Machine" alt coords=423,334,483,374><area shape=poly href=/new-docs/xen-api/classes/vif_metrics title="IO stats and configuration information for a virtual interface" alt coords="498,451 496,445 490,439 481,435 470,432 457,431 444,432 432,435 423,439 417,445 415,451 417,457 423,463 432,467 444,470 457,471 470,470 481,467 490,463 496,457"><area shape=rect href=/new-docs/xen-api/classes/pif title="a network interface for a physical host" alt coords=241,306,301,346><area shape=poly href=/new-docs/xen-api/classes/pif_metrics title="IO stats and configuration information for a physical interface" alt coords="274,412 272,406 266,400 257,396 245,393 232,392 219,393 208,396 198,400 193,406 191,412 193,418 198,424 208,428 219,431 232,432 245,431 257,428 266,424 272,418"><area shape=rect href=/new-docs/xen-api/classes/sr title="Storage Repository, a container for virtual disk images (VDIs)" alt coords=323,97,383,137><area shape=rect href=/new-docs/xen-api/classes/vdi title="a virtual disk image" alt coords=412,124,472,164><area shape=poly href=/new-docs/xen-api/classes/sm title="storage manager plugin module" alt coords="377,26 375,19 371,14 364,9 356,7 347,6 337,7 329,9 322,14 318,19 317,26 318,32 322,37 329,42 337,45 347,46 356,45 364,42 371,37 375,32"><area shape=rect href=/new-docs/xen-api/classes/vbd title="a virtual block device" alt coords=486,181,546,221><area shape=poly href=/new-docs/xen-api/classes/vbd_metrics title="IO stats and configuration information for a virtual block device" alt coords="623,128 620,122 614,116 604,112 592,109 578,108 564,109 551,112 541,116 535,122 533,128 535,134 541,140 551,144 564,147 578,148 592,147 604,144 614,140 620,134"></map><h2>Classes, Fields and Messages</h2><p>Classes have both <i>fields</i> and <i>messages.</i> Messages are either <i>implicit</i> or <i>explicit</i> where an implicit message is one of:</p><ul><li>a constructor (usually called "create");</li><li>a destructor (usually called "destroy");</li><li>"get_by_name_label";</li><li>"get_by_uuid";</li><li>"get_record";</li><li>"get_all"; and</li><li>"get_all_records".</li></ul><p>Explicit messages include all the rest, more class-specific messages (e.g. "VM.start", "VM.clone")</p><p>Every field has at least one <i>accessor</i> depending both on its type and whether it is read-only or read-write. Accessors for a field named "X" would be a proper subset of:</p><ul><li>set_X: change the value of field X (only if it is read-write);</li><li>get_X: retrieve the value of field X;</li><li>add_X: add a key/value pair (for fields of type set);</li><li>remove_X: remove a key (for fields of type set);</li><li>add_to_X: add a key/value pair (for fields of type map); and</li><li>remove_from_X: remove a key (for fields of type map).</li></ul></div><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of XenAPI Reference</h1><article class=default><header class=headline></header><h1 id=auth>auth</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=blob>blob</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=bond>Bond</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=certificate>Certificate</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=cluster>Cluster</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=cluster_host>Cluster_host</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=console>console</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=crashdump>crashdump</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=data_source>data_source</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=dr_task>DR_task</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=event>event</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=feature>Feature</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=gpu_group>GPU_group</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=host>host</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=host_cpu>host_cpu</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=host_crashdump>host_crashdump</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=host_metrics>host_metrics</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=host_patch>host_patch</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=lvhd>LVHD</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=message>message</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=network>network</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=network_sriov>network_sriov</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=observer>Observer</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pbd>PBD</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pci>PCI</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pgpu>PGPU</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pif>PIF</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pif_metrics>PIF_metrics</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pool>pool</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pool_patch>pool_patch</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pool_update>pool_update</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=probe_result>probe_result</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pusb>PUSB</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pvs_cache_storage>PVS_cache_storage</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pvs_proxy>PVS_proxy</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pvs_server>PVS_server</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pvs_site>PVS_site</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=repository>Repository</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=role>role</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sdn_controller>SDN_controller</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=secret>secret</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=session>session</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sm>SM</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sr>SR</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sr_stat>sr_stat</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=subject>subject</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=task>task</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=tunnel>tunnel</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=usb_group>USB_group</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=user>user</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vbd>VBD</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vbd_metrics>VBD_metrics</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vdi>VDI</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vdi_nbd_server_info>vdi_nbd_server_info</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vgpu>VGPU</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vgpu_type>VGPU_type</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vif>VIF</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vif_metrics>VIF_metrics</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vlan>VLAN</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vm>VM</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vm_appliance>VM_appliance</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vm_guest_metrics>VM_guest_metrics</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vm_metrics>VM_metrics</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vmpp>VMPP</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vmss>VMSS</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vtpm>VTPM</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vusb>VUSB</h1><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=xenapi-releases>XenAPI Releases</h1><ul class="children children-li children-sort-"><li><a href=/new-docs/xen-api/releases/24.16.0/index.html>XAPI 24.16.0</a></li><li><a href=/new-docs/xen-api/releases/24.14.0/index.html>XAPI 24.14.0</a></li><li><a href=/new-docs/xen-api/releases/24.10.0/index.html>XAPI 24.10.0</a></li><li><a href=/new-docs/xen-api/releases/24.3.0/index.html>XAPI 24.3.0</a></li><li><a href=/new-docs/xen-api/releases/24.0.0/index.html>XAPI 24.0.0</a></li><li><a href=/new-docs/xen-api/releases/23.30.0/index.html>XAPI 23.30.0</a></li><li><a href=/new-docs/xen-api/releases/23.27.0/index.html>XAPI 23.27.0</a></li><li><a href=/new-docs/xen-api/releases/23.25.0/index.html>XAPI 23.25.0</a></li><li><a href=/new-docs/xen-api/releases/23.18.0/index.html>XAPI 23.18.0</a></li><li><a href=/new-docs/xen-api/releases/23.14.0/index.html>XAPI 23.14.0</a></li><li><a href=/new-docs/xen-api/releases/23.9.0/index.html>XAPI 23.9.0</a></li><li><a href=/new-docs/xen-api/releases/23.1.0/index.html>XAPI 23.1.0</a></li><li><a href=/new-docs/xen-api/releases/22.37.0/index.html>XAPI 22.37.0</a></li><li><a href=/new-docs/xen-api/releases/22.33.0/index.html>XAPI 22.33.0</a></li><li><a href=/new-docs/xen-api/releases/22.27.0/index.html>XAPI 22.27.0</a></li><li><a href=/new-docs/xen-api/releases/22.26.0/index.html>XAPI 22.26.0</a></li><li><a href=/new-docs/xen-api/releases/22.20.0/index.html>XAPI 22.20.0</a></li><li><a href=/new-docs/xen-api/releases/22.19.0/index.html>XAPI 22.19.0</a></li><li><a href=/new-docs/xen-api/releases/22.16.0/index.html>XAPI 22.16.0</a></li><li><a href=/new-docs/xen-api/releases/22.12.0/index.html>XAPI 22.12.0</a></li><li><a href=/new-docs/xen-api/releases/22.5.0/index.html>XAPI 22.5.0</a></li><li><a href=/new-docs/xen-api/releases/21.4.0/index.html>XAPI 21.4.0</a></li><li><a href=/new-docs/xen-api/releases/21.3.0/index.html>XAPI 21.3.0</a></li><li><a href=/new-docs/xen-api/releases/21.2.0/index.html>XAPI 21.2.0</a></li><li><a href=/new-docs/xen-api/releases/1.329.0/index.html>XAPI 1.329.0</a></li><li><a href=/new-docs/xen-api/releases/1.318.0/index.html>XAPI 1.318.0</a></li><li><a href=/new-docs/xen-api/releases/1.313.0/index.html>XAPI 1.313.0</a></li><li><a href=/new-docs/xen-api/releases/1.307.0/index.html>XAPI 1.307.0</a></li><li><a href=/new-docs/xen-api/releases/1.304.0/index.html>XAPI 1.304.0</a></li><li><a href=/new-docs/xen-api/releases/1.303.0/index.html>XAPI 1.303.0</a></li><li><a href=/new-docs/xen-api/releases/1.301.0/index.html>XAPI 1.301.0</a></li><li><a href=/new-docs/xen-api/releases/1.298.0/index.html>XAPI 1.298.0</a></li><li><a href=/new-docs/xen-api/releases/1.297.0/index.html>XAPI 1.297.0</a></li><li><a href=/new-docs/xen-api/releases/1.294.0/index.html>XAPI 1.294.0</a></li><li><a href=/new-docs/xen-api/releases/1.290.0/index.html>XAPI 1.290.0</a></li><li><a href=/new-docs/xen-api/releases/1.271.0/index.html>XAPI 1.271.0</a></li><li><a href=/new-docs/xen-api/releases/1.257.0/index.html>XAPI 1.257.0</a></li><li><a href=/new-docs/xen-api/releases/1.250.0/index.html>XAPI 1.250.0</a></li><li><a href=/new-docs/xen-api/releases/nile-preview/index.html>XenServer 8 Preview</a></li><li><a href=/new-docs/xen-api/releases/stockholm_psr/index.html>Citrix Hypervisor 8.2 Hotfix 2</a></li><li><a href=/new-docs/xen-api/releases/stockholm/index.html>Citrix Hypervisor 8.2</a></li><li><a href=/new-docs/xen-api/releases/quebec/index.html>Citrix Hypervisor 8.1</a></li><li><a href=/new-docs/xen-api/releases/naples/index.html>Citrix Hypervisor 8.0</a></li><li><a href=/new-docs/xen-api/releases/lima/index.html>XenServer 7.6</a></li><li><a href=/new-docs/xen-api/releases/kolkata/index.html>XenServer 7.5</a></li><li><a href=/new-docs/xen-api/releases/jura/index.html>XenServer 7.4</a></li><li><a href=/new-docs/xen-api/releases/inverness/index.html>XenServer 7.3</a></li><li><a href=/new-docs/xen-api/releases/falcon/index.html>XenServer 7.2</a></li><li><a href=/new-docs/xen-api/releases/ely/index.html>XenServer 7.1</a></li><li><a href=/new-docs/xen-api/releases/dundee/index.html>XenServer 7.0</a></li><li><a href=/new-docs/xen-api/releases/indigo/index.html>XenServer 6.5 SP1 Hotfix 31</a></li><li><a href=/new-docs/xen-api/releases/cream/index.html>XenServer 6.5 SP1</a></li><li><a href=/new-docs/xen-api/releases/creedence/index.html>XenServer 6.5</a></li><li><a href=/new-docs/xen-api/releases/clearwater-whetstone/index.html>XenServer 6.2 SP1 Hotfix 11</a></li><li><a href=/new-docs/xen-api/releases/clearwater-felton/index.html>XenServer 6.2 SP1 Hotfix 4</a></li><li><a href=/new-docs/xen-api/releases/vgpu-productisation/index.html>XenServer 6.2 SP1</a></li><li><a href=/new-docs/xen-api/releases/vgpu-tech-preview/index.html>XenServer 6.2 SP1 Tech-Preview</a></li><li><a href=/new-docs/xen-api/releases/clearwater/index.html>XenServer 6.2</a></li><li><a href=/new-docs/xen-api/releases/tampa/index.html>XenServer 6.1</a></li><li><a href=/new-docs/xen-api/releases/boston/index.html>XenServer 6.0</a></li><li><a href=/new-docs/xen-api/releases/cowley/index.html>XenServer 5.6 FP1</a></li><li><a href=/new-docs/xen-api/releases/midnight-ride/index.html>XenServer 5.6</a></li><li><a href=/new-docs/xen-api/releases/george/index.html>XenServer 5.5</a></li><li><a href=/new-docs/xen-api/releases/orlando-update-1/index.html>XenServer 5.0 Update 1</a></li><li><a href=/new-docs/xen-api/releases/orlando/index.html>XenServer 5.0</a></li><li><a href=/new-docs/xen-api/releases/symc/index.html>XenServer 4.1.1</a></li><li><a href=/new-docs/xen-api/releases/miami/index.html>XenServer 4.1</a></li><li><a href=/new-docs/xen-api/releases/rio/index.html>XenServer 4.0</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of XenAPI Releases</h1><article class=default><header class=headline></header><h1 id=xapi-24160>XAPI 24.16.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-24140>XAPI 24.14.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-24100>XAPI 24.10.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-2430>XAPI 24.3.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-2400>XAPI 24.0.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-23300>XAPI 23.30.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-23270>XAPI 23.27.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-23250>XAPI 23.25.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-23180>XAPI 23.18.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-23140>XAPI 23.14.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-2390>XAPI 23.9.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-2310>XAPI 23.1.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-22370>XAPI 22.37.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-22330>XAPI 22.33.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-22270>XAPI 22.27.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-22260>XAPI 22.26.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-22200>XAPI 22.20.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-22190>XAPI 22.19.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-22160>XAPI 22.16.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-22120>XAPI 22.12.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-2250>XAPI 22.5.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-2140>XAPI 21.4.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-2130>XAPI 21.3.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-2120>XAPI 21.2.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-13290>XAPI 1.329.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-13180>XAPI 1.318.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-13130>XAPI 1.313.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-13070>XAPI 1.307.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-13040>XAPI 1.304.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-13030>XAPI 1.303.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-13010>XAPI 1.301.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-12980>XAPI 1.298.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-12970>XAPI 1.297.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-12940>XAPI 1.294.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-12900>XAPI 1.290.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-12710>XAPI 1.271.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-12570>XAPI 1.257.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-12500>XAPI 1.250.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-8-preview>XenServer 8 Preview</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=citrix-hypervisor-82-hotfix-2>Citrix Hypervisor 8.2 Hotfix 2</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=citrix-hypervisor-82>Citrix Hypervisor 8.2</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=citrix-hypervisor-81>Citrix Hypervisor 8.1</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=citrix-hypervisor-80>Citrix Hypervisor 8.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-76>XenServer 7.6</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-75>XenServer 7.5</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-74>XenServer 7.4</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-73>XenServer 7.3</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-72>XenServer 7.2</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-71>XenServer 7.1</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-70>XenServer 7.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-65-sp1-hotfix-31>XenServer 6.5 SP1 Hotfix 31</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-65-sp1>XenServer 6.5 SP1</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-65>XenServer 6.5</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-62-sp1-hotfix-11>XenServer 6.2 SP1 Hotfix 11</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-62-sp1-hotfix-4>XenServer 6.2 SP1 Hotfix 4</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-62-sp1>XenServer 6.2 SP1</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-62-sp1-tech-preview>XenServer 6.2 SP1 Tech-Preview</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-62>XenServer 6.2</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-61>XenServer 6.1</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-60>XenServer 6.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-56-fp1>XenServer 5.6 FP1</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-56>XenServer 5.6</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-55>XenServer 5.5</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-50-update-1>XenServer 5.0 Update 1</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-50>XenServer 5.0</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-411>XenServer 4.1.1</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-41>XenServer 4.1</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenserver-40>XenServer 4.0</h1><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=topics>Topics</h1><ul class="children children-li children-sort-"><li><a href=/new-docs/xen-api/topics/udhcp/index.html>API for configuring the udhcp server in Dom0</a></li><li><a href=/new-docs/xen-api/topics/guest-agents/index.html>Guest agents</a></li><li><a href=/new-docs/xen-api/topics/memory/index.html>Memory</a></li><li><a href=/new-docs/xen-api/topics/metrics/index.html>Metrics</a></li><li><a href=/new-docs/xen-api/topics/snapshots/index.html>Snapshots</a></li><li><a href=/new-docs/xen-api/topics/consoles/index.html>VM consoles</a></li><li><a href=/new-docs/xen-api/topics/importexport/index.html>VM import/export</a></li><li><a href=/new-docs/xen-api/topics/vm-lifecycle/index.html>VM Lifecycle</a></li><li><a href=/new-docs/xen-api/topics/xencenter/index.html>XenCenter</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Topics</h1><article class=default><header class=headline></header><h1 id=api-for-configuring-the-udhcp-server-in-dom0>API for configuring the udhcp server in Dom0</h1><p>This API allows you to configure the DHCP service running on the Host
Internal Management Network (HIMN). The API configures a udhcp daemon
residing in Dom0 and alters the service configuration for any VM using
the network.</p><p>It should be noted that for this reason, that callers who modify the
default configuration should be aware that their changes may have an
adverse affect on other consumers of the HIMN.</p><h2 id=version-history>Version history</h2><pre><code>Date        State
----        ----
2013-3-15   Stable
</code></pre><p><em>Stable</em>: this API is considered stable and unlikely to change between
software version and between hotfixes.</p><h2 id=api-description>API description</h2><p>The API for configuring the network is based on a series of other_config
keys that can be set by the caller on the HIMN XAPI network object. Once
any of the keys below have been set, the caller must ensure that any VIFs
attached to the HIMN are removed, destroyed, created and plugged.</p><pre><code>ip_begin
</code></pre><p>The first IP address in the desired subnet that the caller wishes the
DHCP service to use.</p><pre><code>ip_end
</code></pre><p>The last IP address in the desired subnet that the caller wishes the
DHCP service to use.</p><pre><code>netmask
</code></pre><p>The subnet mask for each of the issues IP addresses.</p><pre><code>ip_disable_gw
</code></pre><p>A boolean key for disabling the DHCP server from returning a default
gateway for VMs on the network. To disable returning the gateway address
set the key to True.</p><p><em>Note</em>: By default, the DHCP server will issue a default gateway for
those requesting an address. Setting this key may disrupt applications
that require the default gateway for communicating with Dom0 and so
should be used with care.</p><h2 id=example-code>Example code</h2><p>An example python extract of setting the config for the network:</p><pre><code>def get_himn_ref():
    networks = session.xenapi.network.get_all_records()
    for ref, rec in networks.iteritems():
        if 'is_host_internal_management_network' \
                                        in rec['other_config']:                                            
            return ref

    raise Exception(&quot;Error: unable to find HIMN.&quot;)


himn_ref = get_himn_ref()
other_config = session.xenapi.network.get_other_config(himn_ref)

other_config['ip_begin'] = &quot;169.254.0.1&quot;
other_config['ip_end'] = &quot;169.254.255.254&quot;
other_config['netmask'] = &quot;255.255.0.0&quot;

session.xenapi.network.set_other_config(himn_ref, other_config)
</code></pre><p>An example for how to disable the server returning a default gateway:</p><pre><code>himn_ref = get_himn_ref()
other_config = session.xenapi.network.get_other_config(himn_ref)

other_config['ip_disable_gw'] = True

session.xenapi.network.set_other_config(himn_ref, other_config)
</code></pre><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=guest-agents>Guest agents</h1><p>&ldquo;Guest agents&rdquo; are special programs which run inside VMs which can be controlled
via the XenAPI.</p><p>One communication method between XenAPI clients is via Xenstore.</p><h2 id=adding-xenstore-entries-to-vms>Adding Xenstore entries to VMs</h2><p>Developers may wish to install guest agents into VMs which take special action based on the type of the VM. In order to communicate this information into the guest, a special Xenstore name-space known as <code>vm-data</code> is available which is populated at VM creation time. It is populated from the <code>xenstore-data</code> map in the VM record.</p><p>Set the <code>xenstore-data</code> parameter in the VM record:</p><pre><code>xe vm-param-set uuid= xenstore-data:vm-data/foo=bar
</code></pre><p>Start the VM.</p><p>If it is a Linux-based VM, install the COMPANY_TOOLS and use the <code>xenstore-read</code> to verify that the node exists in Xenstore.</p><blockquote><p><strong>Note</strong></p><p>Only prefixes beginning with <code>vm-data</code> are permitted, and anything not in this name-space will be silently ignored when starting the VM.</p></blockquote><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=memory>Memory</h1><p>Memory is used for many things:</p><ul><li>the hypervisor code: this is the Xen executable itself</li><li>the hypervisor heap: this is needed for per-domain structures and per-vCPU
structures</li><li>the crash kernel: this is needed to collect information after a host crash</li><li>domain RAM: this is the memory the VM believes it has</li><li>shadow memory: for HVM guests running on hosts without hardware assisted
paging (HAP) Xen uses shadow to optimise page table updates. For all guests
shadow is used during live migration for tracking the memory transfer.</li><li>video RAM for the virtual graphics card</li></ul><p>Some of these are constants (e.g. hypervisor code) while some depend on the VM
configuration (e.g. domain RAM). Xapi calls the constants &ldquo;host overhead&rdquo; and
the variables due to VM configuration as &ldquo;VM overhead&rdquo;.
These overheads are subtracted from free memory on the host when starting,
resuming and migrating VMs.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=metrics>Metrics</h1><p><a href=https://github.com/xapi-project/xen-api/ocaml/xcp-rrdd target=_blank>xcp-rrdd</a>
records statistics about the host and the VMs running on top.
The metrics are stored persistently for long-term access and analysis of
historical trends.
Statistics are stored in <a href=http://oss.oetiker.ch/rrdtool/ target=_blank>RRDs</a> (Round Robin
Databases).
RRDs are fixed-size structures that store time series with decreasing time
resolution: the older the data point is, the longer the timespan it represents.
&lsquo;Data sources&rsquo; are sampled every few seconds and points are added to
the highest resolution RRD. Periodically each high-frequency RRD is
&lsquo;consolidated&rsquo; (e.g. averaged) to produce a data point for a lower-frequency
RRD.</p><p>RRDs are resident on the host on which the VM is running, or the pool
coordinator when the VM is not running.
The RRDs are backed up every day.</p><h2 id=granularity>Granularity</h2><p>Statistics are persisted for a maximum of one year, and are stored at
different granularities.
The average and most recent values are stored at intervals of:</p><ul><li>five seconds for the past ten minutes</li><li>one minute for the past two hours</li><li>one hour for the past week</li><li>one day for the past year</li></ul><p>RRDs are saved to disk as uncompressed XML. The size of each RRD when
written to disk ranges from 200KiB to approximately 1.2MiB when the RRD
stores the full year of statistics.</p><p>By default each RRD contains only averaged data to save storage space.
To record minimum and maximum values in future RRDs, set the Pool-wide flag</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>xe pool-param-set uuid<span style=color:#f92672>=</span> other-config:create_min_max_in_new_VM_RRDs<span style=color:#f92672>=</span>true</span></span></code></pre></div><h1 id=downloading>Downloading</h1><p>Statistics can be downloaded over HTTP in XML or JSON format, for example
using <code>wget</code>.
See <a href=http://oss.oetiker.ch/rrdtool/doc/rrddump.en.html target=_blank>rrddump</a> and
<a href=http://oss.oetiker.ch/rrdtool/doc/rrdxport.en.html target=_blank>rrdxport</a> for information
about the XML format.
The JSON format has the same structure as the XML.
Parameters are appended to the URL following a question mark (?) and separated
by ampersands (&).
HTTP authentication can take the form of a username and password or a session
token in a URL parameter.</p><p>Statistics may be downloaded all at once, including all history, or as
deltas suitable for interactive graphing.</p><h2 id=downloading-statistics-all-at-once>Downloading statistics all at once</h2><p>To obtain a full dump of RRD data for a host use:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>wget  http://hostname/host_rrd?session_id<span style=color:#f92672>=</span>OpaqueRef:43df3204-9360-c6ab-923e-41a8d19389ba<span style=color:#e6db74>&#34;</span></span></span></code></pre></div><p>where the session token has been fetched from the server using the API.</p><p>For example, using Python&rsquo;s <a href=https://pypi.org/project/XenAPI/ target=_blank>XenAPI</a> library:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> XenAPI
</span></span><span style=display:flex><span>username <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;root&#34;</span>
</span></span><span style=display:flex><span>password <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;actual_password&#34;</span>
</span></span><span style=display:flex><span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://hostname&#34;</span>
</span></span><span style=display:flex><span>session <span style=color:#f92672>=</span> XenAPI<span style=color:#f92672>.</span>Session(url)
</span></span><span style=display:flex><span>session<span style=color:#f92672>.</span>xenapi<span style=color:#f92672>.</span>login_with_password(username, password, <span style=color:#e6db74>&#34;1.0&#34;</span>, <span style=color:#e6db74>&#34;session_getter&#34;</span>)
</span></span><span style=display:flex><span>session<span style=color:#f92672>.</span>_session</span></span></code></pre></div><p>A URL parameter is used to decide which format to return: XML is returned by
default, adding the parameter <code>json</code> makes the server return JSON.
Starting from xapi version 23.17.0, the server uses the HTTP header <code>Accept</code>
to decide which format to return.
When both formats are accepted, for example, using <code>*/*</code>; JSON is returned.
Of interest are the clients wget and curl which use this accept header value,
meaning that when using them the default behaviour will change and the accept
header needs to be overridden to make the server return XML.
The content type is provided in the reponse&rsquo;s headers in these newer versions.</p><p>The XML RRD data is in the format used by rrdtool and looks like this:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;?xml version=&#34;1.0&#34;?&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;rrd&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;version&gt;</span>0003<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;step&gt;</span>5<span style=color:#f92672>&lt;/step&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;lastupdate&gt;</span>1213616574<span style=color:#f92672>&lt;/lastupdate&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;ds&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;name&gt;</span>memory_total_kib<span style=color:#f92672>&lt;/name&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;type&gt;</span>GAUGE<span style=color:#f92672>&lt;/type&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;minimal_heartbeat&gt;</span>300.0000<span style=color:#f92672>&lt;/minimal_heartbeat&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;min&gt;</span>0.0<span style=color:#f92672>&lt;/min&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;max&gt;</span>Infinity<span style=color:#f92672>&lt;/max&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;last_ds&gt;</span>2070172<span style=color:#f92672>&lt;/last_ds&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;value&gt;</span>9631315.6300<span style=color:#f92672>&lt;/value&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;unknown_sec&gt;</span>0<span style=color:#f92672>&lt;/unknown_sec&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/ds&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;ds&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>&lt;!-- other dss - the order of the data sources is important
</span></span></span><span style=display:flex><span><span style=color:#75715e>        and defines the ordering of the columns in the archives below --&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/ds&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;rra&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;cf&gt;</span>AVERAGE<span style=color:#f92672>&lt;/cf&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;pdp_per_row&gt;</span>1<span style=color:#f92672>&lt;/pdp_per_row&gt;</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>&lt;params&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;xff&gt;</span>0.5000<span style=color:#f92672>&lt;/xff&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/params&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;cdp_prep&gt;</span> <span style=color:#75715e>&lt;!-- This is for internal use --&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;ds&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;primary_value&gt;</span>0.0<span style=color:#f92672>&lt;/primary_value&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;secondary_value&gt;</span>0.0<span style=color:#f92672>&lt;/secondary_value&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;value&gt;</span>0.0<span style=color:#f92672>&lt;/value&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;unknown_datapoints&gt;</span>0<span style=color:#f92672>&lt;/unknown_datapoints&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;/ds&gt;</span>
</span></span><span style=display:flex><span>      ...other dss - internal use only...
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/cdp_prep&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;database&gt;</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>&lt;row&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>2070172.0000<span style=color:#f92672>&lt;/v&gt;</span>  <span style=color:#75715e>&lt;!-- columns correspond to the DSs defined above --&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>1756408.0000<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>0.0<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>0.0<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>732.2130<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>0.0<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>782.9186<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>0.0<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>647.0431<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>0.0<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>0.0001<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>0.0268<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>0.0100<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>0.0<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;v&gt;</span>615.1072<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>&lt;/row&gt;</span>
</span></span><span style=display:flex><span>     ...
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/rra&gt;</span>
</span></span><span style=display:flex><span>  ... other archives ...
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/rrd&gt;</span></span></span></code></pre></div><p>To obtain a full dump of RRD data of a VM with uuid <code>x</code>:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>wget <span style=color:#e6db74>&#34;http://hostname/vm_rrd?session_id=&lt;token&gt;&amp;uuid=x&#34;</span></span></span></code></pre></div><p>Note that it is quite expensive to download full RRDs as they contain
lots of historical information. For interactive displays clients should
download deltas instead.</p><h2 id=downloading-deltas>Downloading deltas</h2><p>To obtain an update of all VM statistics on a host, the URL would be of
the form:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>wget <span style=color:#e6db74>&#34;https://hostname/rrd_updates?session_id=&lt;token&gt;&amp;start=&lt;secondsinceepoch&gt;&#34;</span></span></span></code></pre></div><p>This request returns data in an rrdtool <code>xport</code> style XML format, for every VM
resident on the particular host that is being queried.
To differentiate which column in the export is associated with which VM, the
<code>legend</code> field is prefixed with the UUID of the VM.</p><p>An example <code>rrd_updates</code> output:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;xport&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;meta&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;start&gt;</span>1213578000<span style=color:#f92672>&lt;/start&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;step&gt;</span>3600<span style=color:#f92672>&lt;/step&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;end&gt;</span>1213617600<span style=color:#f92672>&lt;/end&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;rows&gt;</span>12<span style=color:#f92672>&lt;/rows&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;columns&gt;</span>12<span style=color:#f92672>&lt;/columns&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;legend&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;entry&gt;</span>AVERAGE:vm:ecd8d7a0-1be3-4d91-bd0e-4888c0e30ab3:cpu1<span style=color:#f92672>&lt;/entry&gt;</span> <span style=color:#75715e>&lt;!-- nb - each data source might have multiple entries for different consolidation functions --&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;entry&gt;</span>AVERAGE:vm:ecd8d7a0-1be3-4d91-bd0e-4888c0e30ab3:cpu0<span style=color:#f92672>&lt;/entry&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;entry&gt;</span>AVERAGE:vm:ecd8d7a0-1be3-4d91-bd0e-4888c0e30ab3:memory<span style=color:#f92672>&lt;/entry&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;entry&gt;</span>MIN:vm:ecd8d7a0-1be3-4d91-bd0e-4888c0e30ab3:cpu1<span style=color:#f92672>&lt;/entry&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;entry&gt;</span>MIN:vm:ecd8d7a0-1be3-4d91-bd0e-4888c0e30ab3:cpu0<span style=color:#f92672>&lt;/entry&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;entry&gt;</span>MIN:vm:ecd8d7a0-1be3-4d91-bd0e-4888c0e30ab3:memory<span style=color:#f92672>&lt;/entry&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;entry&gt;</span>MAX:vm:ecd8d7a0-1be3-4d91-bd0e-4888c0e30ab3:cpu1<span style=color:#f92672>&lt;/entry&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;entry&gt;</span>MAX:vm:ecd8d7a0-1be3-4d91-bd0e-4888c0e30ab3:cpu0<span style=color:#f92672>&lt;/entry&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;entry&gt;</span>MAX:vm:ecd8d7a0-1be3-4d91-bd0e-4888c0e30ab3:memory<span style=color:#f92672>&lt;/entry&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;entry&gt;</span>LAST:vm:ecd8d7a0-1be3-4d91-bd0e-4888c0e30ab3:cpu1<span style=color:#f92672>&lt;/entry&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;entry&gt;</span>LAST:vm:ecd8d7a0-1be3-4d91-bd0e-4888c0e30ab3:cpu0<span style=color:#f92672>&lt;/entry&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;entry&gt;</span>LAST:vm:ecd8d7a0-1be3-4d91-bd0e-4888c0e30ab3:memory<span style=color:#f92672>&lt;/entry&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/legend&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/meta&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;data&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;row&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;t&gt;</span>1213617600<span style=color:#f92672>&lt;/t&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;v&gt;</span>0.0<span style=color:#f92672>&lt;/v&gt;</span> <span style=color:#75715e>&lt;!-- once again, the order or the columns is defined by the legend above --&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;v&gt;</span>0.0282<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;v&gt;</span>209715200.0000<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;v&gt;</span>0.0<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;v&gt;</span>0.0201<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;v&gt;</span>209715200.0000<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;v&gt;</span>0.0<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;v&gt;</span>0.0445<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;v&gt;</span>209715200.0000<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;v&gt;</span>0.0<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;v&gt;</span>0.0243<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;v&gt;</span>209715200.0000<span style=color:#f92672>&lt;/v&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/row&gt;</span>
</span></span><span style=display:flex><span>   ...
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/data&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/xport&gt;</span></span></span></code></pre></div><p>To obtain host updates too, use the query parameter <code>host=true</code>:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>wget <span style=color:#e6db74>&#34;http://hostname/rrd_updates?session_id=&lt;token&gt;&amp;start=&lt;secondssinceepoch&gt;&amp;host=true&#34;</span></span></span></code></pre></div><p>The step will decrease as the period decreases, which means that if you
request statistics for a shorter time period you will get more detailed
statistics.</p><p>To download updates containing only the averages, or minimums or maximums,
add the parameter <code>cf=AVERAGE|MIN|MAX</code> (note case is important) e.g.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>wget <span style=color:#e6db74>&#34;http://hostname/rrd_updates?session_id=&lt;token&gt;&amp;start=0&amp;cf=MAX&#34;</span></span></span></code></pre></div><p>To request a different update interval, add the parameter <code>interval=seconds</code> e.g.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>wget <span style=color:#e6db74>&#34;http://hostname/rrd_updates?session_id=&lt;token&gt;&amp;start=0&amp;interval=5&#34;</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=snapshots>Snapshots</h1><p>Snapshots represent the state of a VM, or a disk (VDI) at a point in time.
They can be used for:</p><ul><li>backups (hourly, daily, weekly etc)</li><li>experiments (take snapshot, try something, revert back again)</li><li>golden images (install OS, get it just right, clone it 1000s of times)</li></ul><p>Read more about <a href=/new-docs/xen-api/topics/snapshots/../features/snapshots/snapshots.html>Snapshots: the High-Level Feature</a>.</p><h1 id=taking-a-vdi-snapshot>Taking a VDI snapshot</h1><p>To take a snapshot of a single disk (VDI):</p><div class="wrap-code highlight"><pre tabindex=0><code>snapshot_vdi &lt;- VDI.snapshot(session_id, vdi, driver_params)</code></pre></div><p>where <code>vdi</code> is the reference to the disk to be snapshotted, and <code>driver_params</code>
is a list of string pairs providing optional backend implementation-specific hints.
The snapshot operation should be quick (i.e. it should never be implemented as
a slow disk copy) and the resulting VDI will have</p><table><thead><tr><th>Field name</th><th>Description</th></tr></thead><tbody><tr><td>is_a_snapshot</td><td>a flag, set to true, indicating the disk is a snapshot</td></tr><tr><td>snapshot_of</td><td>a reference to the disk the snapshot was created from</td></tr><tr><td>snapshot_time</td><td>the time the snapshot was taken</td></tr></tbody></table><p>The resulting snapshot should be considered read-only. Depending on the backend
implementation it may be technically possible to write to the snapshot, but clients
must not do this. To create a writable disk from a snapshot, see &ldquo;restoring from
a snapshot&rdquo; below.</p><p>Note that the storage backend is free to implement this in different ways. We
do not assume the presence of a .vhd-formatted storage repository. Clients
must never assume anything about the backend implementation without checking
first with the maintainers of the backend implementation.</p><h1 id=restoring-to-a-vdi-snapshot>Restoring to a VDI snapshot</h1><p>To restore from a VDI snapshot first</p><div class="wrap-code highlight"><pre tabindex=0><code>new_vdi &lt;- VDI.clone(session_id, snapshot_vdi, driver_params)</code></pre></div><p>where <code>snapshot_vdi</code> is a reference to the snapshot VDI, and <code>driver_params</code>
is a list of string pairs providing optional backend implementation-specific hints.
The clone operation should be quick (i.e. it should never be implemented as
a slow disk copy) and the resulting VDI will have</p><table><thead><tr><th>Field name</th><th>Description</th></tr></thead><tbody><tr><td>is_a_snapshot</td><td>a flag, set to false, indicating the disk is not a snapshot</td></tr><tr><td>snapshot_of</td><td>an invalid reference</td></tr><tr><td>snapshot_time</td><td>an invalid time</td></tr></tbody></table><p>The resulting disk is writable and can be used by the client as normal.</p><p>Note that the &ldquo;restored&rdquo; VDI will have a different <code>VDI.uuid</code> and reference to
the original VDI.</p><h1 id=taking-a-vm-snapshot>Taking a VM snapshot</h1><p>A VM snapshot is a copy of the VM metadata and a snapshot of all the associated
VDIs at around the same point in time. To take a VM snapshot:</p><div class="wrap-code highlight"><pre tabindex=0><code>snapshot_vm &lt;- VM.snapshot(session_id, vm, new_name)</code></pre></div><p>where <code>vm</code> is a reference to the existing VM and <code>new_name</code> will be the <code>name_label</code>
of the resulting VM (snapshot) object. The resulting VM will have</p><table><thead><tr><th>Field name</th><th>Description</th></tr></thead><tbody><tr><td>is_a_snapshot</td><td>a flag, set to true, indicating the VM is a snapshot</td></tr><tr><td>snapshot_of</td><td>a reference to the VM the snapshot was created from</td></tr><tr><td>snapshot_time</td><td>the time the snapshot was taken</td></tr></tbody></table><p>Note that each disk is snapshotted one-by-one and not at the same time.</p><h1 id=restoring-to-a-vm-snapshot>Restoring to a VM snapshot</h1><p>A VM snapshot can be reverted to a snapshot using</p><div class="wrap-code highlight"><pre tabindex=0><code>VM.revert(session_id, snapshot_ref)</code></pre></div><p>where <code>snapshot_ref</code> is a reference to the snapshot VM. Each VDI associated with
the VM before the snapshot will be destroyed and each VDI associated with the
snapshot will be cloned (see &ldquo;Reverting to a disk snapshot&rdquo; above) and associated
with the VM. The resulting VM will have</p><table><thead><tr><th>Field name</th><th>Description</th></tr></thead><tbody><tr><td>is_a_snapshot</td><td>a flag, set to false, indicating the VM is not a snapshot</td></tr><tr><td>snapshot_of</td><td>an invalid reference</td></tr><tr><td>snapshot_time</td><td>an invalid time</td></tr></tbody></table><p>Note that the <code>VM.uuid</code> and reference are preserved, but the <code>VDI.uuid</code> and
VDI references are not.</p><h1 id=downloading-a-disk-or-snapshot>Downloading a disk or snapshot</h1><p>Disks can be downloaded in either raw or vhd format using an HTTP 1.0 GET
request as follows:</p><div class="wrap-code highlight"><pre tabindex=0><code>GET /export_raw_vdi?session_id=%s&amp;task_id=%s&amp;vdi=%s&amp;format=%s[&amp;base=%s] HTTP/1.0\r\n
Connection: close\r\n
\r\n
\r\n</code></pre></div><p>where</p><ul><li><code>session_id</code> is a currently logged-in session</li><li><code>task_id</code> is a <code>Task</code> reference which will be used to monitor the
progress of this task and receive errors from it</li><li><code>vdi</code> is the reference of the <code>VDI</code> into which the data will be
imported</li><li><code>format</code> is either <code>vhd</code> or <code>raw</code></li><li>(optional) <code>base</code> is the reference of a <code>VDI</code> which has already been
exported and this export should only contain the blocks which have changed
since then.</li></ul><p>Note that the vhd format allows the disk to be sparse i.e. only contain allocated
blocks. This helps reduce the size of the download.</p><p>The xapi-project/xen-api repo has a
<a href=https://github.com/xapi-project/xen-api/blob/19afd3dfe8883814e525ce7ce39c8c959ce3c924/scripts/examples/python/exportimport.py#L32 target=_blank>python download example</a></p><h1 id=uploading-a-disk-or-snapshot>Uploading a disk or snapshot</h1><p>Disks can be uploaded in either raw or vhd format using an HTTP 1.0 PUT
request as follows:</p><div class="wrap-code highlight"><pre tabindex=0><code>PUT /import_raw_vdi?session_id=%s&amp;task_id=%s&amp;vdi=%s&amp;format=%s HTTP/1.0\r\n
Connection: close\r\n
\r\n
\r\n</code></pre></div><p>where</p><ul><li><code>session_id</code> is a currently logged-in session</li><li><code>task_id</code> is a <code>Task</code> reference which will be used to monitor the
progress of this task and receive errors from it</li><li><code>vdi</code> is the reference of the <code>VDI</code> into which the data will be
imported</li><li><code>format</code> is either <code>vhd</code> or <code>raw</code></li></ul><p>Note that you must create the disk (with the correct size) before importing
data to it. The disk doesn&rsquo;t have to be empty, in fact if restoring from a
series of incremental downloads it makes sense to upload them all to the
same disk in order.</p><h1 id=example-incremental-backup-with-xe>Example: incremental backup with xe</h1><p>This section will show how easy it is to build an incremental backup
tool using these APIs. For simplicity we will use the <code>xe</code> commands
rather than raw XMLRPC and HTTP.</p><p>For a VDI with uuid $VDI, take a snapshot:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>FULL<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>xe vdi-snapshot uuid<span style=color:#f92672>=</span>$VDI<span style=color:#66d9ef>)</span></span></span></code></pre></div><p>Next perform a full backup into a file &ldquo;full.vhd&rdquo;, in vhd format:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>xe vdi-export uuid<span style=color:#f92672>=</span>$FULL filename<span style=color:#f92672>=</span>full.vhd format<span style=color:#f92672>=</span>vhd  --progress</span></span></code></pre></div><p>If the SR was using the vhd format internally (this is the default)
then the full backup will be sparse and will only contain blocks if they
have been written to.</p><p>After some time has passed and the VDI has been written to, take another
snapshot:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>DELTA<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>xe vdi-snapshot uuid<span style=color:#f92672>=</span>$VDI<span style=color:#66d9ef>)</span></span></span></code></pre></div><p>Now we can backup only the disk blocks which have changed between the original
snapshot $FULL and the next snapshot $DELTA into a file called &ldquo;delta.vhd&rdquo;:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>xe vdi-export uuid<span style=color:#f92672>=</span>$DELTA filename<span style=color:#f92672>=</span>delta.vhd format<span style=color:#f92672>=</span>vhd base<span style=color:#f92672>=</span>$FULL --progress</span></span></code></pre></div><p>We now have 2 files on the local system:</p><ul><li>&ldquo;full.vhd&rdquo;: a complete backup of the first snapshot</li><li>&ldquo;delta.vhd&rdquo;: an incremental backup of the second snapshot, relative to
the first</li></ul><p>For example:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>test $ ls -lh *.vhd
</span></span><span style=display:flex><span>-rw------- <span style=color:#ae81ff>1</span> dscott xendev 213M Aug <span style=color:#ae81ff>15</span> 10:39 delta.vhd
</span></span><span style=display:flex><span>-rw------- <span style=color:#ae81ff>1</span> dscott xendev 8.0G Aug <span style=color:#ae81ff>15</span> 10:39 full.vhd</span></span></code></pre></div><p>To restore the original snapshot you must create an empty disk with the
correct size. To find the size of a .vhd file use <code>qemu-img</code> as follows:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>test $ qemu-img info delta.vhd
</span></span><span style=display:flex><span>image: delta.vhd
</span></span><span style=display:flex><span>file format: vpc
</span></span><span style=display:flex><span>virtual size: 24G <span style=color:#f92672>(</span><span style=color:#ae81ff>25769705472</span> bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>disk size: 212M</span></span></code></pre></div><p>Here the size is 25769705472 bytes.
Create a fresh VDI in SR $SR to restore the backup as follows:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>SIZE<span style=color:#f92672>=</span><span style=color:#ae81ff>25769705472</span>
</span></span><span style=display:flex><span>RESTORE<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>xe vdi-create name-label<span style=color:#f92672>=</span>restored virtual-size<span style=color:#f92672>=</span>$SIZE sr-uuid<span style=color:#f92672>=</span>$SR type<span style=color:#f92672>=</span>user<span style=color:#66d9ef>)</span></span></span></code></pre></div><p>then import &ldquo;full.vhd&rdquo; into it:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>xe vdi-import uuid<span style=color:#f92672>=</span>$RESTORE filename<span style=color:#f92672>=</span>full.vhd format<span style=color:#f92672>=</span>vhd --progress</span></span></code></pre></div><p>Once &ldquo;full.vhd&rdquo; has been imported, the incremental backup can be restored
on top:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>xe vdi-import uuid<span style=color:#f92672>=</span>$RESTORE filename<span style=color:#f92672>=</span>delta.vhd format<span style=color:#f92672>=</span>vhd --progress</span></span></code></pre></div><p>Note there is no need to supply a &ldquo;base&rdquo; parameter when importing; Xapi will
treat the &ldquo;vhd differencing disk&rdquo; as a set of blocks and import them. It
is up to you to check you are importing them to the right place.</p><p>Now the VDI $RESTORE should have the same contents as $DELTA.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vm-consoles>VM consoles</h1><p>Most XenAPI graphical interfaces will want to gain access to the VM consoles, in order to render them to the user as if they were physical machines. There are several types of consoles available, depending on the type of guest or if the physical host console is being accessed:</p><h1 id=types-of-consoles>Types of consoles</h1><table><thead><tr><th style=text-align:left>Operating System</th><th style=text-align:left>Text</th><th style=text-align:left>Graphical</th><th style=text-align:left>Optimized graphical</th></tr></thead><tbody><tr><td style=text-align:left>Windows</td><td style=text-align:left>No</td><td style=text-align:left>VNC, using an API call</td><td style=text-align:left>RDP, directly from guest</td></tr><tr><td style=text-align:left>Linux</td><td style=text-align:left>Yes, through VNC and an API call</td><td style=text-align:left>No</td><td style=text-align:left>VNC, directly from guest</td></tr><tr><td style=text-align:left>Physical Host</td><td style=text-align:left>Yes, through VNC and an API call</td><td style=text-align:left>No</td><td style=text-align:left>No</td></tr></tbody></table><p>Hardware-assisted VMs, such as Windows, directly provide a graphical console over VNC. There is no text-based console, and guest networking is not necessary to use the graphical console. Once guest networking has been established, it is more efficient to setup Remote Desktop Access and use an RDP client to connect directly (this must be done outside of the XenAPI).</p><p>Paravirtual VMs, such as Linux guests, provide a native text console directly. XenServer provides a utility (called <code>vncterm</code>) to convert this text-based console into a graphical VNC representation. Guest networking is not necessary for this console to function. As with Windows above, Linux distributions often configure VNC within the guest, and directly connect to it over a guest network interface.</p><p>The physical host console is only available as a <code>vt100</code> console, which is exposed through the XenAPI as a VNC console by using <code>vncterm</code> in the control domain.</p><p>RFB (Remote Framebuffer) is the protocol which underlies VNC, specified in <a href=http://www.realvnc.com/docs/rfbproto.pdf target=_blank>The RFB Protocol</a>. Third-party developers are expected to provide their own VNC viewers, and many freely available implementations can be adapted for this purpose. RFB 3.3 is the minimum version which viewers must support.</p><h1 id=retrieving-vnc-consoles-using-the-api>Retrieving VNC consoles using the API</h1><p>VNC consoles are retrieved using a special URL passed through to the host agent. The sequence of API calls is as follows:</p><ol><li><p>Client to Master/443: XML-RPC: <code>Session.login_with_password()</code>.</p></li><li><p>Master/443 to Client: Returns a session reference to be used with subsequent calls.</p></li><li><p>Client to Master/443: XML-RPC: <code>VM.get_by_name_label()</code>.</p></li><li><p>Master/443 to Client: Returns a reference to a particular VM (or the &ldquo;control domain&rdquo; if you want to retrieve the physical host console).</p></li><li><p>Client to Master/443: XML-RPC: <code>VM.get_consoles()</code>.</p></li><li><p>Master/443 to Client: Returns a list of console objects associated with the VM.</p></li><li><p>Client to Master/443: XML-RPC: <code>VM.get_location()</code>.</p></li><li><p>Returns a URI describing where the requested console is located. The URIs are of the form: <code>https://192.168.0.1/console?ref=OpaqueRef:c038533a-af99-a0ff-9095-c1159f2dc6a0</code>.</p></li><li><p>Client to 192.168.0.1: HTTP CONNECT &ldquo;/console?ref=(&mldr;)&rdquo;</p></li></ol><p>The final HTTP CONNECT is slightly non-standard since the HTTP/1.1 RFC specifies that it should only be a host and a port, rather than a URL. Once the HTTP connect is complete, the connection can subsequently directly be used as a VNC server without any further HTTP protocol action.</p><p>This scheme requires direct access from the client to the control domain&rsquo;s IP, and will not work correctly if there are Network Address Translation (NAT) devices blocking such connectivity. You can use the CLI to retrieve the console URI from the client and perform a connectivity check.</p><p>Retrieve the VM UUID by running:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ VM<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>xe vm-list params<span style=color:#f92672>=</span>uuid --minimal name-label<span style=color:#f92672>=</span>&lt;name&gt;<span style=color:#66d9ef>)</span></span></span></code></pre></div><p>Retrieve the console information:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ xe console-list vm-uuid<span style=color:#f92672>=</span>$VM
</span></span><span style=display:flex><span>uuid <span style=color:#f92672>(</span> RO<span style=color:#f92672>)</span>             : 8013b937-ff7e-60d1-ecd8-e52d66c5879e
</span></span><span style=display:flex><span>          vm-uuid <span style=color:#f92672>(</span> RO<span style=color:#f92672>)</span>: 2d7c558a-8f03-b1d0-e813-cbe7adfa534c
</span></span><span style=display:flex><span>    vm-name-label <span style=color:#f92672>(</span> RO<span style=color:#f92672>)</span>: <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>         protocol <span style=color:#f92672>(</span> RO<span style=color:#f92672>)</span>: RFB
</span></span><span style=display:flex><span>         location <span style=color:#f92672>(</span> RO<span style=color:#f92672>)</span>: https://10.80.228.30/console?uuid<span style=color:#f92672>=</span>8013b937-ff7e-60d1-ecd8-e52d66c5879e</span></span></code></pre></div><p>Use command-line utilities like <code>ping</code> to test connectivity to the IP address provided in the <code>location</code> field.</p><h1 id=disabling-vnc-forwarding-for-linux-vm>Disabling VNC forwarding for Linux VM</h1><p>When creating and destroying Linux VMs, the host agent automatically manages the <code>vncterm</code> processes which convert the text console into VNC. Advanced users who wish to directly access the text console can disable VNC forwarding for that VM. The text console can then only be accessed directly from the control domain directly, and graphical interfaces such as XenCenter will not be able to render a console for that VM.</p><p>Before starting the guest, set the following parameter on the VM record:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ xe vm-param-set uuid<span style=color:#f92672>=</span>$VM other-config:disable_pv_vnc<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span></span></span></code></pre></div><p>Start the VM.</p><p>Use the CLI to retrieve the underlying domain ID of the VM with:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ DOMID<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>xe vm-list params<span style=color:#f92672>=</span>dom-id uuid<span style=color:#f92672>=</span>$VM --minimal<span style=color:#66d9ef>)</span></span></span></code></pre></div><p>On the host console, connect to the text console directly by:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ /usr/lib/xen/bin/xenconsole $DOMID</span></span></code></pre></div><p>This configuration is an advanced procedure, and we do not recommend that the text console is directly used for heavy I/O operations. Instead, connect to the guest over SSH or some other network-based connection mechanism.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vm-importexport>VM import/export</h1><p>VMs can be exported to a file and later imported to any Xapi host. The export
protocol is a simple HTTP(S) GET, which should be sent to the Pool master.
Authorization is either via a pre-created <code>session_id</code> or by HTTP basic
authentication (particularly useful on the command-line).
The VM to export is specified either by UUID or by reference. To keep track of
the export, a task can be created and passed in using its reference. Note that
Xapi may send an HTTP redirect if a different host has better access to the
disk data.</p><p>The following arguments are passed as URI query parameters or HTTP cookies:</p><table><thead><tr><th>Argument</th><th>Description</th></tr></thead><tbody><tr><td>session_id</td><td>the reference of the session being used to authenticate; required only when not using HTTP basic authentication</td></tr><tr><td>task_id</td><td>the reference of the task object with which to keep track of the operation; optional, required only if you have created a task object to keep track of the export</td></tr><tr><td>ref</td><td>the reference of the VM; required only if not using the UUID</td></tr><tr><td>uuid</td><td>the UUID of the VM; required only if not using the reference</td></tr><tr><td>use_compression</td><td>an optional boolean &ldquo;true&rdquo; or &ldquo;false&rdquo; (defaulting to &ldquo;false&rdquo;). If &ldquo;true&rdquo; then the output will be gzip-compressed before transmission.</td></tr></tbody></table><p>For example, using the Linux command line tool cURL:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ curl http://root:foo@myxenserver1/export?uuid<span style=color:#f92672>=</span>&lt;vm_uuid&gt; -o &lt;exportfile&gt;</span></span></code></pre></div><p>will export the specified VM to the file <code>exportfile</code>.</p><p>To export just the metadata, use the URI <code>http://server/export_metadata</code>.</p><p>The import protocol is similar, using HTTP(S) PUT. The <code>session_id</code> and <code>task_id</code> arguments are as for the export. The <code>ref</code> and <code>uuid</code> are not used; a new reference and uuid will be generated for the VM. There are some additional parameters:</p><table><thead><tr><th>Argument</th><th>Description</th></tr></thead><tbody><tr><td>restore</td><td>if <code>true</code>, the import is treated as replacing the original VM - the implication of this currently is that the MAC addresses on the VIFs are exactly as the export was, which will lead to conflicts if the original VM is still being run.</td></tr><tr><td>force</td><td>if <code>true</code>, any checksum failures will be ignored (the default is to destroy the VM if a checksum error is detected)</td></tr><tr><td>sr_id</td><td>the reference of an SR into which the VM should be imported. The default behavior is to import into the <code>Pool.default_SR</code></td></tr></tbody></table><p>Note there is no need to specify whether the export is compressed, as Xapi
will automatically detect and decompress gzip-encoded streams.</p><p>For example, again using cURL:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -T &lt;exportfile&gt; http://root:foo@myxenserver2/import</span></span></code></pre></div><p>will import the VM to the default SR on the server.</p><blockquote><p><strong>Note</strong></p><p>Note that if no default SR has been set, and no <code>sr_uuid</code> is specified, the error message <code>DEFAULT_SR_NOT_FOUND</code> is returned.</p></blockquote><p>Another example:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -T &lt;exportfile&gt; http://root:foo@myxenserver2/import?sr_id<span style=color:#f92672>=</span>&lt;ref_of_sr&gt;</span></span></code></pre></div><p>will import the VM to the specified SR on the server.</p><p>To import just the metadata, use the URI <code>http://server/import_metadata</code></p><h1 id=legacy-vm-import-format>Legacy VM Import Format</h1><p>This section describes the legacy VM import/export format and is for historical
interest only. It should be updated to describe the current format, see
<a href=https://github.com/xapi-project/xapi-project.github.io/issues/64 target=_blank>issue 64</a></p><p>Xapi supports a human-readable legacy VM input format called XVA. This section describes the syntax and structure of XVA.</p><p>An XVA consists of a directory containing XML metadata and a set of disk images. A VM represented by an XVA is not intended to be directly executable. Data within an XVA package is compressed and intended for either archiving on permanent storage or for being transmitted to a VM server - such as a XenServer host - where it can be decompressed and executed.</p><p>XVA is a hypervisor-neutral packaging format; it should be possible to create simple tools to instantiate an XVA VM on any other platform. XVA does not specify any particular runtime format; for example disks may be instantiated as file images, LVM volumes, QCoW images, VMDK or VHD images. An XVA VM may be instantiated any number of times, each instantiation may have a different runtime format.</p><p>XVA does not:</p><ul><li><p>specify any particular serialization or transport format</p></li><li><p>provide any mechanism for customizing VMs (or templates) on install</p></li><li><p>address how a VM may be upgraded post-install</p></li><li><p>define how multiple VMs, acting as an appliance, may communicate</p></li></ul><p>These issues are all addressed by the related Open Virtual Appliance specification.</p><p>An XVA is a directory containing, at a minimum, a file called <code>ova.xml</code>. This file describes the VM contained within the XVA and is described in Section 3.2. Disks are stored within sub-directories and are referenced from the ova.xml. The format of disk data is described later in Section 3.3.</p><p>The following terms will be used in the rest of the chapter:</p><ul><li><p>HVM: a mode in which unmodified OS kernels run with the help of virtualization support in the hardware.</p></li><li><p>PV: a mode in which specially modified &ldquo;paravirtualized&rdquo; kernels run explicitly on top of a hypervisor without requiring hardware support for virtualization.</p></li></ul><p>The &ldquo;ova.xml&rdquo; file contains the following elements:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;appliance</span> <span style=color:#a6e22e>version=</span><span style=color:#e6db74>&#34;0.1&#34;</span><span style=color:#f92672>&gt;</span></span></span></code></pre></div><p>The number in the attribute &ldquo;version&rdquo; indicates the version of this specification to which the XVA is constructed; in this case version 0.1. Inside the &lt;appliance> there is exactly one &lt;vm>: (in the OVA specification, multiple &lt;vm>s are permitted)</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;vm</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;name&#34;</span><span style=color:#f92672>&gt;</span></span></span></code></pre></div><p>Each <code>&lt;vm></code> element describes one VM. The &ldquo;name&rdquo; attribute is for future internal use only and must be unique within the ova.xml file. The &ldquo;name&rdquo; attribute is permitted to be any valid UTF-8 string. Inside each &lt;vm> tag are the following compulsory elements:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;label&gt;</span>... text ... <span style=color:#f92672>&lt;/label&gt;</span></span></span></code></pre></div><p>A short name for the VM to be displayed in a UI.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;shortdesc&gt;</span> ... description ... <span style=color:#f92672>&lt;/shortdesc&gt;</span></span></span></code></pre></div><p>A description for the VM to be displayed in the UI. Note that for both <code>&lt;label></code> and <code>&lt;shortdesc></code> contents, leading and trailing whitespace will be ignored.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;config</span> <span style=color:#a6e22e>mem_set=</span><span style=color:#e6db74>&#34;268435456&#34;</span> <span style=color:#a6e22e>vcpus=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>/&gt;</span></span></span></code></pre></div><p>The <code>&lt;config></code> element has attributes which describe the amount of memory in bytes (<code>mem_set</code>) and number of CPUs (VCPUs) the VM should have.</p><p>Each <code>&lt;vm></code> has zero or more <code>&lt;vbd></code> elements representing block devices which look like the following:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;vbd</span> <span style=color:#a6e22e>device=</span><span style=color:#e6db74>&#34;sda&#34;</span> <span style=color:#a6e22e>function=</span><span style=color:#e6db74>&#34;root&#34;</span> <span style=color:#a6e22e>mode=</span><span style=color:#e6db74>&#34;w&#34;</span> <span style=color:#a6e22e>vdi=</span><span style=color:#e6db74>&#34;vdi_sda&#34;</span><span style=color:#f92672>/&gt;</span></span></span></code></pre></div><p>The attributes have the following meanings:</p><ul><li><code>device</code>: name of the physical device to expose to the VM. For linux guests
we use &ldquo;sd[a-z]&rdquo; and for windows guests we use &ldquo;hd[a-d]&rdquo;.</li><li><code>function</code>: if marked as &ldquo;root&rdquo;, this disk will be used to boot the guest.
(NB this does not imply the existence of the Linux root i.e. / filesystem)
Only one device should be marked as &ldquo;root&rdquo;. See Section 3.4 describing VM
booting. Any other string is ignored.</li><li><code>mode</code>: either &ldquo;w&rdquo; or &ldquo;ro&rdquo; if the device is to be read/write or read-only</li><li><code>vdi</code>: the name of the disk image (represented by a <code>&lt;vdi></code> element) to which
this block device is connected</li></ul><p>Each <code>&lt;vm></code> may have an optional <code>&lt;hacks></code> section like the following:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;hacks</span> <span style=color:#a6e22e>is_hvm=</span><span style=color:#e6db74>&#34;false&#34;</span> <span style=color:#a6e22e>kernel_boot_cmdline=</span><span style=color:#e6db74>&#34;root=/dev/sda1 ro&#34;</span><span style=color:#f92672>/&gt;</span></span></span></code></pre></div><p>The <code>&lt;hacks></code> element will be removed in future. The attribute <code>is_hvm</code> is
either <code>true</code> or <code>false</code>, depending on whether the VM should be booted in HVM or not.
The <code>kernel_boot_cmdline</code> contains additional kernel commandline arguments when
booting a guest using pygrub.</p><p>In addition to a <code>&lt;vm></code> element, the <code>&lt;appliance></code> will contain zero or more
<code>&lt;vdi></code> elements like the following:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;vdi</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;vdi_sda&#34;</span> <span style=color:#a6e22e>size=</span><span style=color:#e6db74>&#34;5368709120&#34;</span> <span style=color:#a6e22e>source=</span><span style=color:#e6db74>&#34;file://sda&#34;</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#34;dir-gzipped-chunks&#34;</span><span style=color:#f92672>&gt;</span></span></span></code></pre></div><p>Each <code>&lt;vdi></code> corresponds to a disk image. The attributes have the following meanings:</p><ul><li><code>name</code>: name of the VDI, referenced by the vdi attribute of <code>&lt;vbd></code>elements.
Any valid UTF-8 string is permitted.</li><li><code>size</code>: size of the required image in bytes</li><li><code>source</code>: a URI describing where to find the data for the image, only
file:// URIs are currently permitted and must describe paths relative to the
directory containing the ova.xml</li><li><code>type</code>: describes the format of the disk data</li></ul><p>A single disk image encoding is specified in which has type &ldquo;dir-gzipped-chunks&rdquo;: Each image is represented by a directory containing a sequence of files as follows:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> dscott xendev <span style=color:#ae81ff>458286013</span>    Sep <span style=color:#ae81ff>18</span> 09:51 chunk000000000.gz
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> dscott xendev <span style=color:#ae81ff>422271283</span>    Sep <span style=color:#ae81ff>18</span> 09:52 chunk000000001.gz
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> dscott xendev <span style=color:#ae81ff>395914244</span>    Sep <span style=color:#ae81ff>18</span> 09:53 chunk000000002.gz
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> dscott xendev <span style=color:#ae81ff>9452401</span>      Sep <span style=color:#ae81ff>18</span> 09:53 chunk000000003.gz
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> dscott xendev <span style=color:#ae81ff>1096066</span>      Sep <span style=color:#ae81ff>18</span> 09:53 chunk000000004.gz
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> dscott xendev <span style=color:#ae81ff>971976</span>       Sep <span style=color:#ae81ff>18</span> 09:53 chunk000000005.gz
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> dscott xendev <span style=color:#ae81ff>971976</span>       Sep <span style=color:#ae81ff>18</span> 09:53 chunk000000006.gz
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> dscott xendev <span style=color:#ae81ff>971976</span>       Sep <span style=color:#ae81ff>18</span> 09:53 chunk000000007.gz
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> dscott xendev <span style=color:#ae81ff>573930</span>       Sep <span style=color:#ae81ff>18</span> 09:53 chunk000000008.gz</span></span></code></pre></div><p>Each file (named &ldquo;chunk-XXXXXXXXX.gz&rdquo;) is a gzipped file containing exactly 1e9 bytes (1GB, not 1GiB) of raw block data. The small size was chosen to be safely under the maximum file size limits of several filesystems. If the files are gunzipped and then concatenated together, the original image is recovered.</p><p>Because the import and export of VMs can take some time to complete, an
asynchronous HTTP interface to the import and export operations is
provided. To perform an export using the XenServer API, construct
an HTTP GET call providing a valid session ID, task ID and VM UUID, as
shown in the following pseudo code:</p><pre><code>task = Task.create()
result = HTTP.get(
  server, 80, &quot;/export?session_id=&amp;task_id=&amp;ref=&quot;);
</code></pre><p>For the import operation, use an HTTP PUT call as demonstrated in the
following pseudo code:</p><pre><code>task = Task.create()
result = HTTP.put(
  server, 80, &quot;/import?session_id=&amp;task_id=&amp;ref=&quot;);
</code></pre><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vm-lifecycle>VM Lifecycle</h1><div class="mermaid align-center">graph
halted-- start(paused) -->paused
halted-- start(not paused) -->running
running-- suspend -->suspended
suspended-- resume(not paused) -->running
suspended-- resume(paused) -->paused
suspended-- hard shutdown -->halted
paused-- unpause -->running
paused-- hard shutdown -->halted
running-- clean shutdown\n hard shutdown -->halted
running-- pause -->paused
halted-- destroy -->destroyed</div><p>The figure above shows the states that a VM can be in and the
API calls that can be used to move the VM between these states.</p><ul class="children children-li children-sort-"></ul><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xencenter>XenCenter</h1><p>XenCenter uses some conventions on top of the XenAPI:</p><h2 id=internationalization-for-sr-names>Internationalization for SR names</h2><p>The SRs created at install time now have an <code>other_config</code> key indicating how their names may be internationalized.</p><p><code>other_config["i18n-key"]</code> may be one of</p><ul><li><p><code>local-hotplug-cd</code></p></li><li><p><code>local-hotplug-disk</code></p></li><li><p><code>local-storage</code></p></li><li><p><code>xenserver-tools</code></p></li></ul><p>Additionally, <code>other_config["i18n-original-value-&lt;field name>"]</code> gives the value of that field when the SR was created. If XenCenter sees a record where <code>SR.name_label</code> equals <code>other_config["i18n-original-value-name_label"]</code> (that is, the record has not changed since it was created during XenServer installation), then internationalization will be applied. In other words, XenCenter will disregard the current contents of that field, and instead use a value appropriate to the user&rsquo;s own language.</p><p>If you change <code>SR.name_label</code> for your own purpose, then it no longer is the same as <code>other_config["i18n-original-value-name_label"]</code>. Therefore, XenCenter does not apply internationalization, and instead preserves your given name.</p><h2 id=hiding-objects-from-xencenter>Hiding objects from XenCenter</h2><p>Networks, PIFs, and VMs can be hidden from XenCenter by adding the key <code>HideFromXenCenter=true</code> to the <code>other_config</code> parameter for the object. This capability is intended for ISVs who know what they are doing, not general use by everyday users. For example, you might want to hide certain VMs because they are cloned VMs that shouldn&rsquo;t be used directly by general users in your environment.</p><p>In XenCenter, hidden Networks, PIFs, and VMs can be made visible, using the View menu.</p><footer class=footline></footer></article></section></section></div></main></div><script src=/new-docs/js/clipboard.min.js?1729773859 defer></script><script src=/new-docs/js/perfect-scrollbar.min.js?1729773859 defer></script><script src=/new-docs/js/d3/d3-color.min.js?1729773859 defer></script><script src=/new-docs/js/d3/d3-dispatch.min.js?1729773859 defer></script><script src=/new-docs/js/d3/d3-drag.min.js?1729773859 defer></script><script src=/new-docs/js/d3/d3-ease.min.js?1729773859 defer></script><script src=/new-docs/js/d3/d3-interpolate.min.js?1729773859 defer></script><script src=/new-docs/js/d3/d3-selection.min.js?1729773859 defer></script><script src=/new-docs/js/d3/d3-timer.min.js?1729773859 defer></script><script src=/new-docs/js/d3/d3-transition.min.js?1729773859 defer></script><script src=/new-docs/js/d3/d3-zoom.min.js?1729773859 defer></script><script src=/new-docs/js/js-yaml.min.js?1729773859 defer></script><script src=/new-docs/js/mermaid.min.js?1729773859 defer></script><script>window.themeUseMermaid=JSON.parse("{}")</script><script src=/new-docs/js/theme.js?1729773859 defer></script></body></html>