<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.127.0"><meta name=generator content="Relearn 5.20.0+tip"><meta name=description content><title>XenAPI :: XAPI Toolstack Developer Documentation</title>
<link href=https://xapi-project.github.io/new-docs/xen-api/index.html rel=canonical type=text/html title="XenAPI :: XAPI Toolstack Developer Documentation"><link href=/new-docs/xen-api/index.xml rel=alternate type=application/rss+xml title="XenAPI :: XAPI Toolstack Developer Documentation"><link href=/new-docs/images/favicon.png?1719501488 rel=icon type=image/png><link href=/new-docs/css/fontawesome-all.min.css?1719501490 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/fontawesome-all.min.css?1719501490 rel=stylesheet></noscript><link href=/new-docs/css/nucleus.css?1719501490 rel=stylesheet><link href=/new-docs/css/auto-complete.css?1719501490 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/auto-complete.css?1719501490 rel=stylesheet></noscript><link href=/new-docs/css/perfect-scrollbar.min.css?1719501490 rel=stylesheet><link href=/new-docs/css/fonts.css?1719501490 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/fonts.css?1719501490 rel=stylesheet></noscript><link href=/new-docs/css/theme.css?1719501490 rel=stylesheet><link href=/new-docs/css/theme-auto.css?1719501490 rel=stylesheet id=variant-style><link href=/new-docs/css/variant.css?1719501490 rel=stylesheet><link href=/new-docs/css/print.css?1719501490 rel=stylesheet media=print><link href=/new-docs/css/format-print.css?1719501490 rel=stylesheet><link href=/new-docs/css/ie.css?1719501490 rel=stylesheet><script src=/new-docs/js/url.js?1719501490></script><script src=/new-docs/js/variant.js?1719501490></script><script>window.index_js_url="/new-docs/index.search.js";var baseUriFull,root_url="/",baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copy to clipboard",window.T_Copied_to_clipboard="Copied to clipboard!",window.T_Copy_link_to_clipboard="Copy link to clipboard",window.T_Link_copied_to_clipboard="Copied link to clipboard!",window.T_No_results_found='No results found for "{0}"',window.T_N_results_found='{1} results found for "{0}"',baseUriFull="https://xapi-project.github.io/new-docs/",window.variants&&variants.init(["auto","zen-light","zen-dark","red","blue","green","learn","neon","relearn-light","relearn-bright","relearn-dark"])</script><link rel=stylesheet href=https://xapi-project.github.io/new-docs/css/misc.css></head><body class="mobile-support print" data-url=/new-docs/xen-api/index.html><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle class=topbar-link title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/new-docs/index.html><span itemprop=name>XAPI Toolstack Developer Guide</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>XenAPI</span><meta itemprop=position content="2"></li></ol></div></div></nav><main id=body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=xenapi>XenAPI</h1><ul class="children children-li children-sort-"><li><a href=/new-docs/xen-api/basics/index.html>XenAPI Basics</a></li><li><a href=/new-docs/xen-api/wire-protocol/index.html>Wire Protocol</a></li><li><a href=/new-docs/xen-api/overview/index.html>Overview of the XenAPI</a></li><li><a href=/new-docs/xen-api/evolution/index.html>API evolution</a></li><li><a href=/new-docs/xen-api/classes/index.html>XenAPI Reference</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of XenAPI</h1><article class=default><header class=headline></header><h1 id=xenapi-basics>XenAPI Basics</h1><p>This document contains a description of the Xen Management API – an interface for
remotely configuring and controlling virtualised guests running on a
Xen-enabled host.</p><p>The XenAPI is presented here as a set of Remote Procedure Calls, with a wire
format based upon <a href=http://xmlrpc.scripting.com target=_blank>XML-RPC</a>.
No specific language bindings are prescribed,
although examples will be given in the python programming language.</p><p>Although we adopt some terminology from object-oriented programming,
future client language bindings may or may not be object oriented.
The API reference uses the terminology <em>classes</em> and <em>objects</em>.
For our purposes a <em>class</em> is simply a hierarchical namespace;
an <em>object</em> is an instance of a class with its fields set to
specific values. Objects are persistent and exist on the server-side.
Clients may obtain opaque references to these server-side objects and then
access their fields via get/set RPCs.</p><p>For each class we specify a list of fields along with their <em>types</em> and <em>qualifiers</em>. A
qualifier is one of:</p><ul><li><em>RO/runtime</em>: the field is Read
Only. Furthermore, its value is automatically computed at runtime.
For example: current CPU load and disk IO throughput.</li><li><em>RO/constructor</em>: the field must be manually set
when a new object is created, but is then Read Only for
the duration of the object&rsquo;s life.
For example, the maximum memory addressable by a guest is set
before the guest boots.</li><li><em>RW</em>: the field is Read/Write. For example, the name of a VM.</li></ul><h2 id=types>Types</h2><p>The following types are used to specify methods and fields in the API Reference:</p><ul><li><code>string</code>: Text strings.</li><li><code>int</code>: 64-bit integers.</li><li><code>float</code>: IEEE double-precision floating-point numbers.</li><li><code>bool</code>: Boolean.</li><li><code>datetime</code>: Date and timestamp.</li><li><code>c ref</code>: Reference to an object of class <code>c</code>.</li><li><code>t set</code>: Arbitrary-length set of values of type <code>t</code>.</li><li><code>(k → v) map</code>: Mapping from values of type <code>k</code> to values of type <code>v</code>.</li><li><code>e enum</code>: Enumeration type with name <code>e</code>. Enums are defined in the API Reference together with classes that use them.</li></ul><p>Note that there are a number of cases where <code>ref</code>s are <em>doubly
linked</em> – e.g. a VM has a field called <code>VIFs</code> of type
<code>VIF ref set</code>; this field lists
the network interfaces attached to a particular VM. Similarly, the VIF
class has a field called <code>VM</code> of type <code>VM ref</code> which references the VM to which the interface is connected.
These two fields are <em>bound together</em>, in the sense that
creating a new VIF causes the <code>VIFs</code> field of the corresponding
VM object to be updated automatically.</p><p>The API reference explicitly lists the fields that are
bound together in this way. It also contains a diagram that shows
relationships between classes. In this diagram an edge signifies the
existance of a pair of fields that are bound together, using standard
crows-foot notation to signify the type of relationship (e.g.
one-many, many-many).</p><h2 id=rpcs-associated-with-fields>RPCs associated with fields</h2><p>Each field, <code>f</code>, has an RPC accessor associated with it
that returns <code>f</code>&rsquo;s value:</p><ul><li><code>get_f (r)</code>: Takes a <code>ref</code>, <code>r</code>, that refers to an object and returns the value of <code>f</code>.</li></ul><p>Each field, <code>f</code>, with attribute <code>RW</code> and whose outermost type is <code>set</code> has the following
additional RPCs associated with it:</p><ul><li><p><code>add_f (r, v)</code>: Adds a new element <code>v</code> to the set. Since sets cannot contain duplicate values this operation has no action in the case
that <code>v</code> was already in the set.</p></li><li><p><code>remove_f (r, v)</code>: Removes element <code>v</code> from the set.</p></li></ul><p>Each field, <code>f</code>, with attribute RW and whose outermost type is <code>map</code> has the following
additional RPCs associated with it:</p><ul><li><code>add_to_f (r, k, v)</code>: Adds new pair <code>(k → v)</code> to the mapping stored in <code>f</code> in object <code>r</code>. Attempting to add a new pair for duplicate
key, <code>k</code>, fails with an <code>MAP_DUPLICATE_KEY</code> error.</li><li><code>remove_from_f (r, k)</code>: Removes the pair with key <code>k</code> from the mapping stored in <code>f</code> in object <code>r</code>.</li></ul><p>Each field whose outermost type is neither <code>set</code> nor <code>map</code>,
but whose attribute is RW has an RPC accessor associated with it
that sets its value:</p><ul><li><code>set_f (r, v)</code>: Sets field <code>f</code> on object <code>r</code> to value <code>v</code>.</li></ul><h2 id=rpcs-associated-with-classes>RPCs associated with classes</h2><ul><li>Most classes have a <em>constructor</em> RPC named <code>create</code> that
takes as parameters all fields marked RW and
RO/constructor. The result of this RPC is that a new <em>persistent</em> object is
created on the server-side with the specified field values.</li><li>Each class has a <code>get_by_uuid (uuid)</code> RPC that returns the object
of that class that has the specified UUID.</li><li>Each class that has a <code>name_label</code> field has a <code>get_by_name_label (name_label)</code> RPC that returns a set of objects of that
class that have the specified <code>name_label</code>.</li><li>Most classes have a <code>destroy (r)</code> RPC that explicitly deletes the persistent object specified by <code>r</code> from the system. This is a
non-cascading delete – if the object being removed is referenced by another
object then the <code>destroy</code> call will fail.</li></ul><h2 id=additional-rpcs>Additional RPCs</h2><p>As well as the RPCs enumerated above, most classes have additional RPCs
associated with them. For example, the VM class has RPCs for cloning,
suspending, starting etc. Such additional RPCs are described explicitly
in the API reference.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=wire-protocol>Wire Protocol</h1><p>API calls are sent over a network to a Xen-enabled host using the
<a href=http://xmlrpc.scripting.com/spec.html target=_blank>XML-RPC</a> protocol. On this page, we describe how the higher-level types
used in our API Reference are mapped to primitive XML-RPC types.</p><p>We specify the signatures of API functions in the following style:</p><pre><code>(VM ref set)  VM.get_all ()
</code></pre><p>This specifies that the function with name <code>VM.get_all</code>
takes no parameters and returns a <code>set</code> of <code>VM ref</code>s. These
types are mapped onto XML-RPC types in a straight-forward manner:</p><ul><li><p><code>float</code>s, <code>bool</code>s, <code>datetime</code>s and <code>string</code>s map directly to the XML-RPC
<code>&lt;double></code>, <code>&lt;boolean></code>, <code>&lt;dateTime.iso8601></code>, and <code>&lt;string></code> elements.</p></li><li><p>all <code>ref</code> types are opaque references, encoded as the
XML-RPC’s <code>&lt;string></code> type. Users of the API should not make
assumptions about the concrete form of these strings and should not
expect them to remain valid after the client’s session with the
server has terminated.</p></li><li><p>fields named <code>uuid</code> of type <code>string</code> are
mapped to the XML-RPC <code>&lt;string></code> type. The string itself is
the OSF DCE UUID presentation format (as output by
<code>uuidgen</code>, etc).</p></li><li><p><code>int</code>s are all assumed to be 64-bit in our API and are encoded as a
string of decimal digits (rather than using XML-RPC’s built-in
32-bit <code>&lt;i4></code> type).</p></li><li><p>values of <code>enum</code> types are encoded as strings. For example, a value of
<code>destroy</code> of type <code>enum on_normal_exit</code>, would be
conveyed as:</p><pre><code>&lt;value&gt;&lt;string&gt;destroy&lt;/string&gt;&lt;/value&gt;
</code></pre></li><li><p>for all our types, <code>t</code>, our type <code>t set</code>
simply maps to XML-RPC’s <code>&lt;array></code> type, so for example a
value of type <code>string set</code> would be transmitted like
this:</p><pre><code>&lt;value&gt;
  &lt;array&gt;
    &lt;data&gt;
      &lt;value&gt;&lt;string&gt;CX8&lt;/string&gt;&lt;/value&gt;
      &lt;value&gt;&lt;string&gt;PSE36&lt;/string&gt;&lt;/value&gt;
      &lt;value&gt;&lt;string&gt;FPU&lt;/string&gt;&lt;/value&gt;
    &lt;/data&gt;
  &lt;/array&gt; 
&lt;/value&gt;
</code></pre></li><li><p>for types <code>k</code> and <code>v</code>, our type <code>(k → v) map</code> maps onto an XML-RPC <code>&lt;struct></code>, with the key as the name of
the struct. Note that the <code>(k → v) map</code> type is only valid
when <code>k</code> is a <code>string</code>, <code>ref</code>, or <code>int</code>, and in each case the keys of the maps are
stringified as above. For example, the <code>(string → double) map</code> containing a the mappings <code>"Mike" → 2.3</code> and
<code>"John" → 1.2</code> would be represented as:</p><pre><code>&lt;value&gt;
  &lt;struct&gt;
    &lt;member&gt;
      &lt;name&gt;Mike&lt;/name&gt;
      &lt;value&gt;&lt;double&gt;2.3&lt;/double&gt;&lt;/value&gt;
    &lt;/member&gt;
    &lt;member&gt;
      &lt;name&gt;John&lt;/name&gt;
      &lt;value&gt;&lt;double&gt;1.2&lt;/double&gt;&lt;/value&gt;
    &lt;/member&gt;
  &lt;/struct&gt;
&lt;/value&gt;
</code></pre></li><li><p>our <code>void</code> type is transmitted as an empty string.</p></li></ul><h2 id=note-on-references-vs-uuids>Note on References vs UUIDs</h2><p>References are opaque types — encoded as XML-RPC strings on the wire —
understood only by the particular server which generated them. Servers
are free to choose any concrete representation they find convenient;
clients should not make any assumptions or attempt to parse the string
contents. References are not guaranteed to be permanent identifiers for
objects; clients should not assume that references generated during one
session are valid for any future session. References do not allow
objects to be compared for equality. Two references to the same object
are not guaranteed to be textually identical.</p><p>UUIDs are intended to be permanent names for objects. They are
guaranteed to be in the OSF DCE UUID presentation format (as output by
<code>uuidgen</code>. Clients may store UUIDs on disk and use them to
lookup objects in subsequent sessions with the server. Clients may also
test equality on objects by comparing UUID strings.</p><p>The API provides mechanisms for translating between UUIDs and opaque
references. Each class that contains a UUID field provides:</p><ul><li><p>A <code>get_by_uuid</code> method that takes a UUID, and
returns an opaque reference to the server-side object that has that
UUID;</p></li><li><p>A <code>get_uuid</code> function (a regular “field getter” RPC)
that takes an opaque reference and returns the UUID of the
server-side object that is referenced by it.</p></li></ul><h2 id=return-valuesstatus-codes>Return Values/Status Codes</h2><p>The return value of an RPC call is an XML-RPC <code>&lt;struct></code>.</p><ul><li>The first element of the struct is named <code>"Status"</code>; it
contains a string value indicating whether the result of the call
was a <code>"Success"</code> or a <code>"Failure"</code>.</li></ul><p>If <code>"Status"</code> was set to <code>"Success"</code> then the Struct
contains a second element named <code>"Value"</code>:</p><ul><li>The element of the struct named <code>"Value"</code> contains the
function’s return value.</li></ul><p>In the case where <code>"Status"</code> is set to <code>"Failure"</code>
then the struct contains a second element named
<code>"ErrorDescription"</code>:</p><ul><li>The element of the struct named <code>"ErrorDescription"</code>
contains an array of string values. The first element of the array
is an error code; the remainder of the array are strings
representing error parameters relating to that code.</li></ul><p>For example, an XML-RPC return value from the
<code>host.get_resident_VMs</code> function above may look like this:</p><pre><code>&lt;struct&gt;
   &lt;member&gt;
     &lt;name&gt;Status&lt;/name&gt;
     &lt;value&gt;Success&lt;/value&gt;
   &lt;/member&gt;
   &lt;member&gt;
      &lt;name&gt;Value&lt;/name&gt;
      &lt;value&gt;
        &lt;array&gt;
           &lt;data&gt;
             &lt;value&gt;81547a35-205c-a551-c577-00b982c5fe00&lt;/value&gt;
             &lt;value&gt;61c85a22-05da-b8a2-2e55-06b0847da503&lt;/value&gt;
             &lt;value&gt;1d401ec4-3c17-35a6-fc79-cee6bd9811fe&lt;/value&gt;
           &lt;/data&gt;
        &lt;/array&gt;
     &lt;/value&gt;
   &lt;/member&gt;
&lt;/struct&gt;
</code></pre><h1 id=making-xml-rpc-calls>Making XML-RPC Calls</h1><h2 id=transport-layer>Transport Layer</h2><p>The following transport layers are currently supported:</p><ul><li><p>HTTPS for remote administration</p></li><li><p>HTTP over Unix domain sockets for local administration</p></li></ul><h2 id=session-layer>Session Layer</h2><p>The XML-RPC interface is session-based; before you can make arbitrary
RPC calls you must login and initiate a session. For example:</p><pre><code>(session ref)  session.login_with_password(string  uname, string  pwd, string  version, string  originator)
</code></pre><p>Where <code>uname</code> and <code>password</code> refer to your
username and password respectively, as defined by the Xen administrator.
The <code>session ref</code> returned by <code>session.login_with_password</code> is passed to subequent RPC
calls as an authentication token.</p><p>A session can be terminated with the <code>session.logout</code> function:</p><pre><code>(void)  session.logout (session ref)
</code></pre><h2 id=synchronous-and-asynchronous-invocation>Synchronous and Asynchronous invocation</h2><p>Each method call (apart from methods on <code>session</code> and <code>task</code> objects and
“getters” and “setters” derived from fields) can be made either
synchronously or asynchronously. A synchronous RPC call blocks until the
return value is received; the return value of a synchronous RPC call is
exactly as specified above.</p><p>Only synchronous API calls are listed explicitly in this document. All
asynchronous versions are in the special <code>Async</code> namespace.
For example, synchronous call <code>VM.clone (...)</code> has an asynchronous counterpart,
<code>Async.VM.clone (...)</code>, that is non-blocking.</p><p>Instead of returning its result directly, an asynchronous RPC call
returns a task ID (of type <code>task ref</code>); this identifier is subsequently used to
track the status of a running asynchronous RPC. Note that an asychronous
call may fail immediately, before a task has even been
created. To represent this eventuality, the returned <code>task ref</code>
is wrapped in an XML-RPC struct with a <code>Status</code>,
<code>ErrorDescription</code> and <code>Value</code> fields, exactly as
specified above.</p><p>The <code>task ref</code> is provided in the <code>Value</code> field if
<code>Status</code> is set to <code>Success</code>.</p><p>The RPC call</p><pre><code>(task ref set)  task.get_all (session ref)
</code></pre><p>returns a set of all task IDs known to the system. The status (including
any returned result and error codes) of these tasks can then be queried
by accessing the fields of the Task object in the usual way. Note that,
in order to get a consistent snapshot of a task’s state, it is advisable
to call the <code>get_record</code> function.</p><h1 id=example-interactive-session>Example interactive session</h1><p>This section describes how an interactive session might look, using the
python XML-RPC client library.</p><p>First, initialise python and import the library <code>xmlrpc.client</code>:</p><pre><code>$ python
...
&gt;&gt;&gt; import xmlrpc.client
</code></pre><p>Create a python object referencing the remote server:</p><pre><code>&gt;&gt;&gt; xen = xmlrpc.client.Server(&quot;https://localhost:443&quot;)
</code></pre><p>Acquire a session reference by logging in with a username and password
(error-handling ommitted for brevity; the session reference is returned
under the key <code>'Value'</code> in the resulting dictionary)</p><pre><code>&gt;&gt;&gt; session = xen.session.login_with_password(&quot;user&quot;, &quot;passwd&quot;)['Value']
</code></pre><p>When serialised, this call looks like the following:</p><pre><code>&lt;?xml version='1.0'?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;session.login_with_password&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;&lt;string&gt;user&lt;/string&gt;&lt;/value&gt;
    &lt;/param&gt;
    &lt;param&gt;
      &lt;value&gt;&lt;string&gt;passwd&lt;/string&gt;&lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;
</code></pre><p>Next, the user may acquire a list of all the VMs known to the system:
(Note the call takes the session reference as the only parameter)</p><pre><code>&gt;&gt;&gt; all_vms = xen.VM.get_all(session)['Value']
&gt;&gt;&gt; all_vms
['OpaqueRef:1', 'OpaqueRef:2', 'OpaqueRef:3', 'OpaqueRef:4']
</code></pre><p>The VM references here have the form <code>OpaqueRef:X</code>, though
they may not be that simple in the future, and you should treat them as
opaque strings. <em>Templates</em> are VMs with the
<code>is_a_template</code> field set to <code>true</code>. We can find the subset
of template VMs using a command like the following:</p><pre><code>&gt;&gt;&gt; all_templates = filter(lambda x: xen.VM.get_is_a_template(session, x)['Value'], all_vms)
</code></pre><p>Once a reference to a VM has been acquired a lifecycle operation may be
invoked:</p><pre><code>&gt;&gt;&gt; xen.VM.start(session, all_templates[0], False, False)
{'Status': 'Failure', 'ErrorDescription': ['VM_IS_TEMPLATE', 'OpaqueRef:X']}
</code></pre><p>In this case the <code>start</code> message has been rejected, because
the VM is a template, and so an error response has been returned. These
high-level errors are returned as structured data (rather than as
XML-RPC faults), allowing them to be internationalised.</p><p>Rather than querying fields individually, whole <em>records</em>
may be returned at once. To retrieve the record of a single object as a
python dictionary:</p><pre><code>&gt;&gt;&gt; record = xen.VM.get_record(session, all_templates[0])['Value']
&gt;&gt;&gt; record['power_state']
'Halted'
&gt;&gt;&gt; record['name_label']
'XenSource P2V Server'
</code></pre><p>To retrieve all the VM records in a single call:</p><pre><code>&gt;&gt;&gt; records = xen.VM.get_all_records(session)['Value']
&gt;&gt;&gt; records.keys()
['OpaqueRef:1', 'OpaqueRef:2', 'OpaqueRef:3', 'OpaqueRef:4' ]
&gt;&gt;&gt; records['OpaqueRef:1']['name_label']
'RHEL 4.1 Autoinstall Template'
</code></pre><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=overview-of-the-xenapi>Overview of the XenAPI</h1><p>This chapter introduces the XenAPI and its associated object model. The API has the following key features:</p><ul><li><p><em>Management of all aspects of the XenServer Host</em>.
The API allows you to manage VMs, storage, networking, host configuration and pools. Performance and status metrics can also be queried from the API.</p></li><li><p><em>Persistent Object Model</em>.
The results of all side-effecting operations (e.g. object creation, deletion and parameter modifications) are persisted in a server-side database that is managed by the XenServer installation.</p></li><li><p><em>An event mechanism</em>.
Through the API, clients can register to be notified when persistent (server-side) objects are modified. This enables applications to keep track of datamodel modifications performed by concurrently executing clients.</p></li><li><p><em>Synchronous and asynchronous invocation</em>.
All API calls can be invoked synchronously (that is, block until completion); any API call that may be long-running can also be invoked <em>asynchronously</em>. Asynchronous calls return immediately with a reference to a <em>task</em> object. This task object can be queried (through the API) for progress and status information. When an asynchronously invoked operation completes, the result (or error code) is available from the task object.</p></li><li><p><em>Remotable and Cross-Platform</em>.
The client issuing the API calls does not have to be resident on the host being managed; nor does it have to be connected to the host over ssh in order to execute the API. API calls make use of the XML-RPC protocol to transmit requests and responses over the network.</p></li><li><p><em>Secure and Authenticated Access</em>.
The XML-RPC API server executing on the host accepts secure socket connections. This allows a client to execute the APIs over the https protocol. Further, all the API calls execute in the context of a login session generated through username and password validation at the server. This provides secure and authenticated access to the XenServer installation.</p></li></ul><h2 id=getting-started-with-the-api>Getting Started with the API</h2><p>We will start our tour of the API by describing the calls required to create a new VM on a XenServer installation, and take it through a start/suspend/resume/stop cycle. This is done without reference to code in any specific language; at this stage we just describe the informal sequence of RPC invocations that accomplish our &ldquo;install and start&rdquo; task.</p><h3 id=authentication-acquiring-a-session-reference>Authentication: acquiring a session reference</h3><p>The first step is to call <code>Session.login_with_password(, , , )</code>. The API is session based, so before you can make other calls you will need to authenticate with the server. Assuming the username and password are authenticated correctly, the result of this call is a <em>session reference</em>. Subsequent API calls take the session reference as a parameter. In this way we ensure that only API users who are suitably authorized can perform operations on a XenServer installation. You can continue to use the same session for any number of API calls. When you have finished the session, Citrix recommends that you call <code>Session.logout(session)</code> to clean up: see later.</p><h3 id=acquiring-a-list-of-templates-to-base-a-new-vm-installation-on>Acquiring a list of templates to base a new VM installation on</h3><p>The next step is to query the list of &ldquo;templates&rdquo; on the host. Templates are specially-marked VM objects that specify suitable default parameters for a variety of supported guest types. (If you want to see a quick enumeration of the templates on a XenServer installation for yourself then you can execute the <code>xe template-list</code> CLI command.) To get a list of templates from the API, we need to find the VM objects on the server that have their <code>is_a_template</code> field set to true. One way to do this by calling <code>VM.get_all_records(session)</code> where the session parameter is the reference we acquired from our <code>Session.login_with_password</code> call earlier. This call queries the server, returning a snapshot (taken at the time of the call) containing all the VM object references and their field values.</p><p>(Remember that at this stage we are not concerned about the particular mechanisms by which the returned object references and field values can be manipulated in any particular client language: that detail is dealt with by our language-specific API bindings and described concretely in the following chapter. For now it suffices just to assume the existence of an abstract mechanism for reading and manipulating objects and field values returned by API calls.)</p><p>Now that we have a snapshot of all the VM objects&rsquo; field values in the memory of our client application we can simply iterate through them and find the ones that have their &ldquo;<code>is_a_template</code>&rdquo; set to true. At this stage let&rsquo;s assume that our example application further iterates through the template objects and remembers the reference corresponding to the one that has its &ldquo;<code>name_label</code>&rdquo; set to &ldquo;Debian Etch 4.0&rdquo; (one of the default Linux templates supplied with XenServer).</p><h3 id=installing-the-vm-based-on-a-template>Installing the VM based on a template</h3><p>Continuing through our example, we must now install a new VM based on the template we selected. The installation process requires 4 API calls:</p><ul><li><p>First we must now invoke the API call <code>VM.clone(session, t_ref, "my first VM")</code>. This tells the server to clone the VM object referenced by <code>t_ref</code> in order to make a new VM object. The return value of this call is the VM reference corresponding to the newly-created VM. Let&rsquo;s call this <code>new_vm_ref</code>.</p></li><li><p>Next, we need to specify the UUID of the Storage Repository where the VM&rsquo;s
disks will be instantiated. We have to put this in the <code>sr</code> attribute in
the disk provisioning XML stored under the &ldquo;<code>disks</code>&rdquo; key in the
<code>other_config</code> map of the newly-created VM. This field can be updated by
calling its getter (<code>other_config &lt;- VM.get_other_config(session, new_vm_ref)</code>) and then its setter (<code>VM.set_other_config(session, new_vm_ref, other_config)</code>) with the modified <code>other_config</code> map.</p></li><li><p>At this stage the object referred to by <code>new_vm_ref</code> is still a template (just like the VM object referred to by <code>t_ref</code>, from which it was cloned). To make <code>new_vm_ref</code> into a VM object we need to call <code>VM.provision(session, new_vm_ref)</code>. When this call returns the <code>new_vm_ref</code> object will have had its <code>is_a_template</code> field set to false, indicating that <code>new_vm_ref</code> now refers to a regular VM ready for starting.</p></li></ul><blockquote><p><strong>Note</strong></p><p>The provision operation may take a few minutes, as it is as during this call that the template&rsquo;s disk images are created. In the case of the Debian template, the newly created disks are also at this stage populated with a Debian root filesystem.</p></blockquote><h3 id=taking-the-vm-through-a-startsuspendresumestop-cycle>Taking the VM through a start/suspend/resume/stop cycle</h3><p>Now we have an object reference representing our newly-installed VM, it is trivial to take it through a few lifecycle operations:</p><ul><li><p>To start our VM we can just call <code>VM.start(session, new_vm_ref)</code></p></li><li><p>After it&rsquo;s running, we can suspend it by calling <code>VM.suspend(session, new_vm_ref)</code>,</p></li><li><p>and then resume it by calling <code>VM.resume(session, new_vm_ref)</code>.</p></li><li><p>We can call <code>VM.shutdown(session, new_vm_ref)</code> to shutdown the VM cleanly.</p></li></ul><h3 id=logging-out>Logging out</h3><p>Once an application is finished interacting with a XenServer Host it is good practice to call <code>Session.logout(session)</code>. This invalidates the session reference (so it cannot be used in subsequent API calls) and simultaneously deallocates server-side memory used to store the session object.</p><p>Although inactive sessions will eventually timeout, the server has a hardcoded limit of 500 concurrent sessions for each <code>username</code> or <code>originator</code>. Once this limit has been reached fresh logins will evict the session objects that have been used least recently, causing their associated session references to become invalid. For successful interoperability with other applications, concurrently accessing the server, the best policy is:</p><ul><li><p>Choose a string that identifies your application and its version.</p></li><li><p>Create a single session at start-of-day, using that identifying string for the <code>originator</code> parameter to <code>Session.login_with_password</code>.</p></li><li><p>Use this session throughout the application (note that sessions can be used across multiple separate client-server <em>network connections</em>) and then explicitly logout when possible.</p></li></ul><p>If a poorly written client leaks sessions or otherwise exceeds the limit, then as long as the client uses an appropriate <code>originator</code> argument, it will be easily identifiable from the XenServer logs and XenServer will destroy the longest-idle sessions of the rogue client only; this may cause problems for that client but not for other clients. If the misbehaving client did not specify an <code>originator</code>, it would be harder to identify and would cause the premature destruction of sessions of any clients that also did not specify an <code>originator</code></p><h3 id=install-and-start-example-summary>Install and start example: summary</h3><p>We have seen how the API can be used to install a VM from a XenServer template and perform a number of lifecycle operations on it. You will note that the number of calls we had to make in order to affect these operations was small:</p><ul><li><p>One call to acquire a session: <code>Session.login_with_password()</code></p></li><li><p>One call to query the VM (and template) objects present on the XenServer installation: <code>VM.get_all_records()</code>. Recall that we used the information returned from this call to select a suitable template to install from.</p></li><li><p>Four calls to install a VM from our chosen template: <code>VM.clone()</code>, followed
by the getter and setter of the <code>other_config</code> field to specify where to
create the disk images of the template, and then <code>VM.provision()</code>.</p></li><li><p>One call to start the resultant VM: <code>VM.start()</code> (and similarly other single calls to suspend, resume and shutdown accordingly)</p></li><li><p>And then one call to logout <code>Session.logout()</code></p></li></ul><p>The take-home message here is that, although the API as a whole is complex and fully featured, common tasks (such as creating and performing lifecycle operations on VMs) are very straightforward to perform, requiring only a small number of simple API calls. Keep this in mind while you study the next section which may, on first reading, appear a little daunting!</p><h2 id=object-model-overview>Object Model Overview</h2><p>This section gives a high-level overview of the object model of the API. A more detailed description of the parameters and methods of each class outlined here can be found in the XenServer API Reference document.</p><p>We start by giving a brief outline of some of the core classes that make up the API. (Don&rsquo;t worry if these definitions seem somewhat abstract in their initial presentation; the textual description in subsequent sections, and the code-sample walk through in the next Chapter will help make these concepts concrete.)</p><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td>VM</td><td>A VM object represents a particular virtual machine instance on a XenServer Host or Resource Pool. Example methods include <code>start</code>, <code>suspend</code>, <code>pool_migrate</code>; example parameters include <code>power_state</code>, <code>memory_static_max</code>, and <code>name_label</code>. (In the previous section we saw how the VM class is used to represent both templates and regular VMs)</td></tr><tr><td>Host</td><td>A host object represents a physical host in a XenServer pool. Example methods include <code>reboot</code> and <code>shutdown</code>. Example parameters include <code>software_version</code>, <code>hostname</code>, and [IP] <code>address</code>.</td></tr><tr><td>VDI</td><td>A VDI object represents a <em>Virtual Disk Image</em>. Virtual Disk Images can be attached to VMs, in which case a block device appears inside the VM through which the bits encapsulated by the Virtual Disk Image can be read and written. Example methods of the VDI class include &ldquo;resize&rdquo; and &ldquo;clone&rdquo;. Example fields include &ldquo;virtual_size&rdquo; and &ldquo;sharable&rdquo;. (When we called <code>VM.provision</code> on the VM template in our previous example, some VDI objects were automatically created to represent the newly created disks, and attached to the VM object.)</td></tr><tr><td>SR</td><td>An SR (<em>Storage Repository</em>) aggregates a collection of VDIs and encapsulates the properties of physical storage on which the VDIs&rsquo; bits reside. Example parameters include <code>type</code> (which determines the storage-specific driver a XenServer installation uses to read/write the SR&rsquo;s VDIs) and <code>physical_utilisation</code>; example methods include <code>scan</code> (which invokes the storage-specific driver to acquire a list of the VDIs contained with the SR and the properties of these VDIs) and <code>create</code> (which initializes a block of physical storage so it is ready to store VDIs).</td></tr><tr><td>Network</td><td>A network object represents a layer-2 network that exists in the environment in which the XenServer Host instance lives. Since XenServer does not manage networks directly this is a lightweight class that serves merely to model physical and virtual network topology. VM and Host objects that are <em>attached</em> to a particular Network object (by virtue of VIF and PIF instances &ndash; see below) can send network packets to each other.</td></tr></tbody></table><p>At this point, readers who are finding this enumeration of classes rather terse may wish to skip to the code walk-throughs of the next chapter: there are plenty of useful applications that can be written using only a subset of the classes already described! For those who wish to continue this description of classes in the abstract, read on.</p><p>On top of the classes listed above, there are 4 more that act as <em>connectors</em>, specifying relationships between VMs and Hosts, and Storage and Networks. The first 2 of these classes that we will consider, <em>VBD</em> and <em>VIF</em>, determine how VMs are attached to virtual disks and network objects respectively:</p><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td>VBD</td><td>A VBD (<em>Virtual Block Device</em>) object represents an attachment between a VM and a VDI. When a VM is booted its VBD objects are queried to determine which disk images (VDIs) should be attached. Example methods of the VBD class include &ldquo;plug&rdquo; (which <em>hot plugs</em> a disk device into a running VM, making the specified VDI accessible therein) and &ldquo;unplug&rdquo; (which <em>hot unplugs</em> a disk device from a running guest); example fields include &ldquo;device&rdquo; (which determines the device name inside the guest under which the specified VDI will be made accessible).</td></tr><tr><td>VIF</td><td>A VIF (<em>Virtual network InterFace</em>) object represents an attachment between a VM and a Network object. When a VM is booted its VIF objects are queried to determine which network devices should be created. Example methods of the VIF class include &ldquo;plug&rdquo; (which <em>hot plugs</em> a network device into a running VM) and &ldquo;unplug&rdquo; (which <em>hot unplugs</em> a network device from a running guest).</td></tr></tbody></table><p>The second set of &ldquo;connector classes&rdquo; that we will consider determine how Hosts are attached to Networks and Storage.</p><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td>PIF</td><td>A PIF (<em>Physical InterFace</em>) object represents an attachment between a Host and a Network object. If a host is connected to a Network (over a PIF) then packets from the specified host can be transmitted/received by the corresponding host. Example fields of the PIF class include &ldquo;device&rdquo; (which specifies the device name to which the PIF corresponds &ndash; e.g. <em>eth0</em>) and &ldquo;MAC&rdquo; (which specifies the MAC address of the underlying NIC that a PIF represents). Note that PIFs abstract both physical interfaces and VLANs (the latter distinguished by the existence of a positive integer in the &ldquo;VLAN&rdquo; field).</td></tr><tr><td>PBD</td><td>A PBD (<em>Physical Block Device</em>) object represents an attachment between a Host and a SR (Storage Repository) object. Fields include &ldquo;currently-attached&rdquo; (which specifies whether the chunk of storage represented by the specified SR object) is currently available to the host; and &ldquo;device_config&rdquo; (which specifies storage-driver specific parameters that determines how the low-level storage devices are configured on the specified host &ndash; e.g. in the case of an SR rendered on an NFS filer, device_config may specify the host-name of the filer and the path on the filer in which the SR files live.).</td></tr></tbody></table><p><a href=#image-61c3ac0b76a24574cec47cf7c87e413a class=lightbox-link><img src=/new-docs/xen-api/overview/dia_class_overview.svg alt="Graphical overview of API classes for managing VMs, Hosts, Storage and Networking" class="figure-image noborder lightbox noshadow" style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=image-61c3ac0b76a24574cec47cf7c87e413a><img src=/new-docs/xen-api/overview/dia_class_overview.svg alt="Graphical overview of API classes for managing VMs, Hosts, Storage and Networking" class="lightbox-image noborder lightbox noshadow" loading=lazy></a></p><p>The figure above presents a graphical overview of the API classes involved in managing VMs, Hosts, Storage and Networking. From this diagram, the symmetry between storage and network configuration, and also the symmetry between virtual machine and host configuration is plain to see.</p><h2 id=working-with-vifs-and-vbds>Working with VIFs and VBDs</h2><p>In this section we walk through a few more complex scenarios, describing informally how various tasks involving virtual storage and network devices can be accomplished using the API.</p><h3 id=creating-disks-and-attaching-them-to-vms>Creating disks and attaching them to VMs</h3><p>Let&rsquo;s start by considering how to make a new blank disk image and attach it to a running VM. We will assume that we already have ourselves a running VM, and we know its corresponding API object reference (e.g. we may have created this VM using the procedure described in the previous section, and had the server return its reference to us.) We will also assume that we have authenticated with the XenServer installation and have a corresponding <code>session reference</code>. Indeed in the rest of this chapter, for the sake of brevity, we will stop mentioning sessions altogether.</p><h4 id=creating-a-new-blank-disk-image>Creating a new blank disk image</h4><p>The first step is to instantiate the disk image on physical storage. We do this by calling <code>VDI.create()</code>. The <code>VDI.create</code> call takes a number of parameters, including:</p><ul><li><p><code>name_label</code> and <code>name_description</code>: a human-readable name/description for the disk (e.g. for convenient display in the UI etc.). These fields can be left blank if desired.</p></li><li><p><code>SR</code>: the object reference of the Storage Repository representing the physical storage in which the VDI&rsquo;s bits will be placed.</p></li><li><p><code>read_only</code>: setting this field to true indicates that the VDI can <em>only</em> be attached to VMs in a read-only fashion. (Attempting to attach a VDI with its <code>read_only</code> field set to true in a read/write fashion results in error.)</p></li></ul><p>Invoking the <code>VDI.create</code> call causes the XenServer installation to create a blank disk image on physical storage, create an associated VDI object (the datamodel instance that refers to the disk image on physical storage) and return a reference to this newly created VDI object.</p><p>The way in which the disk image is represented on physical storage depends on the type of the SR in which the created VDI resides. For example, if the SR is of type &ldquo;lvm&rdquo; then the new disk image will be rendered as an LVM volume; if the SR is of type &ldquo;nfs&rdquo; then the new disk image will be a sparse VHD file created on an NFS filer. (You can query the SR type through the API using the <code>SR.get_type()</code> call.)</p><blockquote><p><strong>Note</strong></p><p>Some SR types might round up the <code>virtual-size</code> value to make it divisible by a configured block size.</p></blockquote><h4 id=attaching-the-disk-image-to-a-vm>Attaching the disk image to a VM</h4><p>So far we have a running VM (that we assumed the existence of at the start of this example) and a fresh VDI that we just created. Right now, these are both independent objects that exist on the XenServer Host, but there is nothing linking them together. So our next step is to create such a link, associating the VDI with our VM.</p><p>The attachment is formed by creating a new &ldquo;connector&rdquo; object called a VBD (<em>Virtual Block Device</em>). To create our VBD we invoke the <code>VBD.create()</code> call. The <code>VBD.create()</code> call takes a number of parameters including:</p><ul><li><p><code>VM</code> - the object reference of the VM to which the VDI is to be attached</p></li><li><p><code>VDI</code> - the object reference of the VDI that is to be attached</p></li><li><p><code>mode</code> - specifies whether the VDI is to be attached in a read-only or a read-write fashion</p></li><li><p><code>userdevice</code> - specifies the block device inside the guest through which applications running inside the VM will be able to read/write the VDI&rsquo;s bits.</p></li><li><p><code>type</code> - specifies whether the VDI should be presented inside the VM as a regular disk or as a CD. (Note that this particular field has more meaning for Windows VMs than it does for Linux VMs, but we will not explore this level of detail in this chapter.)</p></li></ul><p>Invoking <code>VBD.create</code> makes a VBD object on the XenServer installation and returns its object reference. However, this call in itself does not have any side-effects on the running VM (that is, if you go and look inside the running VM you will see that the block device has not been created). The fact that the VBD object exists but that the block device in the guest is not active, is reflected by the fact that the VBD object&rsquo;s <code>currently_attached</code> field is set to false.</p><p><a href=#image-f07183fc8ba3952390e69ed4292246aa class=lightbox-link><img src=/new-docs/xen-api/overview/dia_vm_sr.svg alt="A VM object with 2 associated VDIs" class="figure-image noborder lightbox noshadow" style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=image-f07183fc8ba3952390e69ed4292246aa><img src=/new-docs/xen-api/overview/dia_vm_sr.svg alt="A VM object with 2 associated VDIs" class="lightbox-image noborder lightbox noshadow" loading=lazy></a></p><p>For expository purposes, the figure above presents a graphical example that shows the relationship between VMs, VBDs, VDIs and SRs. In this instance a VM object has 2 attached VDIs: there are 2 VBD objects that form the connections between the VM object and its VDIs; and the VDIs reside within the same SR.</p><h4 id=hotplugging-the-vbd>Hotplugging the VBD</h4><p>If we rebooted the VM at this stage then, after rebooting, the block device corresponding to the VBD would appear: on boot, XenServer queries all VBDs of a VM and actively attaches each of the corresponding VDIs.</p><p>Rebooting the VM is all very well, but recall that we wanted to attach a newly created blank disk to a <em>running</em> VM. This can be achieved by invoking the <code>plug</code> method on the newly created VBD object. When the <code>plug</code> call returns successfully, the block device to which the VBD relates will have appeared inside the running VM &ndash; i.e. from the perspective of the running VM, the guest operating system is led to believe that a new disk device has just been <em>hot plugged</em>. Mirroring this fact in the managed world of the API, the <code>currently_attached</code> field of the VBD is set to true.</p><p>Unsurprisingly, the VBD <code>plug</code> method has a dual called &ldquo;<code>unplug</code>&rdquo;. Invoking the <code>unplug</code> method on a VBD object causes the associated block device to be <em>hot unplugged</em> from a running VM, setting the <code>currently_attached</code> field of the VBD object to false accordingly.</p><h3 id=creating-and-attaching-network-devices-to-vms>Creating and attaching Network Devices to VMs</h3><p>The API calls involved in configuring virtual network interfaces in VMs are similar in many respects to the calls involved in configuring virtual disk devices. For this reason we will not run through a full example of how one can create network interfaces using the API object-model; instead we will use this section just to outline briefly the symmetry between virtual <em>networking device</em> and virtual <em>storage device</em> configuration.</p><p>The networking analogue of the VBD class is the VIF class. Just as a VBD is the API representation of a block device inside a VM, a VIF (<em>Virtual network InterFace</em>) is the API representation of a network device inside a VM. Whereas VBDs associate VM objects with VDI objects, VIFs associate VM objects with Network objects. Just like VBDs, VIFs have a <code>currently_attached</code> field that determines whether or not the network device (inside the guest) associated with the VIF is currently active or not. And as we saw with VBDs, at VM boot-time the VIFs of the VM are queried and a corresponding network device for each created inside the booting VM. Similarly, VIFs also have <code>plug</code> and <code>unplug</code> methods for hot plugging/unplugging network devices in/out of running VMs.</p><h3 id=host-configuration-for-networking-and-storage>Host configuration for networking and storage</h3><p>We have seen that the VBD and VIF classes are used to manage configuration of block devices and network devices (respectively) inside VMs. To manage host configuration of storage and networking there are two analogous classes: PBD (<em>Physical Block Device</em>) and PIF (<em>Physical [network] InterFace</em>).</p><h4 id=host-storage-configuration-pbds>Host storage configuration: PBDs</h4><p>Let us start by considering the PBD class. A <code>PBD_create()</code> call takes a number of parameters including:</p><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>host</td><td>physical machine on which the PBD is available</td></tr><tr><td>SR</td><td>the Storage Repository that the PBD connects to</td></tr><tr><td>device_config</td><td>a string-to-string map that is provided to the host&rsquo;s SR-backend-driver, containing the low-level parameters required to configure the physical storage device(s) on which the SR is to be realized. The specific contents of the <code>device_config</code> field depend on the type of the SR to which the PBD is connected. (Executing <code>xe sm-list</code> will show a list of possible SR types; the <em>configuration</em> field in this enumeration specifies the <code>device_config</code> parameters that each SR type expects.)</td></tr></tbody></table><p>For example, imagine we have an SR object <em>s</em> of type &ldquo;nfs&rdquo; (representing a directory on an NFS filer within which VDIs are stored as VHD files); and let&rsquo;s say that we want a host, <em>h</em>, to be able to access <em>s</em>. In this case we invoke <code>PBD.create()</code> specifying host <em>h</em>, SR <em>s</em>, and a value for the <em>device_config</em> parameter that is the following map:</p><p><code>("server", "my_nfs_server.example.com"), ("serverpath", "/scratch/mysrs/sr1")</code></p><p>This tells the XenServer Host that SR <em>s</em> is accessible on host <em>h</em>, and further that to access SR <em>s</em>, the host needs to mount the directory <code>/scratch/mysrs/sr1</code> on the NFS server named <code>my_nfs_server.example.com</code>.</p><p>Like VBD objects, PBD objects also have a field called <code>currently_attached</code>. Storage repositories can be attached and detached from a given host by invoking <code>PBD.plug</code> and <code>PBD.unplug</code> methods respectively.</p><h4 id=host-networking-configuration-pifs>Host networking configuration: PIFs</h4><p>Host network configuration is specified by virtue of PIF objects. If a PIF object connects a network object, <em>n</em>, to a host object <em>h</em>, then the network corresponding to <em>n</em> is bridged onto a physical interface (or a physical interface plus a VLAN tag) specified by the fields of the PIF object.</p><p>For example, imagine a PIF object exists connecting host <em>h</em> to a network <em>n</em>, and that <code>device</code> field of the PIF object is set to <code>eth0</code>. This means that all packets on network <em>n</em> are bridged to the NIC in the host corresponding to host network device <code>eth0</code>.</p><h2 id=xml-rpc-notes>XML-RPC notes</h2><h3 id=datetimes>Datetimes</h3><p>The API deviates from the XML-RPC specification in handling of datetimes. The API appends a &ldquo;Z&rdquo; to the end of datetime strings, which is meant to indicate that the time is expressed in UTC.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=api-evolution>API evolution</h1><p>All APIs evolve as bugs are fixed, new features added and features are removed</p><ul><li>the XenAPI is no exception. This document lists policies describing how the
XenAPI evolves over time.</li></ul><p>The goals of XenAPI evolution are:</p><ul><li>to allow bugs to be fixed efficiently;</li><li>to allow new, innovative features to be added easily;</li><li>to keep old, unmodified clients working as much as possible; and</li><li>where backwards-incompatible changes are to be made, publish this
information early to enable affected parties to give timely feedback.</li></ul><h2 id=background>Background</h2><p>In this document, the term <em>XenAPI</em> refers to the XMLRPC-derived wire protocol
used by xapi. The XenAPI has <em>objects</em> which each have <em>fields</em> and
<em>messages</em>. The XenAPI is described in detail elsewhere.</p><h2 id=xenapi-lifecycle>XenAPI Lifecycle</h2><div class="mermaid align-center">graph LR
Prototype -->|1| Published -->|4| Deprecated -->|5| Removed
Published -->|2,3| Published</div><p>Each element of the XenAPI (objects, messages and fields) follows the lifecycle
diagram above. When an element is newly created and being still in development,
it is in the <em>Prototype</em> state. Elements in this state may be stubs: the
interface is there and can be used by clients for prototyping their new
features, but the actual implementation is not yet ready.</p><p>When the element subsequently becomes ready for use (the stub is replaced by a
real implementation), it transitions to the <em>Published</em> state. This is the only
state in which the object, message or field should be used. From this point
onwards, the element needs to have clearly defined semantics that are available
for reference in the XenAPI documentation.</p><p>If the XenAPI element becomes <em>Deprecated</em>, it will still function as it did
before, but its use is discouraged. The final stage of the lifecycle is the
<em>Removed</em> state, in which the element is not available anymore.</p><p>The numbered state changes in the diagram have the following meaning:</p><ol><li>Publish: declare that the XenAPI element is ready for people to use.</li><li>Extend: a <em>backwards-compatible</em> extension of the XenAPI, for example an
additional parameter in a message with an appropriate default value. If the
API is used as before, it still has the same effect.</li><li>Change: a <em>backwards-incompatible</em> change. That is, the message now behaves
differently, or the field has different semantics. Such changes are
discouraged and should only be considered in special cases (always consider
whether deprecation is a better solution). The use of a message can for
example be restricted for security or efficiency reasons, or the behaviour
can be changed simply to fix a bug.</li><li>Deprecate: declare that the use of this XenAPI element should be avoided from
now on. Reasons for doing this include: the element is redundant (it
duplicates functionality elsewhere), it is inconsistent with other parts of
the XenAPI, it is insecure or inefficient (for examples of deprecation
policies of other projects, see
<a href=http://developer.symbian.org/wiki/index.php/Public_API_Change_Control_Process target=_blank>symbian</a>
<a href=http://wiki.eclipse.org/Eclipse/API_Central/Deprecation_Policy target=_blank>eclipse</a>
<a href=http://oval.mitre.org/language/about/deprecation.html target=_blank>oval</a>.</li><li>Remove: the element is taken out of the public API and can no longer be used.</li></ol><p>Each lifecycle transition must be accompanied by an explanation describing the
change and the reason for the change. This message should be enough to
understand the semantics of the XenAPI element after the change, and in the case
of backwards-incompatible changes or deprecation, it should give directions
about how to modify a client to deal with the change (for example, how to avoid
using the deprecated field or message).</p><h2 id=releases>Releases</h2><p>Every release must be accompanied by <em>release notes</em> listing all objects, fields
and messages that are newly prototyped, published, extended, changed, deprecated
or removed in the release. Each item should have an explanation as implied
above, documenting the new or changed XenAPI element. The release notes for
every release shall be prominently displayed in the XenAPI HTML documentation.</p><h2 id=documentation>Documentation</h2><p>The XenAPI documentation will contain its complete lifecycle history for each
XenAPI element. Only the elements described in the documentation are
&ldquo;official&rdquo; and supported.</p><p>Each object, message and field in <code>datamodel.ml</code> will have lifecycle
metadata attached to it, which is a list of transitions (transition type *
release * explanation string) as described above. Release notes are automatically generated from this data.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xenapi-reference>XenAPI Reference</h1><div><h2 class=title>XenAPI Classes</h2><p>Click on a class to view the associated fields and messages.</p><img src=/new-docs/xen-api/classes/classes.png alt="Xen-api class diagram" usemap=#graph border=0>
<map id=graph name=graph><area shape=poly href=/new-docs/xen-api/classes/task title="an asynchronous server-side task" alt coords="408,233 406,227 402,222 395,217 387,214 378,213 369,214 360,217 354,222 349,227 348,233 349,240 354,245 360,250 369,252 378,253 387,252 395,250 402,245 406,240"><area shape=poly href=/new-docs/xen-api/classes/event title="allows event registration and reading" alt coords="408,296 406,289 402,284 395,279 387,277 378,276 369,277 360,279 354,284 349,289 348,296 349,302 354,307 360,312 369,315 378,316 387,315 395,312 402,307 406,302"><area shape=poly href=/new-docs/xen-api/classes/pool title="a Resource Pool" alt coords="470,78 469,72 464,66 458,62 449,59 440,58 431,59 422,62 416,66 411,72 410,78 411,84 416,90 422,94 431,97 440,98 449,97 458,94 464,90 469,84"><area shape=rect href=/new-docs/xen-api/classes/session title="an authenticated session" alt coords=92,211,152,251><area shape=rect href=/new-docs/xen-api/classes/user title="a user" alt coords=6,201,66,241><area shape=rect href=/new-docs/xen-api/classes/host title="a physical host" alt coords=187,223,247,263><area shape=rect href=/new-docs/xen-api/classes/vm title="a Virtual Machine" alt coords=508,279,568,319><area shape=poly href=/new-docs/xen-api/classes/vm_metrics title="dynamic VM configuration information" alt coords="673,301 671,295 665,289 656,285 644,282 631,281 618,282 607,285 597,289 591,295 589,301 591,307 597,313 607,317 618,320 631,321 644,320 656,317 665,313 671,307"><area shape=poly href=/new-docs/xen-api/classes/vm_guest_metrics title="dynamic information from inside the guest" alt coords="670,360 667,354 658,348 645,344 628,341 610,340 592,341 575,344 562,348 553,354 550,360 553,366 562,372 575,376 592,379 610,380 628,379 645,376 658,372 667,366"><area shape=poly href=/new-docs/xen-api/classes/crashdump title="VM crashdump" alt coords="650,246 648,239 642,234 633,229 622,227 609,226 596,227 585,229 576,234 570,239 568,246 570,252 576,257 585,262 596,265 609,266 622,265 633,262 642,257 648,252"><area shape=poly href=/new-docs/xen-api/classes/console title="location information for a guest's console" alt coords="590,387 589,380 584,375 577,370 569,368 559,367 549,368 540,370 533,375 529,380 527,387 529,393 533,398 540,403 549,406 559,407 569,406 577,403 584,398 589,393"><area shape=rect href=/new-docs/xen-api/classes/pbd title="the connection between an SR and a host" alt coords=244,147,304,187><area shape=poly href=/new-docs/xen-api/classes/host_metrics title="dynamic host information" alt coords="202,307 199,300 193,295 183,290 170,288 156,287 141,288 128,290 118,295 112,300 109,307 112,313 118,318 128,323 141,326 156,327 170,326 183,323 193,318 199,313"><area shape=poly href=/new-docs/xen-api/classes/host_cpu title="a physical CPU on a host" alt coords="206,164 204,158 199,153 191,148 182,145 171,144 160,145 151,148 143,153 138,158 136,164 138,171 143,176 151,181 160,183 171,184 182,183 191,181 199,176 204,171"><area shape=rect href=/new-docs/xen-api/classes/network title="an ethernet network" alt coords=331,331,391,371><area shape=rect href=/new-docs/xen-api/classes/vif title="a network interface for a Virtual Machine" alt coords=423,334,483,374><area shape=poly href=/new-docs/xen-api/classes/vif_metrics title="IO stats and configuration information for a virtual interface" alt coords="498,451 496,445 490,439 481,435 470,432 457,431 444,432 432,435 423,439 417,445 415,451 417,457 423,463 432,467 444,470 457,471 470,470 481,467 490,463 496,457"><area shape=rect href=/new-docs/xen-api/classes/pif title="a network interface for a physical host" alt coords=241,306,301,346><area shape=poly href=/new-docs/xen-api/classes/pif_metrics title="IO stats and configuration information for a physical interface" alt coords="274,412 272,406 266,400 257,396 245,393 232,392 219,393 208,396 198,400 193,406 191,412 193,418 198,424 208,428 219,431 232,432 245,431 257,428 266,424 272,418"><area shape=rect href=/new-docs/xen-api/classes/sr title="Storage Repository, a container for virtual disk images (VDIs)" alt coords=323,97,383,137><area shape=rect href=/new-docs/xen-api/classes/vdi title="a virtual disk image" alt coords=412,124,472,164><area shape=poly href=/new-docs/xen-api/classes/sm title="storage manager plugin module" alt coords="377,26 375,19 371,14 364,9 356,7 347,6 337,7 329,9 322,14 318,19 317,26 318,32 322,37 329,42 337,45 347,46 356,45 364,42 371,37 375,32"><area shape=rect href=/new-docs/xen-api/classes/vbd title="a virtual block device" alt coords=486,181,546,221><area shape=poly href=/new-docs/xen-api/classes/vbd_metrics title="IO stats and configuration information for a virtual block device" alt coords="623,128 620,122 614,116 604,112 592,109 578,108 564,109 551,112 541,116 535,122 533,128 535,134 541,140 551,144 564,147 578,148 592,147 604,144 614,140 620,134"></map><h2>Classes, Fields and Messages</h2><p>Classes have both <i>fields</i> and <i>messages.</i> Messages are either <i>implicit</i> or <i>explicit</i> where an implicit message is one of:</p><ul><li>a constructor (usually called "create");</li><li>a destructor (usually called "destroy");</li><li>"get_by_name_label";</li><li>"get_by_uuid";</li><li>"get_record";</li><li>"get_all"; and</li><li>"get_all_records".</li></ul><p>Explicit messages include all the rest, more class-specific messages (e.g. "VM.start", "VM.clone")</p><p>Every field has at least one <i>accessor</i> depending both on its type and whether it is read-only or read-write. Accessors for a field named "X" would be a proper subset of:</p><ul><li>set_X: change the value of field X (only if it is read-write);</li><li>get_X: retrieve the value of field X;</li><li>add_X: add a key/value pair (for fields of type set);</li><li>remove_X: remove a key (for fields of type set);</li><li>add_to_X: add a key/value pair (for fields of type map); and</li><li>remove_from_X: remove a key (for fields of type map).</li></ul></div><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of XenAPI Reference</h1><article class=default><header class=headline></header><h1 id=auth>auth</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=blob>blob</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=bond>Bond</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=certificate>Certificate</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=cluster>Cluster</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=cluster_host>Cluster_host</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=console>console</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=crashdump>crashdump</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=data_source>data_source</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=dr_task>DR_task</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=event>event</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=feature>Feature</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=gpu_group>GPU_group</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=host>host</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=host_cpu>host_cpu</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=host_crashdump>host_crashdump</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=host_metrics>host_metrics</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=host_patch>host_patch</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=lvhd>LVHD</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=message>message</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=network>network</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=network_sriov>network_sriov</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=observer>Observer</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pbd>PBD</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pci>PCI</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pgpu>PGPU</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pif>PIF</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pif_metrics>PIF_metrics</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pool>pool</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pool_patch>pool_patch</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pool_update>pool_update</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=probe_result>probe_result</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pusb>PUSB</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pvs_cache_storage>PVS_cache_storage</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pvs_proxy>PVS_proxy</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pvs_server>PVS_server</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pvs_site>PVS_site</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=repository>Repository</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=role>role</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sdn_controller>SDN_controller</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=secret>secret</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=session>session</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sm>SM</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sr>SR</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sr_stat>sr_stat</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=subject>subject</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=task>task</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=tunnel>tunnel</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=usb_group>USB_group</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=user>user</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vbd>VBD</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vbd_metrics>VBD_metrics</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vdi>VDI</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vdi_nbd_server_info>vdi_nbd_server_info</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vgpu>VGPU</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vgpu_type>VGPU_type</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vif>VIF</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vif_metrics>VIF_metrics</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vlan>VLAN</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vm>VM</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vm_appliance>VM_appliance</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vm_guest_metrics>VM_guest_metrics</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vm_metrics>VM_metrics</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vmpp>VMPP</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vmss>VMSS</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vtpm>VTPM</h1><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=vusb>VUSB</h1><footer class=footline></footer></article></section></section></div></main></div><script src=/new-docs/js/clipboard.min.js?1719501490 defer></script><script src=/new-docs/js/perfect-scrollbar.min.js?1719501490 defer></script><script src=/new-docs/js/d3/d3-color.min.js?1719501490 defer></script><script src=/new-docs/js/d3/d3-dispatch.min.js?1719501490 defer></script><script src=/new-docs/js/d3/d3-drag.min.js?1719501490 defer></script><script src=/new-docs/js/d3/d3-ease.min.js?1719501490 defer></script><script src=/new-docs/js/d3/d3-interpolate.min.js?1719501490 defer></script><script src=/new-docs/js/d3/d3-selection.min.js?1719501490 defer></script><script src=/new-docs/js/d3/d3-timer.min.js?1719501490 defer></script><script src=/new-docs/js/d3/d3-transition.min.js?1719501490 defer></script><script src=/new-docs/js/d3/d3-zoom.min.js?1719501490 defer></script><script src=/new-docs/js/js-yaml.min.js?1719501490 defer></script><script src=/new-docs/js/mermaid.min.js?1719501490 defer></script><script>window.themeUseMermaid=JSON.parse("{}")</script><script src=/new-docs/js/theme.js?1719501490 defer></script></body></html>