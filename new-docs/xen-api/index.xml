<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>XenAPI on XAPI Toolstack Developer Documentation</title><link>https://xapi-project.github.io/new-docs/xen-api/index.html</link><description>Recent content in XenAPI on XAPI Toolstack Developer Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://xapi-project.github.io/new-docs/xen-api/index.xml" rel="self" type="application/rss+xml"/><item><title>XenAPI Basics</title><link>https://xapi-project.github.io/new-docs/xen-api/basics/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xapi-project.github.io/new-docs/xen-api/basics/index.html</guid><description>This document contains a description of the Xen Management API â€“ an interface for remotely configuring and controlling virtualised guests running on a Xen-enabled host.
The XenAPI is presented here as a set of Remote Procedure Calls, with a wire format based upon XML-RPC. No specific language bindings are prescribed, although examples will be given in the python programming language.
Although we adopt some terminology from object-oriented programming, future client language bindings may or may not be object oriented.</description></item><item><title>Wire Protocol</title><link>https://xapi-project.github.io/new-docs/xen-api/wire-protocol/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xapi-project.github.io/new-docs/xen-api/wire-protocol/index.html</guid><description>API calls are sent over a network to a Xen-enabled host using the XML-RPC protocol. On this page, we describe how the higher-level types used in our API Reference are mapped to primitive XML-RPC types.
We specify the signatures of API functions in the following style:
(VM ref set) VM.get_all () This specifies that the function with name VM.get_all takes no parameters and returns a set of VM refs. These types are mapped onto XML-RPC types in a straight-forward manner:</description></item><item><title>Overview of the XenAPI</title><link>https://xapi-project.github.io/new-docs/xen-api/overview/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xapi-project.github.io/new-docs/xen-api/overview/index.html</guid><description>This chapter introduces the XenAPI and its associated object model. The API has the following key features:
Management of all aspects of the XenServer Host. The API allows you to manage VMs, storage, networking, host configuration and pools. Performance and status metrics can also be queried from the API.
Persistent Object Model. The results of all side-effecting operations (e.g. object creation, deletion and parameter modifications) are persisted in a server-side database that is managed by the XenServer installation.</description></item><item><title>API evolution</title><link>https://xapi-project.github.io/new-docs/xen-api/evolution/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xapi-project.github.io/new-docs/xen-api/evolution/index.html</guid><description>All APIs evolve as bugs are fixed, new features added and features are removed
the XenAPI is no exception. This document lists policies describing how the XenAPI evolves over time. The goals of XenAPI evolution are:
to allow bugs to be fixed efficiently; to allow new, innovative features to be added easily; to keep old, unmodified clients working as much as possible; and where backwards-incompatible changes are to be made, publish this information early to enable affected parties to give timely feedback.</description></item><item><title>XenAPI Reference</title><link>https://xapi-project.github.io/new-docs/xen-api/classes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xapi-project.github.io/new-docs/xen-api/classes/index.html</guid><description>XenAPI Classes Click on a class to view the associated fields and messages.
Classes, Fields and Messages Classes have both fields and messages. Messages are either implicit or explicit where an implicit message is one of:
a constructor (usually called &amp;quot;create&amp;quot;); a destructor (usually called &amp;quot;destroy&amp;quot;); &amp;quot;get_by_name_label&amp;quot;; &amp;quot;get_by_uuid&amp;quot;; &amp;quot;get_record&amp;quot;; &amp;quot;get_all&amp;quot;; and &amp;quot;get_all_records&amp;quot;. Explicit messages include all the rest, more class-specific messages (e.g. &amp;quot;VM.start&amp;quot;, &amp;quot;VM.clone&amp;quot;)
Every field has at least one accessor depending both on its type and whether it is read-only or read-write.</description></item></channel></rss>