<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.127.0"><meta name=generator content="Relearn 7.3.2"><meta name=description content="Xapi is the xapi-project host and cluster manager.
Xapi is responsible for:
providing a stable interface (the XenAPI) allowing one client to manage multiple hosts hosting the â€œxeâ€ CLI authenticating users and applying role-based access control locking resources (in particular disks) allowing storage to be managed through plugins planning and coping with host failures (â€œHigh Availabilityâ€) storing VM and host configuration generating alerts managing software patching Principles The XenAPI interface must remain backwards compatible, allowing older clients to continue working Xapi delegates all Xenstore/libxc/libxl access to Xenopsd, so Xapi could be run in an unprivileged helper domain Xapi delegates the low-level storage manipulation to SM plugins."><meta name=author content><meta name=twitter:card content="summary"><meta name=twitter:title content="Xapi :: XAPI Toolstack Developer Documentation"><meta name=twitter:description content="Xapi is the xapi-project host and cluster manager.
Xapi is responsible for:
providing a stable interface (the XenAPI) allowing one client to manage multiple hosts hosting the â€œxeâ€ CLI authenticating users and applying role-based access control locking resources (in particular disks) allowing storage to be managed through plugins planning and coping with host failures (â€œHigh Availabilityâ€) storing VM and host configuration generating alerts managing software patching Principles The XenAPI interface must remain backwards compatible, allowing older clients to continue working Xapi delegates all Xenstore/libxc/libxl access to Xenopsd, so Xapi could be run in an unprivileged helper domain Xapi delegates the low-level storage manipulation to SM plugins."><meta property="og:url" content="https://xapi-project.github.io/new-docs/xapi/index.html"><meta property="og:site_name" content="XAPI Toolstack Developer Documentation"><meta property="og:title" content="Xapi :: XAPI Toolstack Developer Documentation"><meta property="og:description" content="Xapi is the xapi-project host and cluster manager.
Xapi is responsible for:
providing a stable interface (the XenAPI) allowing one client to manage multiple hosts hosting the â€œxeâ€ CLI authenticating users and applying role-based access control locking resources (in particular disks) allowing storage to be managed through plugins planning and coping with host failures (â€œHigh Availabilityâ€) storing VM and host configuration generating alerts managing software patching Principles The XenAPI interface must remain backwards compatible, allowing older clients to continue working Xapi delegates all Xenstore/libxc/libxl access to Xenopsd, so Xapi could be run in an unprivileged helper domain Xapi delegates the low-level storage manipulation to SM plugins."><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta itemprop=name content="Xapi :: XAPI Toolstack Developer Documentation"><meta itemprop=description content="Xapi is the xapi-project host and cluster manager.
Xapi is responsible for:
providing a stable interface (the XenAPI) allowing one client to manage multiple hosts hosting the â€œxeâ€ CLI authenticating users and applying role-based access control locking resources (in particular disks) allowing storage to be managed through plugins planning and coping with host failures (â€œHigh Availabilityâ€) storing VM and host configuration generating alerts managing software patching Principles The XenAPI interface must remain backwards compatible, allowing older clients to continue working Xapi delegates all Xenstore/libxc/libxl access to Xenopsd, so Xapi could be run in an unprivileged helper domain Xapi delegates the low-level storage manipulation to SM plugins."><meta itemprop=wordCount content="827"><title>Xapi :: XAPI Toolstack Developer Documentation</title>
<link href=https://xapi-project.github.io/new-docs/xapi/index.html rel=canonical type=text/html title="Xapi :: XAPI Toolstack Developer Documentation"><link href=/new-docs/xapi/index.xml rel=alternate type=application/rss+xml title="Xapi :: XAPI Toolstack Developer Documentation"><link href=/new-docs/images/favicon.png?1762269348 rel=icon type=image/png><link href=/new-docs/css/fontawesome-all.min.css?1762269348 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/fontawesome-all.min.css?1762269348 rel=stylesheet></noscript><link href=/new-docs/css/auto-complete.css?1762269348 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/auto-complete.css?1762269348 rel=stylesheet></noscript><link href=/new-docs/css/perfect-scrollbar.min.css?1762269348 rel=stylesheet><link href=/new-docs/css/theme.min.css?1762269348 rel=stylesheet><link href=/new-docs/css/format-print.min.css?1762269348 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://xapi-project.github.io/new-docs",window.relearn.min=`.min`,window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.themevariants=["auto","zen-light","zen-dark","red","blue","green","learn","neon","relearn-light","relearn-bright","relearn-dark"],window.relearn.customvariantname="my-custom-variant",window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.localStorage.setItem(window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}}))},window.relearn.markVariant=function(){var t=window.localStorage.getItem(window.relearn.absBaseUri+"/variant"),e=document.querySelector("#R-select-variant");e&&(e.value=t)},window.relearn.initVariant=function(){var e=window.localStorage.getItem(window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.localStorage.setItem(window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant(),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link rel=stylesheet href=https://xapi-project.github.io/new-docs/css/misc.css></head><body class="mobile-support print" data-url=/new-docs/xapi/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#principles>Principles</a></li><li><a href=#overview>Overview</a></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/new-docs/index.html><span itemprop=name>XAPI Toolstack Developer Guide</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Xapi</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/xapi-project/xen-api/edit/master/doc/content/xapi/_index.md target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/new-docs/xapi/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/new-docs/toolstack/features/XSM/index.html title="Xapi Storage Migration (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/new-docs/xapi/guides/index.html title="Guides (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable xapi" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=xapi>Xapi</h1><p>Xapi is the <a href=http://github.com/xapi-project rel=external target=_blank>xapi-project</a> host and cluster manager.</p><p>Xapi is responsible for:</p><ul><li>providing a stable interface (the XenAPI)</li><li>allowing one client to manage multiple hosts</li><li>hosting the &ldquo;xe&rdquo; CLI</li><li>authenticating users and applying role-based access control</li><li>locking resources (in particular disks)</li><li>allowing storage to be managed through plugins</li><li>planning and coping with host failures (&ldquo;High Availability&rdquo;)</li><li>storing VM and host configuration</li><li>generating alerts</li><li>managing software patching</li></ul><h2 id=principles>Principles</h2><ol><li>The XenAPI interface must remain backwards compatible, allowing older
clients to continue working</li><li>Xapi delegates all Xenstore/libxc/libxl access to Xenopsd, so Xapi could
be run in an unprivileged helper domain</li><li>Xapi delegates the low-level storage manipulation to SM plugins.</li><li>Xapi delegates setting up host networking to xcp-networkd.</li><li>Xapi delegates monitoring performance counters to xcp-rrdd.</li></ol><h2 id=overview>Overview</h2><p>The following diagram shows the internals of Xapi:</p><p><img alt="Internals of xapi" class="noborder lazy nolightbox shadow figure-image" loading=lazy src=/new-docs/xapi/xapi.png style=height:auto;width:auto></p><p>The top of the diagram shows the XenAPI clients: XenCenter, XenOrchestra,
OpenStack and CloudStack using XenAPI and HTTP GET/PUT over ports 80 and 443 to
talk to xapi. These XenAPI (JSON-RPC or XML-RPC over HTTP POST) and HTTP
GET/PUT are always authenticated using either PAM (by default using the local
passwd and group files) or through Active Directory.</p><p>The APIs are classified into categories:</p><ul><li>coordinator-only: these are the majority of current APIs. The coordinator
should be called and relied upon to forward the call to the right place with
the right locks held.</li><li>normally-local: these are performance special cases
such as disk import/export and console connection which are sent directly to
hosts which have the most efficient access to the data.</li><li>emergency: these deal with scenarios where the coordinator is offline</li></ul><p>If the incoming API call should be resent to the coordinator than a XenAPI
<code>HOST_IS_SLAVE</code> error message containing the coordinator&rsquo;s IP is sent to the
client.</p><p>Once past the initial checks, API calls enter the &ldquo;message forwarding&rdquo; layer which</p><ul><li>locks resources (via the <code>current_operations</code> mechanism)</li><li>decides which host should execute the request.</li></ul><p>If the request should run locally then a direct function call is used;
otherwise the message forwarding code makes a synchronous API call to a
specific other host. Note: Xapi currently employs a &ldquo;thread per request&rdquo; model
which causes one full POSIX thread to be created for every request. Even when a
request is forwarded the full thread persists, blocking for the result to
become available.</p><p>If the XenAPI call is a VM lifecycle operation then it is converted into a
Xenopsd API call and forwarded over a Unix domain socket. Xapi and Xenopsd have
similar notions of cancellable asynchronous &ldquo;tasks&rdquo;, so the current Xapi task
(all operations run in the context of a task) is bound to the Xenopsd task, so
cancellation is passed through and progress updates are received.</p><p>If the XenAPI call is a storage operation then the &ldquo;storage access&rdquo; layer</p><ul><li>verifies that the storage objects are in the correct state (SR
attached/detached; VDI attached/activated read-only/read-write)</li><li>invokes the relevant operation in the Storage Manager API (SMAPI) v2
interface;</li><li>depending on the type of SR:<ul><li>uses the SMAPIv2 to SMAPIv1 converter to generate the necessary command-line
to talk to the SMAPIv1 plugin (EXT, NFS, LVM etc) and to execute it</li><li>uses the SMAPIv2 to SMAPIv3 converter daemon xapi-storage-script to
exectute the necessary SMAPIv3 command (GFS2)</li></ul></li><li>persists the state of the storage objects (including the result of a
<code>VDI.attach</code> call) to persistent storage</li></ul><p>Internally the SMAPIv1 plugins use privileged access to the Xapi database to
directly set fields (e.g. VDI.virtual_size) that would be considered read/only
to other clients. The SMAPIv1 plugins also rely on Xapi for</p><ul><li>knowledge of all hosts which may access the storage</li><li>locking of disks within the resource pool</li><li>safely executing code on other hosts via the &ldquo;Xapi plugin&rdquo; mechanism</li></ul><p>The Xapi database contains Host and VM metadata and is shared pool-wide. The
coordinator keeps a copy in memory, and all other nodes remote queries to the
coordinator. The database associates each object with a generation count which
is used to implement the XenAPI <code>event.next</code> and <code>event.from</code> APIs. The
database is routinely asynchronously flushed to disk in XML format. If the
&ldquo;redo-log&rdquo; is enabled then all database writes are made synchronously as deltas
to a shared block device. Without the redo-log, recent updates may be lost if
Xapi is killed before a flush.</p><p>High-Availability refers to planning for host failure, monitoring host liveness
and then following-through on the plans. Xapi defers to an external host
liveness monitor called <code>xhad</code>. When <code>xhad</code> confirms that a host has failed &ndash;
and has been isolated from the storage &ndash; then Xapi will restart any VMs which
have failed and which have been marked as &ldquo;protected&rdquo; by HA. Xapi can also
impose admission control to prevent the pool becoming too overloaded to cope
with <code>n</code> arbitrary host failures.</p><p>The <code>xe</code> CLI is implemented in terms of the XenAPI, but for efficiency the
implementation is linked directly into Xapi. The <code>xe</code> program remotes its
command-line to Xapi, and Xapi sends back a series of simple commands (prompt
for input; print line; fetch file; exit etc).</p><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Xapi</h1><article class=default><header class=headline></header><h1 id=guides>Guides</h1><p>Helpful guides for xapi developers.</p><ul class="children children-li children-sort-weight"><li><a href=/new-docs/xapi/guides/howtos/index.html>How to add....</a><ul><li><a href=/new-docs/xapi/guides/howtos/add-class/index.html>Adding a Class to the API</a><ul></ul></li><li><a href=/new-docs/xapi/guides/howtos/add-field/index.html>Adding a field to the API</a><ul></ul></li><li><a href=/new-docs/xapi/guides/howtos/add-function/index.html>Adding a function to the API</a><ul></ul></li><li><a href=/new-docs/xapi/guides/howtos/add-api-extension/index.html>Adding a XenAPI extension</a><ul></ul></li></ul></li></ul><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Guides</h1><article class=default><header class=headline></header><h1 id=how-to-add>How to add....</h1><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of How to add....</h1><article class=default><header class=headline></header><h1 id=adding-a-class-to-the-api>Adding a Class to the API</h1><p>This document describes how to add a new class to the data model that
defines the Xen Server API. It complements two other documents that
describe how to extend an existing class:</p><ul><li><a href=/new-docs/xapi/guides/howtos/add-field/index.html>Adding a field</a></li><li><a href=/new-docs/xapi/guides/howtos/add-function/index.html>Adding a function</a></li></ul><p>As a running example, we will use the addition of a class that is part
of the design for the PVS Direct feature. PVS Direct introduces
proxies that serve VMs with disk images. This class was added via commit
<a href=https://github.com/xenserver/xen-api/commit/78fe558dad19458a89519fe196069317d57eac58 rel=external target=_blank>CP-16939</a> to Xen API.</p><h2 id=example-pvs_server>Example: PVS_server</h2><p>In the world of Xen Server, each important concept like a virtual
machine, interface, or users is represented by a class in the data model.
A class defines methods and instance variables. At runtime, all class
instances are held in an in-memory database. For example, part of [PVS
Direct] is a class <code>PVS_server</code>, representing a resource that provides
block-level data for virtual machines. The design document defines it to
have the following important properties:</p><h3 id=fields>Fields</h3><ul><li><p><code>(string set) addresses</code> (RO/constructor) IPv4 addresses of the
server.</p></li><li><p><code>(int) first_port</code> (RO/constructor) First UDP port accepted by the
server.</p></li><li><p><code>(int) last_port</code> (RO/constructor) Last UDP port accepted by the
server.</p></li><li><p><code>(PVS_farm ref) farm</code> (RO/constructor) Link to the farm that this
server is included in. A PVS_server object must always have a valid
farm reference; the PVS_server will be automatically GCâ€™ed by xapi
if the associated PVS_farm object is removed.</p></li><li><p><code>(string) uuid (R0/runtime)</code> Unique identifier/object reference.
Allocated by the server.</p></li></ul><h3 id=methods-or-functions>Methods (or Functions)</h3><ul><li><p><code>(PVS_server ref) introduce (string set addresses, int first_port, int last_port, PVS_farm ref farm)</code> Introduce a new PVS server into
the farm. Allowed at any time, even when proxies are in use. The
proxies will be updated automatically.</p></li><li><p><code>(void) forget (PVS_server ref self)</code> Remove a PVS server from the
farm. Allowed at any time, even when proxies are in use. The
proxies will be updated automatically.</p></li></ul><h3 id=implementation-overview>Implementation Overview</h3><p>The implementation of a class is distributed over several files:</p><ul><li><code>ocaml/idl/datamodel.ml</code> &ndash; central class definition</li><li><code>ocaml/idl/datamodel_types.ml</code> &ndash; definition of releases</li><li><code>ocaml/xapi/cli_frontend.ml</code> &ndash; declaration of CLI operations</li><li><code>ocaml/xapi/cli_operations.ml</code> &ndash; implementation of CLI operations</li><li><code>ocaml/xapi/records.ml</code> &ndash; getters and setters</li><li><code>ocaml/xapi/OMakefile</code> &ndash; refers to <code>xapi_pvs_farm.ml</code></li><li><code>ocaml/xapi/api_server.ml</code> &ndash; refers to <code>xapi_pvs_farm.ml</code></li><li><code>ocaml/xapi/message_forwarding.ml</code></li><li><code>ocaml/xapi/xapi_pvs_farm.ml</code> &ndash; implementation of methods, new file</li></ul><h3 id=data-model>Data Model</h3><p>The data model <code>ocaml/idl/datamodel.ml</code> defines the class. To keep the
name space tidy, most helper functions are grouped into an internal
module:</p><pre><code>(* datamodel.ml *)

let schema_minor_vsn = 103 (* line 21 -- increment this *)
let _pvs_farm = &quot;PVS_farm&quot; (* line 153 *)

module PVS_farm = struct (* line 8658 *)
  let lifecycle = [Prototyped, rel_dundee_plus, &quot;&quot;]

  let introduce = call
    ~name:&quot;introduce&quot;
    ~doc:&quot;Introduce new PVS farm&quot;
    ~result:(Ref _pvs_farm, &quot;the new PVS farm&quot;)
    ~params:
    [ String,&quot;name&quot;,&quot;name of the PVS farm&quot;
    ]
    ~lifecycle
    ~allowed_roles:_R_POOL_OP
    ()

  let forget = call
    ~name:&quot;forget&quot;
    ~doc:&quot;Remove a farm's meta data&quot;
    ~params:
    [ Ref _pvs_farm, &quot;self&quot;, &quot;this PVS farm&quot;
    ]
    ~errs:[
      Api_errors.pvs_farm_contains_running_proxies;
      Api_errors.pvs_farm_contains_servers;
    ]
    ~lifecycle
    ~allowed_roles:_R_POOL_OP
    ()


  let set_name = call
    ~name:&quot;set_name&quot;
    ~doc:&quot;Update the name of the PVS farm&quot;
    ~params:
    [ Ref _pvs_farm, &quot;self&quot;, &quot;this PVS farm&quot;
    ; String, &quot;value&quot;, &quot;name to be used&quot;
    ]
    ~lifecycle
    ~allowed_roles:_R_POOL_OP
    ()

  let add_cache_storage = call
    ~name:&quot;add_cache_storage&quot;
    ~doc:&quot;Add a cache SR for the proxies on the farm&quot;
    ~params:
    [ Ref _pvs_farm, &quot;self&quot;, &quot;this PVS farm&quot;
    ; Ref _sr, &quot;value&quot;, &quot;SR to be used&quot;
    ]
    ~lifecycle
    ~allowed_roles:_R_POOL_OP
    ()

  let remove_cache_storage = call
    ~name:&quot;remove_cache_storage&quot;
    ~doc:&quot;Remove a cache SR for the proxies on the farm&quot;
    ~params:
    [ Ref _pvs_farm, &quot;self&quot;, &quot;this PVS farm&quot;
    ; Ref _sr, &quot;value&quot;, &quot;SR to be removed&quot;
    ]
    ~lifecycle
    ~allowed_roles:_R_POOL_OP
    ()

  let obj =
    let null_str = Some (VString &quot;&quot;) in
    let null_set = Some (VSet []) in
    create_obj (* &lt;---- creates class *)
    ~name: _pvs_farm
    ~descr:&quot;machines serving blocks of data for provisioning VMs&quot;
    ~doccomments:[]
    ~gen_constructor_destructor:false
    ~gen_events:true
    ~in_db:true
    ~lifecycle
    ~persist:PersistEverything
    ~in_oss_since:None
    ~messages_default_allowed_roles:_R_POOL_OP
    ~contents:
    [ uid     _pvs_farm ~lifecycle

    ; field   ~qualifier:StaticRO ~lifecycle
              ~ty:String &quot;name&quot; ~default_value:null_str
              &quot;Name of the PVS farm. Must match name configured in PVS&quot;

    ; field   ~qualifier:DynamicRO ~lifecycle
              ~ty:(Set (Ref _sr)) &quot;cache_storage&quot; ~default_value:null_set
              ~ignore_foreign_key:true
              &quot;The SR used by PVS proxy for the cache&quot;

    ; field   ~qualifier:DynamicRO ~lifecycle
              ~ty:(Set (Ref _pvs_server)) &quot;servers&quot;
              &quot;The set of PVS servers in the farm&quot;


    ; field   ~qualifier:DynamicRO ~lifecycle
              ~ty:(Set (Ref _pvs_proxy)) &quot;proxies&quot;
              &quot;The set of proxies associated with the farm&quot;
    ]
    ~messages:
    [ introduce
    ; forget
    ; set_name
    ; add_cache_storage
    ; remove_cache_storage
    ]
    ()
end
let pvs_farm = PVS_farm.obj
</code></pre><p>The class is defined by a call to <code>create_obj</code> and it defines the
fields and messages (methods) belonging to the class. Each field has a
name, a type, and some meta information. Likewise, each message
(or method) is created by <code>call</code> that describes its parameters.</p><p>The <code>PVS_farm</code> has additional getter and setter methods for accessing
its fields. These are not declared here as part of the messages
but are automatically generated.</p><p>To make sure the new class is actually used, it is important to enter it
into two lists:</p><pre><code>(* datamodel.ml *)
let all_system = (* line 8917 *)
  [
    ...
    vgpu_type;
    pvs_farm;
    ...
  ]

let expose_get_all_messages_for = [ (* line 9097 *)
  ...
  _pvs_farm;
  _pvs_server;
  _pvs_proxy;
</code></pre><p>When a field refers to another object that itself refers back to it,
these two need to be entered into the <code>all_relations</code> list. For example,
<code>_pvs_server</code> refers to a <code>_pvs_farm</code> value via <code>"farm"</code>, which, in
turn, refers to the <code>_pvs_server</code> value via its <code>"servers"</code> field.</p><pre><code>let all_relations =
  [
    (* ... *)
    (_sr, &quot;introduced_by&quot;), (_dr_task, &quot;introduced_SRs&quot;);
    (_pvs_server, &quot;farm&quot;), (_pvs_farm, &quot;servers&quot;);
    (_pvs_proxy,  &quot;farm&quot;), (_pvs_farm, &quot;proxies&quot;);
  ]
</code></pre><h2 id=cli-conventions>CLI Conventions</h2><p>The CLI provides access to objects from the command line. The following
conventions exist for naming fields:</p><ul><li><p>A field in the data model uses an underscore (<code>_</code>) but a hyphen (<code>-</code>)
in the CLI: what is <code>cache_storage</code> in the data model becomes
<code>cache-storage</code> in the CLI.</p></li><li><p>When a field contains a reference or multiple, like <code>proxies</code>, it
becomes <code>proxy-uuids</code> in the CLI because references are always
referred to by their UUID.</p></li></ul><h2 id=cli-getters-and-setters>CLI Getters and Setters</h2><p>All fields can be read from the CLI and some fields can also be set via
the CLI. These getters and setters are mostly generated automatically
and need to be connected to the CLI through a function in
<code>ocaml/xapi/records.ml</code>. Note that field names here use the
naming convention for the CLI:</p><pre><code>(* ocaml/xapi/records.ml *)
let pvs_farm_record rpc session_id pvs_farm =
  let _ref = ref pvs_farm in
  let empty_record =
    ToGet (fun () -&gt; Client.PVS_farm.get_record rpc session_id !_ref) in
  let record = ref empty_record in
  let x () = lzy_get record in
    { setref    = (fun r -&gt; _ref := r ; record := empty_record)
    ; setrefrec = (fun (a,b) -&gt; _ref := a; record := Got b)
    ; record    = x
    ; getref    = (fun () -&gt; !_ref)
    ; fields=
      [ make_field ~name:&quot;uuid&quot;
        ~get:(fun () -&gt; (x ()).API.pVS_farm_uuid) ()
      ; make_field ~name:&quot;name&quot;
        ~get:(fun () -&gt; (x ()).API.pVS_farm_name)
        ~set:(fun name -&gt;
          Client.PVS_farm.set_name rpc session_id !_ref name) ()
      ; make_field ~name:&quot;cache-storage&quot;
        ~get:(fun () -&gt; (x ()).API.pVS_farm_cache_storage
          |&gt; List.map get_uuid_from_ref |&gt; String.concat &quot;; &quot;)
        ~add_to_set:(fun sr_uuid -&gt;
          let sr = Client.SR.get_by_uuid rpc session_id sr_uuid in
          Client.PVS_farm.add_cache_storage rpc session_id !_ref sr)
        ~remove_from_set:(fun sr_uuid -&gt;
          let sr = Client.SR.get_by_uuid rpc session_id sr_uuid in
          Client.PVS_farm.remove_cache_storage rpc session_id !_ref sr)
        ()
      ; make_field ~name:&quot;server-uuids&quot;
        ~get:(fun () -&gt; (x ()).API.pVS_farm_servers
          |&gt; List.map get_uuid_from_ref |&gt; String.concat &quot;; &quot;)
        ~get_set:(fun () -&gt; (x ()).API.pVS_farm_servers
          |&gt; List.map get_uuid_from_ref)
        ()
      ; make_field ~name:&quot;proxy-uuids&quot;
        ~get:(fun () -&gt; (x ()).API.pVS_farm_proxies
          |&gt; List.map get_uuid_from_ref |&gt; String.concat &quot;; &quot;)
        ~get_set:(fun () -&gt; (x ()).API.pVS_farm_proxies
          |&gt; List.map get_uuid_from_ref)
        ()
      ]
    }
</code></pre><h2 id=cli-interface-to-methods>CLI Interface to Methods</h2><p>Methods accessible from the CLI are declared in
<code>ocaml/xapi/cli_frontend.ml</code>. Each declaration refers to the real
implementation of the method, like <code>Cli_operations.PVS_far.introduce</code>:</p><pre><code>(* cli_frontend.ml *)
let rec cmdtable_data : (string*cmd_spec) list =
  (* ... *)
  &quot;pvs-farm-introduce&quot;,
  {
    reqd=[&quot;name&quot;];
    optn=[];
    help=&quot;Introduce new PVS farm&quot;;
    implementation=No_fd Cli_operations.PVS_farm.introduce;
    flags=[];
  };
  &quot;pvs-farm-forget&quot;,
  {
    reqd=[&quot;uuid&quot;];
    optn=[];
    help=&quot;Forget a PVS farm&quot;;
    implementation=No_fd Cli_operations.PVS_farm.forget;
    flags=[];
  };
</code></pre><h2 id=cli-implementation-of-methods>CLI Implementation of Methods</h2><p>Each CLI operation that is not a getter or setter has an implementation
in <code>cli_operations.ml</code> which is implemented in terms of the real
implementation:</p><pre><code>(* cli_operations.ml *)
module PVS_farm = struct
  let introduce printer rpc session_id params =
    let name  = List.assoc &quot;name&quot; params in
    let ref   = Client.PVS_farm.introduce ~rpc ~session_id ~name in
    let uuid  = Client.PVS_farm.get_uuid rpc session_id ref in
    printer (Cli_printer.PList [uuid])

  let forget printer rpc session_id params =
    let uuid  = List.assoc &quot;uuid&quot; params in
    let ref   = Client.PVS_farm.get_by_uuid ~rpc ~session_id ~uuid in
    Client.PVS_farm.forget rpc session_id ref
end
</code></pre><p>Fields that should show up in the CLI interface by default are declared
in the <code>gen_cmds</code> value:</p><pre><code>(* cli_operations.ml *)
let gen_cmds rpc session_id =
  let mk = make_param_funs in
  List.concat
  [ (*...*)
  ; Client.Pool.(mk get_all get_all_records_where
    get_by_uuid pool_record &quot;pool&quot; []
    [&quot;uuid&quot;;&quot;name-label&quot;;&quot;name-description&quot;;&quot;master&quot;
    ;&quot;default-SR&quot;] rpc session_id)
  ; Client.PVS_farm.(mk get_all get_all_records_where
    get_by_uuid pvs_farm_record &quot;pvs-farm&quot; []
    [&quot;uuid&quot;;&quot;name&quot;;&quot;cache-storage&quot;;&quot;server-uuids&quot;] rpc session_id)
</code></pre><h2 id=error-messages>Error messages</h2><p>Error messages used by an implementation are introduced in two files:</p><pre><code>(* ocaml/xapi-consts/api_errors.ml *)
let pvs_farm_contains_running_proxies = &quot;PVS_FARM_CONTAINS_RUNNING_PROXIES&quot;
let pvs_farm_contains_servers = &quot;PVS_FARM_CONTAINS_SERVERS&quot;
let pvs_farm_sr_already_added = &quot;PVS_FARM_SR_ALREADY_ADDED&quot;
let pvs_farm_sr_is_in_use = &quot;PVS_FARM_SR_IS_IN_USE&quot;
let sr_not_in_pvs_farm = &quot;SR_NOT_IN_PVS_FARM&quot;
let pvs_farm_cant_set_name = &quot;PVS_FARM_CANT_SET_NAME&quot;

(* ocaml/idl/datamodel.ml *)
  (* PVS errors *)
  error Api_errors.pvs_farm_contains_running_proxies [&quot;proxies&quot;]
    ~doc:&quot;The PVS farm contains running proxies and cannot be forgotten.&quot; ();

  error Api_errors.pvs_farm_contains_servers [&quot;servers&quot;]
    ~doc:&quot;The PVS farm contains servers and cannot be forgotten.&quot;
    ();

  error Api_errors.pvs_farm_sr_already_added [&quot;farm&quot;; &quot;SR&quot;]
    ~doc:&quot;Trying to add a cache SR that is already associated with the farm&quot;
    ();

  error Api_errors.sr_not_in_pvs_farm [&quot;farm&quot;; &quot;SR&quot;]
    ~doc:&quot;The SR is not associated with the farm.&quot;
    ();

  error Api_errors.pvs_farm_sr_is_in_use [&quot;farm&quot;; &quot;SR&quot;]
    ~doc:&quot;The SR is in use by the farm and cannot be removed.&quot;
    ();

  error Api_errors.pvs_farm_cant_set_name [&quot;farm&quot;]
    ~doc:&quot;The name of the farm can't be set while proxies are active.&quot;
    ()
</code></pre><h2 id=method-implementation>Method Implementation</h2><p>The implementation of methods lives in a module in <code>ocaml/xapi</code>:</p><pre><code>(* ocaml/xapi/api_server.ml *)
  module PVS_farm = Xapi_pvs_farm
</code></pre><p>The file below is typically a new file and needs to be added to
<code>ocaml/xapi/OMakefile</code>.</p><pre><code>(* ocaml/xapi/xapi_pvs_farm.ml *)
module D = Debug.Make(struct let name = &quot;xapi_pvs_farm&quot; end)
module E = Api_errors

let api_error msg xs = raise (E.Server_error (msg, xs))

let introduce ~__context ~name =
  let pvs_farm = Ref.make () in
  let uuid = Uuid.to_string (Uuid.make_uuid ()) in
  Db.PVS_farm.create ~__context
    ~ref:pvs_farm ~uuid ~name ~cache_storage:[];
  pvs_farm

(* ... *)
</code></pre><p>Messages received on a slave host may or may not be executed there. In
the simple case, each methods executes locally:</p><pre><code>(* ocaml/xapi/message_forwarding.ml *)
module PVS_farm = struct
  let introduce ~__context ~name =
    info &quot;PVS_farm.introduce %s&quot; name;
    Local.PVS_farm.introduce ~__context ~name

  let forget ~__context ~self =
    info &quot;PVS_farm.forget&quot;;
    Local.PVS_farm.forget ~__context ~self

  let set_name ~__context ~self ~value =
    info &quot;PVS_farm.set_name %s&quot; value;
    Local.PVS_farm.set_name ~__context ~self ~value

  let add_cache_storage ~__context ~self ~value =
    info &quot;PVS_farm.add_cache_storage&quot;;
    Local.PVS_farm.add_cache_storage ~__context ~self ~value

  let remove_cache_storage ~__context ~self ~value =
    info &quot;PVS_farm.remove_cache_storage&quot;;
    Local.PVS_farm.remove_cache_storage ~__context ~self ~value
end
</code></pre><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=adding-a-field-to-the-api>Adding a field to the API</h1><p>This page describes how to add a field to XenAPI. A field is a parameter of a class that can be used in functions and read from the API.</p><h2 id=bumping-the-database-schema-version>Bumping the database schema version</h2><p>Whenever a field is added to or removed from the API, its schema version needs
to be increased. XAPI needs this fundamental procedure in order to be able to
detect that an automatic database upgrade is necessary or to find out that the
new schema is incompatible with the existing database. If the schema version is
not bumped, XAPI will start failing in unpredictable ways. Note that bumping
the version is not necessary when adding functions, only when adding fields.</p><p>The current version number is kept at the top of the file
<code>ocaml/idl/datamodel_common.ml</code> in the variables <code>schema_major_vsn</code> and
<code>schema_minor_vsn</code>, of which only the latter should be incremented (the major
version only exists for historical reasons). When moving to a new XenServer
release, also update the variable <code>last_release_schema_minor_vsn</code> to the schema
version of the last release. To keep track of the schema versions of recent
XenServer releases, the file contains variables for these, such as
<code>miami_release_schema_minor_vsn</code>. After starting a new version of Xapi on an
existing server, the database is automatically upgraded if the schema version
of the existing database matches the value of <code>last_release_schema_*_vsn</code> in the
new Xapi.</p><p>As an example, the patch below shows how the schema version was bumped when the
new API fields used for ActiveDirectory integration were added:</p><pre><code>--- a/ocaml/idl/datamodel.ml  Tue Nov 11 16:17:48 2008 +0000
+++ b/ocaml/idl/datamodel.ml  Tue Nov 11 15:53:29 2008 +0000
@@ -15,17 +15,20 @@ open Datamodel_types
  open Datamodel_types

  (* IMPORTANT: Please bump schema vsn if you change/add/remove a _field_.
     You do not have to dump vsn if you change/add/remove a message *)

  let schema_major_vsn = 5
 -let schema_minor_vsn = 55
 +let schema_minor_vsn = 56

  (* Historical schema versions just in case this is useful later *)
  let rio_schema_major_vsn = 5
  let rio_schema_minor_vsn = 19

 +let miami_release_schema_major_vsn = 5
 +let miami_release_schema_minor_vsn = 35
 +
  (* the schema vsn of the last release: used to determine whether we can
     upgrade or not.. *)
  let last_release_schema_major_vsn = 5
 -let last_release_schema_minor_vsn = 35
 +let last_release_schema_minor_vsn = 55
</code></pre><h3 id=setting-the-schema-hash>Setting the schema hash</h3><p>In the <code>ocaml/idl/schematest.ml</code> there is the <code>last_known_schema_hash</code> This needs to be updated to be the next hash after the schema version was bumped. Get the new hash by running <code>make test</code> and you will receive the correct hash in the error message.</p><h2 id=adding-the-new-field-to-some-existing-class>Adding the new field to some existing class</h2><h3 id=ocamlidldatamodelml>ocaml/idl/datamodel.ml</h3><p>Add a new &ldquo;field&rdquo; line to the class in the file <code>ocaml/idl/datamodel.ml</code> or <code>ocaml/idl/datamodel_[class].ml</code>. The new field might require
a suitable default value. This default value is used in case the user does not
provide a value for the field.</p><p>A field has a number of parameters:</p><ul><li>The lifecycle parameter, which shows how the field has evolved over time.</li><li>The qualifier parameter, which controls access to the field. The following
values are possible:</li></ul><table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>StaticRO</td><td>Field is set statically at install-time.</td></tr><tr><td>DynamicRO</td><td>Field is computed dynamically at run time.</td></tr><tr><td>RW</td><td>Field is read/write.</td></tr></tbody></table><ul><li>The ty parameter for the type of the field.</li><li>The default_value parameter.</li><li>The name of the field.</li><li>A documentation string.</li></ul><p>Example of a field in the pool class:</p><pre><code>field ~lifecycle:[Published, rel_orlando, &quot;Controls whether HA is enabled&quot;]
      ~qualifier:DynamicRO ~ty:Bool
      ~default_value:(Some (VBool false)) &quot;ha_enabled&quot; &quot;true if HA is enabled on the pool, false otherwise&quot;;
</code></pre><p>See datamodel_types.ml for information about other parameters.</p><h2 id=changing-constructors>Changing Constructors</h2><p>Adding a field would change the constructors for the class â€“ functions
Db.*.create â€“ and therefore, any references to these in the code need to be
updated. In the example, the argument ~ha_enabled:false should be added to any
call to Db.Pool.create.</p><p>Examples of where these calls can be found is in <code>ocaml/tests/common/test_common.ml</code> and <code>ocaml/xapi/xapi_[class].ml</code>.</p><h3 id=cli-records>CLI Records</h3><p>If you want this field to show up in the CLI (which you probably do), you will
also need to modify the Records module, in the file
<code>ocaml/xapi-cli-server/records.ml</code>. Find the record function for the class which
you have modified, add a new entry to the fields list using make_field. This type can be found in the same file.</p><p>The only required parameters are name and get (and unit, of course ).
If your field is a map or set, then you will need to pass in get_{map,set}, and
optionally set_{map,set}, if it is a RW field. The hidden parameter is useful
if you don&rsquo;t want this field to show up in a *_params_list call. As an example,
here is a field that we&rsquo;ve just added to the SM class:</p><pre><code>make_field ~name:&quot;versioned-capabilities&quot;
           ~get:(fun () -&gt; get_from_map (x ()).API.sM_versioned_capabilities)
           ~get_map:(fun () -&gt; (x ()).API.sM_versioned_capabilities)
           ~hidden:true ();
</code></pre><h2 id=testing>Testing</h2><p>The new fields can be tested by copying the newly compiled xapi binary to a
test box. After the new xapi service is started, the file
<em>/var/log/xensource.log</em> in the test box should contain a few lines reporting the
successful upgrade of the metadata schema in the test box:</p><pre><code>[...|xapi] Db has schema major_vsn=5, minor_vsn=57 (current is 5 58) (last is 5 57)
[...|xapi] Database schema version is that of last release: attempting upgrade
[...|sql] attempting to restore database from /var/xapi/state.db
[...|sql] finished parsing xml
[...|sql] writing db as xml to file '/var/xapi/state.db'.
[...|xapi] Database upgrade complete, restarting to use new db
</code></pre><h2 id=making-this-field-accessible-as-a-cli-attribute>Making this field accessible as a CLI attribute</h2><p>XenAPI functions to get and set the value of the new field are generated
automatically. It requires some extra work, however, to enable such operations
in the CLI.</p><p>The CLI has commands such as host-param-list and host-param-get. To make a new
field accessible by these commands, the file <code>xapi-cli-server/records.ml</code> needs to
be edited. For the pool.ha-enabled field, the pool_record function in this file
contains the following (note the convention to replace underscores by hyphens
in the CLI):</p><pre><code>let pool_record rpc session_id pool =
  ...
[
  ...
  make_field ~name:&quot;ha-enabled&quot; ~get:(fun () -&gt; string_of_bool (x ()).API.pool_ha_enabled) ();
  ...
]}
</code></pre><p>NB: the ~get parameter must return a string so include a relevant function to convert the type of the field into a string i.e. <code>string_of_bool</code></p><p>See <code>xapi-cli-server/records.ml</code> for examples of handling field types other than Bool.</p><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=adding-a-function-to-the-api>Adding a function to the API</h1><p>This page describes how to add a function to XenAPI.</p><h2 id=add-message-to-api>Add message to API</h2><p>The file <code>idl/datamodel.ml</code> is a description of the API, from which the
marshalling and handler code is generated.</p><p>In this file, the <code>create_obj</code> function is used to define a class which may
contain fields and support operations (known as &ldquo;messages&rdquo;). For example, the
identifier host is defined using create_obj to encapsulate the operations which
can be performed on a host.</p><p>In order to add a function to the API, we need to add a message to an existing
class. This entails adding a function in <code>idl/datamodel.ml</code> or one of the other datamodel files to describe the new
message and adding it to the class&rsquo;s list of messages. In this example, we are adding to <code>idl/datamodel_host.ml</code>.</p><p>The function to describe the new message will look something like the following:</p><pre><code>let host_price_of = call ~flags:[`Session]
    ~name:&quot;price_of&quot;
    ~in_oss_since:None
    ~lifecycle:[]
    ~params:[(Ref _host, &quot;host&quot;, &quot;The host containing the price information&quot;);
             (String, &quot;item&quot;, &quot;The item whose price is queried&quot;)]
    ~result:(Float, &quot;The price of the item&quot;)
    ~doc:&quot;Returns the price of a named item.&quot;
    ~allowed_roles:_R_POOL_OP
    ()
</code></pre><p>By convention, the name of the function is formed from the name of the class
and the name of the message: host and price_of, in the example. An entry for
host_price_of is added to the messages of the host class:</p><pre><code>let host =
    create_obj ...
        ~messages: [...
                    host_price_of;
                   ]
...
</code></pre><p>The parameters passed to call are all optional (except ~name and ~lifecycle).</p><ul><li><p>The ~flags parameter is used to set conditions for the use of the message.
For example, `Session is used to indicate that the call must be made in the
presence of an existing session.</p></li><li><p>The value of the <code>~lifecycle</code> parameter should be <code>[]</code> in new code, with dune
automatically generating appropriate values (<code>datamodel_lifecycle.ml</code>)</p></li><li><p>The ~params parameter describes a list of the formal parameters of the message.
Each parameter is described by a triple. The first component of the triple is
the type (from type ty in <code>idl/datamodel_types.ml</code>); the second is the name
of the parameter, and the third is a human-readable description of the parameter.
The first triple in the list is conventionally the instance of the class on
which the message will operate. In the example, this is a reference to the host.</p></li><li><p>Similarly, the ~result describes the message&rsquo;s return type, although this is
permitted to merely be a single value rather than a list of values. If no
~result is specified, the default is unit.</p></li><li><p>The ~doc parameter describes what the message is doing.</p></li><li><p>The bool ~hide_from_docs parameter prevents the message from being included in the documentation when generated.</p></li><li><p>The bool ~pool_internal parameter is used to indicate if the message should be callable by external systems or only internal hosts.</p></li><li><p>The ~errs parameter is a list of possible exceptions that the message can raise.</p></li><li><p>The parameter ~lifecycle takes in an array of (Status, version, doc) to indicate the lifecycle of the message type. This takes over from ~in_oss_since which indicated the release that the message type was introduced. NOTE: Leave this parameter empty, it will be populated on build.</p></li><li><p>The ~allowed_roles parameter is used for access control (see below).</p></li></ul><p>Compiling <code>xen-api.(hg|git)</code> will cause the code corresponding to this message
to be generated and output in <code>ocaml/xapi/server.ml</code>. In the example above, a
section handling an incoming call host.price_of appeared in <code>ocaml/xapi/server.ml</code>.
However, after this was generated, the rest of the build failed because this
call expects a price_of function in the Host object.</p><h2 id=update-expose_get_all_messages_for-list>Update expose_get_all_messages_for list</h2><p>If you are adding a new class, do not forget to add your new class _name to
the expose_get_all_messages_for list, at the bottom of datamodel.ml, in
order to have automatically generated get_all and get_all_records functions
attached to it.</p><h2 id=update-the-rbac-field-containing-the-roles-expected-to-use-the-new-api-call>Update the RBAC field containing the roles expected to use the new API call</h2><p>After the RBAC integration, Xapi provides by default a set of static roles
associated to the most common subject tasks.</p><p>The api calls associated with each role are defined by a new <code>~allowed_roles</code>
parameter in each api call, which specifies the list of static roles that
should be able to execute the call. The possible roles for this list is one of
the following names, defined in <code>datamodel.ml</code>:</p><ul><li>role_pool_admin</li><li>role_pool_operator</li><li>role_vm_power_admin</li><li>role_vm_admin</li><li>role_vm_operator</li><li>role_read_only</li></ul><p>So, for instance,</p><pre><code>~allowed_roles:[role_pool_admin,role_pool_operator] (* this is not the recommended usage, see example below *)
</code></pre><p>would be a valid list (though it is not the recommended way of using
allowed_roles, see below), meaning that subjects belonging to either
role_pool_admin or role_pool_operator can execute the api call.</p><p>The RBAC requirements define a policy where the roles in the list above are
supposed to be totally-ordered by the set of api-calls associated with each of
them. That means that any api-call allowed to role_pool_operator should also be
in role_pool_admin; any api-call allowed to role_vm_power_admin should also be
in role_pool_operator and also in role_pool_admin; and so on. Datamodel.ml
provides shortcuts for expressing these totally-ordered set of roles policy
associated with each api-call:</p><ul><li>_R_POOL_ADMIN, equivalent to [role_pool_admin]</li><li>_R_POOL_OP, equivalent to [role_pool_admin,role_pool_operator]</li><li>_R_VM_POWER_ADMIN, equivalent to [role_pool_admin,role_pool_operator,role_vm_power_admin]</li><li>_R_VM_ADMIN, equivalent to [role_pool_admin,role_pool_operator,role_vm_power_admin,role_vm_admin]</li><li>_R_VM_OP, equivalent to [role_pool_admin,role_pool_operator,role_vm_power_admin,role_vm_admin,role_vm_op]</li><li>_R_READ_ONLY, equivalent to [role_pool_admin,role_pool_operator,role_vm_power_admin,role_vm_admin,role_vm_op,role_read_only]</li></ul><p>The <code>~allowed_roles</code> parameter should use one of the shortcuts in the list above,
instead of directly using a list of roles, because the shortcuts above make sure
that the roles in the list are in a total order regarding the api-calls
permission sets. Creating an api-call with e.g.
allowed_roles:[role_pool_admin,role_vm_admin] would be wrong, because that
would mean that a pool_operator cannot execute the api-call that a vm_admin can,
breaking the total-order policy expected in the RBAC 1.0 implementation.
In the future, this requirement might be relaxed.</p><p>So, the example above should instead be used as:</p><pre><code>~allowed_roles:_R_POOL_OP  (* recommended usage via pre-defined totally-ordered role lists *)
</code></pre><p>and so on.</p><h2 id=how-to-determine-the-correct-role-of-a-new-api-call>How to determine the correct role of a new api-call:</h2><ul><li>if only xapi should execute the api-call, ie. it is an internal call: _R_POOL_ADMIN</li><li>if it is related to subject, role, external-authentication: _R_POOL_ADMIN</li><li>if it is related to accessing Dom0 (via console, ssh, whatever): _R_POOL_ADMIN</li><li>if it is related to the pool object: R_POOL_OP</li><li>if it is related to the host object, licenses, backups, physical devices: _R_POOL_OP</li><li>if it is related to managing VM memory, snapshot/checkpoint, migration: _R_VM_POWER_ADMIN</li><li>if it is related to creating, destroying, cloning, importing/exporting VMs: _R_VM_ADMIN</li><li>if it is related to starting, stopping, pausing etc VMs or otherwise accessing/manipulating VMs: _R_VM_OP</li><li>if it is related to being able to login, manipulate own tasks and read values only: _R_READ_ONLY</li></ul><h2 id=update-message-forwarding>Update message forwarding</h2><p>The &ldquo;message forwarding&rdquo; layer describes the policy of whether an incoming API
call should be forwarded to another host (such as another member of the pool)
or processed on the host which receives the call. This policy may be
non-trivial to describe and so cannot be auto-generated from the data model.</p><p>In <code>xapi/message_forwarding.ml</code>, add a function to the relevant module to
describe this policy. In the running example, we add the following function to
the Host module:</p><pre><code>let price_of ~__context ~host ~item =
    info &quot;Host.price_of for item %s&quot; item;
    let local_fn = Local.Host.price_of ~host ~item in
    let remote_fn = Client.Host.price_of ~host ~item in
    do_op_on ~local_fn ~__context ~host ~remote_fn
</code></pre><p>After the ~__context parameter, the parameters of this new function should
match the parameters we specified for the message. In this case, that is the
host and the item to query the price of.</p><p>The do_op_on function takes a function to execute locally and a function to
execute remotely and performs one of these operations depending on whether the
given host is the local host.</p><p>The local function references Local.Host.price_of, which is a function we will
write in the next step.</p><h2 id=implement-the-function>Implement the function</h2><p>Now we write the function to perform the logic behind the new API call.
For a host-based call, this will reside in <code>xapi/xapi_host.ml</code>. For other
classes, other files with similar names are used.</p><p>We add the following function to <code>xapi/xapi_host.ml</code>:</p><pre><code>let price_of ~__context ~host ~item =
    if item = &quot;fish&quot; then 3.14 else 0.00
</code></pre><p>We also need to add the function to the interface <code>xapi/xapi_host.mli</code>:</p><pre><code>val price_of :
    __context:Context.t -&gt; host:API.ref_host -&gt; item:string -&gt; float
</code></pre><p>Congratulations, you&rsquo;ve added a function to the API!</p><h2 id=add-the-operation-to-the-cli>Add the operation to the CLI</h2><p>Edit <code>xapi-cli-server/cli_frontend.ml</code>. Add a block to the definition of cmdtable_data as
in the following example:</p><pre><code>&quot;host-price-of&quot;,
{
  reqd=[&quot;host-uuid&quot;; &quot;item&quot;];
  optn=[];
  help=&quot;Find out the price of an item on a certain host.&quot;;
  implementation= No_fd Cli_operations.host_price_of;
  flags=[];
};
</code></pre><p>Include here the following:</p><ul><li><p>The names of required (<em>reqd</em>) and optional (<em>optn</em>) parameters.</p></li><li><p>A description to be displayed when calling <em>xe help &lt;cmd></em> in the help field.</p></li><li><p>The <em>implementation</em> should use <em>With_fd</em> if any communication with the
client is necessary (for example, showing the user a warning, sending the
contents of a file, etc.) Otherwise, <em>No_fd</em> can be used as above.</p></li><li><p>The <em>flags</em> field can be used to set special options:</p><ul><li><em>Vm_selectors</em>: adds a &ldquo;vm&rdquo; parameter for the name of a VM (rather than a UUID)</li><li><em>Host_selectors</em>: adds a &ldquo;host&rdquo; parameter for the name of a host (rather than a UUID)</li><li><em>Standard</em>: includes the command in the list of common commands displayed by <em>xe help</em></li><li><em>Neverforward:</em></li><li><em>Hidden:</em></li><li><em>Deprecated of string list:</em></li></ul></li></ul><p>Now we must implement <code>Cli_operations.host_price_of</code>. This is done in
<code>xapi-cli-server/cli_operations.ml</code>. This function typically extracts the parameters and
forwards them to the internal implementation of the function. Other arbitrary
code is permitted. For example:</p><pre><code>let host_price_of printer rpc session_id params =
  let host = Client.Host.get_by_uuid rpc session_id (List.assoc &quot;host-uuid&quot; params) in
  let item = List.assoc &quot;item&quot; params in
  let price = string_of_float (Client.Host.price_of ~rpc ~session_id ~host ~item) in
  printer (Cli_printer.PList [price])
</code></pre><h2 id=tab-completion-in-the-cli>Tab Completion in the CLI</h2><p>The CLI features tab completion for many of its commands&rsquo; parameters.
Tab completion is implemented in the file <code>ocaml/xe-cli/bash-completion</code>, which
is installed on the host as <code>/etc/bash_completion.d/cli</code>, and is done on a
parameter-name rather than on a command-name basis. The main portion of the
bash-completion file is a case statement that contains a section for each of
the parameters that benefit from completion. There is also an entry that
catches all parameter names ending at -uuid, and performs an automatic lookup
of suitable UUIDs. The host-uuid parameter of our new host-price-of command
therefore automatically gains completion capabilities.</p><h2 id=executing-the-cli-operation>Executing the CLI operation</h2><p>Recompile <code>xapi</code> with the changes described above and install it on a test machine.</p><p>Execute the following command to see if the function exists:</p><pre><code>xe help host-price-of
</code></pre><p>Invoke the function itself with the following command:</p><pre><code>xe host-price-of host-uuid=&lt;tab&gt; item=fish
</code></pre><p>and you should find out the price of fish.</p><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=adding-a-xenapi-extension>Adding a XenAPI extension</h1><p>A XenAPI extension is a new RPC which is implemented as a separate executable
(i.e. it is not part of <code>xapi</code>)
but which still benefits from <code>xapi</code> parameter type-checking, multi-language
stub generation, documentation generation, authentication etc.
An extension can be backported to previous versions by simply adding the
implementation, without having to recompile <code>xapi</code> itself.</p><p>A XenAPI extension is in two parts:</p><ol><li>a declaration in the <a href=https://github.com/xapi-project/xen-api/blob/07056d661bbf58b652e1da59d9adf67a778a5626/ocaml/idl/datamodel.ml#L5608 rel=external target=_blank>xapi datamodel</a>.
This must use the <code>~forward_to:(Extension "filename")</code> parameter. The filename must be unique, and
should be the same as the XenAPI call name.</li><li>an implementation executable in the dom0 filesystem with path <code>/etc/xapi.d/extensions/filename</code></li></ol><h2 id=to-define-an-extension>To define an extension</h2><p>First write the declaration in the datamodel. The act of specifying the
types and writing the documentation will help clarify the intended meaning
of the call.</p><p>Second create a prototype of your implementation and put an executable file
in <code>/etc/xapi.d/extensions/filename</code>. The calling convention is:</p><ul><li>the file must be executable</li><li><code>xapi</code> will parse the XMLRPC call arguments received over the network and check the <code>session_id</code> is
valid</li><li><code>xapi</code> will execute the named executable</li><li>the XMLRPC call arguments will be sent to the executable on <code>stdin</code> and
<code>stdin</code> will be closed afterwards</li><li>the executable will run and print an XMLRPC response on <code>stdout</code></li><li><code>xapi</code> will read the response and return it to the client.</li></ul><p>See the <a href=https://github.com/xapi-project/xen-api/blob/07056d661bbf58b652e1da59d9adf67a778a5626/scripts/extensions/Test.test rel=external target=_blank>basic example</a>.</p><p>Second make a <a href=https://github.com/xapi-project/xen-api/pulls rel=external target=_blank>pull request</a>
containing only the datamodel definitions (it is not necessary to include the
prototype too).
This will attract review comments which will help you improve your API further.
Once the pull request is merged, then the API call name and extension are officially
yours and you may use them on any xapi version which supports the extension mechanism.</p><h2 id=packaging-your-extension>Packaging your extension</h2><p>Your extension <code>/etc/xapi.d/extensions/filename</code> (and dependencies) should be
packaged for your target distribution (for XenServer dom0 this would be a CentOS
RPM). Once the package is unpacked on the target machine, the extension should
be immediately callable via the XenAPI, provided the <code>xapi</code> version supports
the extension mechanism. Note the <code>xapi</code> version does not need to know about
the specific extension in advance: it will always look in <code>/etc/xapi.d/extensions/</code> for
all RPC calls whose name it does not recognise.</p><h2 id=limitations>Limitations</h2><p>On type-checking</p><ul><li>if the <code>xapi</code> version is new enough to know about your specific extension:
<code>xapi</code> will type-check the call arguments for you</li><li>if the <code>xapi</code> version is too old to know about your specific extension:
the extension will still be callable but the arguments will not be type-checked.</li></ul><p>On access control</p><ul><li>if the <code>xapi</code> version is new enough to know about your specific extension:
you can declare that a user must have a particular role (e.g. &lsquo;VM admin&rsquo;)</li><li>if the <code>xapi</code> version is too old to know about your specific extension:
the extension will still be callable but the client must have the &lsquo;Pool admin&rsquo; role.</li></ul><p>Since a <code>xapi</code> which knows about your specific extension is stricter than an older
<code>xapi</code>, it&rsquo;s a good idea to develop against the new <code>xapi</code> and then test older
<code>xapi</code> versions later.</p><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article></section></section><article class=default><header class=headline></header><h1 id=how-to-set-up-alarms>How to set up alarms</h1><h1 id=introduction>Introduction</h1><p>In XAPI, alarms are triggered by a Python daemon located at <code>/opt/xensource/bin/perfmon</code>.
The daemon is managed as a systemd service and can be configured by setting parameters in <code>/etc/sysconfig/perfmon</code>.</p><p>It listens on an internal Unix socket to receive commands. Otherwise, it runs in a loop, periodically requesting metrics from XAPI. It can then be configured to generate events based on these metrics. It can monitor various types of XAPI objects, including <code>VMs</code>, <code>SRs</code>, and <code>Hosts</code>. The configuration for each object is defined by writing an XML string into the object&rsquo;s <code>other-config</code> key.</p><p>The metrics used by <code>perfmon</code> are collected by the <code>xcp-rrdd</code> daemon. The <code>xcp-rrdd</code> daemon is a component of XAPI responsible for collecting metrics and storing them as Round-Robin Databases (RRDs).</p><p>A XAPI plugin also exists, providing the functions <code>refresh</code> and <code>debug_mem</code>, which send commands through the Unix socket. The <code>refresh</code> function is used when an <code>other-config</code> key is added or updated; it triggers the daemon to reread the monitored objects so that new alerts are taken into account. The <code>debug_mem</code> function logs the objects currently being monitored into <code>/var/log/user.log</code> as a dictionary.</p><h1 id=monitoring-and-alarms>Monitoring and alarms</h1><h2 id=overview>Overview</h2><ul><li>To get the metrics, <code>perfmon</code> requests XAPI by calling: <code>http://localhost/rrd_updates?session_id=&lt;ref>&amp;start=1759912021&amp;host=true&amp;sr_uuid=all&amp;cf=AVERAGE&amp;interval=60</code></li><li>Different consolidation functions can be used like <strong>AVERAGE</strong>, <strong>MIN</strong>, <strong>MAX</strong> or <strong>LAST</strong>. See the details in the next sections for specific objects and how to set it.</li><li>Once retrieve, <code>perfmon</code> will check all its triggers and generate alarms if needed.</li></ul><h2 id=specific-xapi-objects>Specific XAPI objects</h2><h3 id=vms>VMs</h3><ul><li>To set an alarm on a VM, you need to write an XML string into the <code>other-config</code> key of the object. For example, to trigger an alarm when the CPU usage is higher than 50%, run:</li></ul><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>xe vm-param-set uuid<span style=color:#f92672>=</span>&lt;UUID&gt; other-config:perfmon<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;&lt;config&gt; &lt;variable&gt; &lt;name value=&#34;cpu_usage&#34;/&gt; &lt;alarm_trigger_level value=&#34;0.5&#34;/&gt; &lt;/variable&gt; &lt;/config&gt;&#39;</span></span></span></code></pre></div><ul><li>Then, you can either wait until the new configuration is read by the <code>perfmon</code> daemon or force a refresh by running:</li></ul><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>xe host-call-plugin host-uuid<span style=color:#f92672>=</span>&lt;UUID&gt; plugin<span style=color:#f92672>=</span>perfmon fn<span style=color:#f92672>=</span>refresh</span></span></code></pre></div><ul><li>Now, if you generate some load inside the VM and the CPU usage goes above 50%, the <code>perfmon</code> daemon will create a message (a XAPI object) with the name <strong>ALARM</strong>. This message will include a <em>priority</em>, a <em>timestamp</em>, an <em>obj-uuid</em> and a <em>body</em>. To list all messages that are alarms, run:</li></ul><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>xe message-list name<span style=color:#f92672>=</span>ALARM</span></span></code></pre></div><ul><li>You will see, for example:</li></ul><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>uuid <span style=color:#f92672>(</span> RO<span style=color:#f92672>)</span>         : dadd7cbc-cb4e-5a56-eb0b-0bb31c102c94
</span></span><span style=display:flex><span>         name <span style=color:#f92672>(</span> RO<span style=color:#f92672>)</span>: ALARM
</span></span><span style=display:flex><span>     priority <span style=color:#f92672>(</span> RO<span style=color:#f92672>)</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>        class <span style=color:#f92672>(</span> RO<span style=color:#f92672>)</span>: VM
</span></span><span style=display:flex><span>     obj-uuid <span style=color:#f92672>(</span> RO<span style=color:#f92672>)</span>: ea9efde2-d0f2-34bb-74cb-78c303f65d89
</span></span><span style=display:flex><span>    timestamp <span style=color:#f92672>(</span> RO<span style=color:#f92672>)</span>: 20251007T11:30:26Z
</span></span><span style=display:flex><span>         body <span style=color:#f92672>(</span> RO<span style=color:#f92672>)</span>: value: 0.986414
</span></span><span style=display:flex><span>config:
</span></span><span style=display:flex><span>&lt;variable&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        &lt;name value<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;cpu_usage&#34;</span>/&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        &lt;alarm_trigger_level value<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;0.5&#34;</span>/&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;/variable&gt;</span></span></code></pre></div><ul><li><p>where the <em>body</em> contains all the relevant information: the value that triggered the alarm and the configuration of your alarm.</p></li><li><p>When configuring you alarm, your XML string can:</p><ul><li>have multiple <code>&lt;variable></code> nodes</li><li>use the following values for child nodes:<ul><li><strong>name</strong>: what to call the variable (no default)</li><li><strong>alarm_priority</strong>: the priority of the messages generated (default &lsquo;3&rsquo;)</li><li><strong>alarm_trigger_level</strong>: level of value that triggers an alarm (no default)</li><li><strong>alarm_trigger_sense</strong>:&lsquo;high&rsquo; if alarm_trigger_level is a max, otherwise &rsquo;low&rsquo;. (default &lsquo;high&rsquo;)</li><li><strong>alarm_trigger_period</strong>: num seconds of &lsquo;bad&rsquo; values before an alarm is sent (default &lsquo;60&rsquo;)</li><li><strong>alarm_auto_inhibit_period</strong>: num seconds this alarm disabled after an alarm is sent (default &lsquo;3600&rsquo;)</li><li><strong>consolidation_fn</strong>: how to combine variables from rrd_updates into one value (default is &lsquo;average&rsquo; for &lsquo;cpu_usage&rsquo;, &lsquo;get_percent_fs_usage&rsquo; for &lsquo;fs_usage&rsquo;, &lsquo;get_percent_log_fs_usage&rsquo; for &rsquo;log_fs_usage&rsquo;,&lsquo;get_percent_mem_usage&rsquo; for &lsquo;mem_usage&rsquo;, & &lsquo;sum&rsquo; for everything else)</li><li><strong>rrd_regex</strong> matches the names of variables from (xe vm-data-sources-list uuid=$vmuuid) used to compute value (only has defaults for &ldquo;cpu_usage&rdquo;, &ldquo;network_usage&rdquo;, and &ldquo;disk_usage&rdquo;)</li></ul></li></ul></li><li><p>Notice that <code>alarm_priority</code> will be the priority of the generated <code>message</code>, 0 being low priority.</p></li></ul><h3 id=srs>SRs</h3><ul><li>To set an alarm on an SR object, as with VMs, you need to write an XML string into the <code>other-config</code> key of the SR. For example, you can run:</li></ul><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>xe sr-param-set uuid<span style=color:#f92672>=</span>&lt;UUID&gt; other-config:perfmon<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;&lt;config&gt;&lt;variable&gt;&lt;name value=&#34;physical_utilisation&#34;/&gt;&lt;alarm_trigger_level value=&#34;0.8&#34;/&gt;&lt;/variable&gt;&lt;/config&gt;&#39;</span></span></span></code></pre></div><ul><li>When configuring you alarm, the XML string supports the same child elements as for VMs</li></ul><h3 id=hosts>Hosts</h3><ul><li>As with VMs ans SRs, alarms can be configured by writing an XML string into an <code>other-config</code> key. For example, you can run:</li></ul><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>xe host-param-set uuid<span style=color:#f92672>=</span>&lt;UUID&gt; other-config:perfmon<span style=color:#f92672>=</span><span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  <span style=color:#e6db74>&#39;&lt;config&gt;&lt;variable&gt;&lt;name value=&#34;cpu_usage&#34;/&gt;&lt;alarm_trigger_level value=&#34;0.5&#34;/&gt;&lt;/variable&gt;&lt;/config&gt;&#39;</span></span></span></code></pre></div><ul><li><p>The XML string can include multiple <variable>nodes allowed</p></li><li><p>The full list of supported child nodes is:</p><ul><li><strong>name</strong>: what to call the variable (no default)</li><li><strong>alarm_priority</strong>: the priority of the messages generated (default &lsquo;3&rsquo;)</li><li><strong>alarm_trigger_level</strong>: level of value that triggers an alarm (no default)</li><li><strong>alarm_trigger_sense</strong>: &lsquo;high&rsquo; if alarm_trigger_level is a max, otherwise &rsquo;low&rsquo;. (default &lsquo;high&rsquo;)</li><li><strong>alarm_trigger_period</strong>: num seconds of &lsquo;bad&rsquo; values before an alarm is sent (default &lsquo;60&rsquo;)</li><li><strong>alarm_auto_inhibit_period</strong>:num seconds this alarm disabled after an alarm is sent (default &lsquo;3600&rsquo;)</li><li><strong>consolidation_fn</strong>: how to combine variables from rrd_updates into one value (default is &lsquo;average&rsquo; for &lsquo;cpu_usage&rsquo; & &lsquo;sum&rsquo; for everything else)</li><li><strong>rrd_regex</strong> matches the names of variables from (xe host-data-source-list uuid=<uuid>) used to compute value (only has defaults for &ldquo;cpu_usage&rdquo;, &ldquo;network_usage&rdquo;, &ldquo;memory_free_kib&rdquo; and &ldquo;sr_io_throughput_total_xxxxxxxx&rdquo;) where that last one ends with the first eight characters of the SR UUID)</li></ul></li><li><p>As a special case for SR throughput, it is also possible to configure a Host by writing XML into the <code>other-config</code> key of an SR connected to it. For example:</p></li></ul><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>xe sr-param-set uuid<span style=color:#f92672>=</span>$sruuid other-config:perfmon<span style=color:#f92672>=</span><span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  <span style=color:#e6db74>&#39;&lt;config&gt;&lt;variable&gt;&lt;name value=&#34;sr_io_throughput_total_per_host&#34;/&gt;&lt;alarm_trigger_level value=&#34;0.01&#34;/&gt;&lt;/variable&gt;&lt;/config&gt;&#39;</span></span></span></code></pre></div><ul><li>This only works for that specific variable name, and <code>rrd_regex</code> must not be specified.</li><li>Configuration done directly on the host (variable-name, sr_io_throughput_total_xxxxxxxx) takes priority.</li></ul><h2 id=which-metrics-are-available>Which metrics are available?</h2><ul><li>Accepted name for metrics are:<ul><li><strong>cpu_usage</strong>: matches RRD metrics with the pattern <code>cpu[0-9]+</code></li><li><strong>network_usage</strong>: matches RRD metrics with the pattern <code>vif_[0-9]+_[rt]x</code></li><li><strong>disk_usage</strong>: match RRD metrics with the pattern <code>vbd_(xvd|hd)[a-z]+_(read|write)</code></li><li><strong>fs_usage</strong>, <strong>log_fs_usage</strong>, <strong>mem_usage</strong> and <strong>memory_internal_free</strong> do not match anything by default.</li></ul></li><li>By using <code>rrd_regex</code>, you can add your own expressions. To get a list of available metrics with their descriptions, you can call the <code>get_data_sources</code> method for <a href=https://xapi-project.github.io/new-docs/xen-api/classes/vm/ rel=external target=_blank>VM</a>, for <a href=https://xapi-project.github.io/new-docs/xen-api/classes/sr/ rel=external target=_blank>SR</a> and also for <a href=https://xapi-project.github.io/new-docs/xen-api/classes/host/ rel=external target=_blank>Host</a>.</li><li>A python script is provided at the end to get data sources. Using the script we can, for example, see:</li></ul><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># ./get_data_sources.py --vm 5a445deb-0a8e-c6fe-24c8-09a0508bbe21</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>List of data sources related to VM 5a445deb-0a8e-c6fe-24c8-09a0508bbe21
</span></span><span style=display:flex><span>cpu0                         | CPU0 usage
</span></span><span style=display:flex><span>cpu_usage                    | Domain CPU usage
</span></span><span style=display:flex><span>memory                       | Memory currently allocated to VM
</span></span><span style=display:flex><span>memory_internal_free         | Memory used as reported by the guest agent
</span></span><span style=display:flex><span>memory_target                | Target of VM balloon driver
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>vbd_xvda_io_throughput_read  | Data read from the VDI, in MiB/s
</span></span><span style=display:flex><span>...</span></span></code></pre></div><ul><li>You can then set up an alarm when the data read from a VDI exceeds a certain level by doing:</li></ul><div class="highlight wrap-code"><pre tabindex=0><code>xe vm-param-set uuid=5a445deb-0a8e-c6fe-24c8-09a0508bbe21 \
  other-config:perfmon=&#39;&lt;config&gt;&lt;variable&gt; \
  &lt;name value=&#34;disk_usage&#34;/&gt; \
  &lt;alarm_trigger_level value=&#34;10&#34;/&gt; \
  &lt;rrd_regex value=&#34;vbd_xvda_io_throughput_read&#34;/&gt; \
  &lt;/variable&gt; &lt;/config&gt;&#39;</code></pre></div><ul><li>Here is the script that allows you to get data sources:</li></ul><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> argparse
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> XenAPI
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pretty_print</span>(data_sources):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> data_sources:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;No data sources.&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Compute alignment for something nice</span>
</span></span><span style=display:flex><span>    max_label_len <span style=color:#f92672>=</span> max(len(data[<span style=color:#e6db74>&#34;name_label&#34;</span>]) <span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> data_sources)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> data_sources:
</span></span><span style=display:flex><span>        label <span style=color:#f92672>=</span> data[<span style=color:#e6db74>&#34;name_label&#34;</span>]
</span></span><span style=display:flex><span>        desc <span style=color:#f92672>=</span> data[<span style=color:#e6db74>&#34;name_description&#34;</span>]
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>label<span style=color:#e6db74>:</span><span style=color:#e6db74>&lt;</span><span style=color:#e6db74>{</span>max_label_len<span style=color:#e6db74>}}</span><span style=color:#e6db74> | </span><span style=color:#e6db74>{</span>desc<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>list_vm_data</span>(session, uuid):
</span></span><span style=display:flex><span>    vm_ref <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span>xenapi<span style=color:#f92672>.</span>VM<span style=color:#f92672>.</span>get_by_uuid(uuid)
</span></span><span style=display:flex><span>    data_sources <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span>xenapi<span style=color:#f92672>.</span>VM<span style=color:#f92672>.</span>get_data_sources(vm_ref)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>List of data sources related to VM </span><span style=color:#e6db74>{</span>uuid<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    pretty_print(data_sources)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>list_host_data</span>(session, uuid):
</span></span><span style=display:flex><span>    host_ref <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span>xenapi<span style=color:#f92672>.</span>host<span style=color:#f92672>.</span>get_by_uuid(uuid)
</span></span><span style=display:flex><span>    data_sources <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span>xenapi<span style=color:#f92672>.</span>host<span style=color:#f92672>.</span>get_data_sources(host_ref)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>List of data sources related to Host </span><span style=color:#e6db74>{</span>uuid<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    pretty_print(data_sources)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>list_sr_data</span>(session, uuid):
</span></span><span style=display:flex><span>    sr_ref <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span>xenapi<span style=color:#f92672>.</span>SR<span style=color:#f92672>.</span>get_by_uuid(uuid)
</span></span><span style=display:flex><span>    data_sources <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span>xenapi<span style=color:#f92672>.</span>SR<span style=color:#f92672>.</span>get_data_sources(sr_ref)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>List of data sources related to SR </span><span style=color:#e6db74>{</span>uuid<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    pretty_print(data_sources)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    parser <span style=color:#f92672>=</span> argparse<span style=color:#f92672>.</span>ArgumentParser(
</span></span><span style=display:flex><span>        description<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;List data sources related to VM, host or SR&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(<span style=color:#e6db74>&#34;--vm&#34;</span>, help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;VM UUID&#34;</span>)
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(<span style=color:#e6db74>&#34;--host&#34;</span>, help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Host UUID&#34;</span>)
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(<span style=color:#e6db74>&#34;--sr&#34;</span>, help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;SR UUID&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    args <span style=color:#f92672>=</span> parser<span style=color:#f92672>.</span>parse_args()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Connect to local XAPI: no identification required to access local socket</span>
</span></span><span style=display:flex><span>    session <span style=color:#f92672>=</span> XenAPI<span style=color:#f92672>.</span>xapi_local()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        session<span style=color:#f92672>.</span>xenapi<span style=color:#f92672>.</span>login_with_password(<span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> args<span style=color:#f92672>.</span>vm:
</span></span><span style=display:flex><span>            list_vm_data(session, args<span style=color:#f92672>.</span>vm)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> args<span style=color:#f92672>.</span>host:
</span></span><span style=display:flex><span>            list_host_data(session, args<span style=color:#f92672>.</span>host)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> args<span style=color:#f92672>.</span>sr:
</span></span><span style=display:flex><span>            list_sr_data(session, args<span style=color:#f92672>.</span>sr)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> XenAPI<span style=color:#f92672>.</span>Failure <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;XenAPI call failed: </span><span style=color:#e6db74>{</span>e<span style=color:#f92672>.</span>details<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        sys<span style=color:#f92672>.</span>exit(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>        session<span style=color:#f92672>.</span>xenapi<span style=color:#f92672>.</span>session<span style=color:#f92672>.</span>logout()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    main()</span></span></code></pre></div><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xe-cli-architecture>XE CLI architecture</h1><details open class="box cstyle notices info"><summary class=box-label tabindex=-1><i class="fa-fw fas fa-info-circle"></i>
Info</summary><div class=box-content><p>The links in this page point to the source files of xapi
<a href=https://github.com/xapi-project/xen-api/tree/v1.132.0 rel=external target=_blank>v1.132.0</a>, not to the
latest source code. Meanwhile, the CLI server code in xapi has been moved to a
library separate from the main xapi binary, and has its own subdirectory
<code>ocaml/xapi-cli-server</code>.</p></div></details><h2 id=architecture>Architecture</h2><ul><li><p><strong>The actual CLI</strong> is a very lightweight binary in
<a href=https://github.com/xapi-project/xen-api/tree/v1.132.0/ocaml/xe-cli rel=external target=_blank>ocaml/xe-cli</a></p><ul><li>It is just a dumb client, that does everything that xapi tells
it to do</li><li>This is a security issue<ul><li>We must trust the xenserver that we connect to, because it
can tell xe to read local files, download files, &mldr;</li></ul></li><li>When it is first called, it takes the few command-line arguments
it needs, and then passes the rest to xapi in a HTTP PUT request<ul><li>Each argument is in a separate line</li></ul></li><li>Then it loops doing what xapi tells it to do, in a loop, until
xapi tells it to exit or an exception happens</li></ul></li><li><p><strong>The protocol</strong> description is in
<a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi-cli-protocol/cli_protocol.ml rel=external target=_blank>ocaml/xapi-cli-protocol/cli_protocol.ml</a></p><ul><li>The CLI has such a protocol that one binary can talk to multiple
versions of xapi as long as their CLI protocol versions are
compatible</li><li>and the CLI can be changed without updating the xe binary</li><li>and also for performance reasons, it is more efficient this way
than by having a CLI that makes XenAPI calls</li></ul></li><li><p><strong>Xapi</strong></p><ul><li>The HTTP POST request is sent to the <code>/cli</code> URL</li><li>In <code>Xapi.server_init</code>, xapi <a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/xapi.ml#L804 rel=external target=_blank>registers the appropriate function
to handle these
requests</a>,
defined in <a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/xapi.ml#L589 rel=external target=_blank>common_http_handlers in the same
file</a>:
<code>Xapi_cli.handler</code></li><li>The relevant code is in <code>ocaml/xapi/records.ml</code>,
<code>ocaml/xapi/cli_*.ml</code><ul><li>CLI object definitions are in <code>records.ml</code>, command
definitions in <code>cli_frontend.ml</code> (in
<a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/cli_frontend.ml#L72 rel=external target=_blank>cmdtable_data</a>),
implementations of commands in <code>cli_operations.ml</code></li></ul></li><li>When a command is received, it is parsed into a command name and
a parameter list of key-value pairs<ul><li>and the command table
<a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/xapi_cli.ml#L157 rel=external target=_blank>is</a>
<a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/cli_frontend.ml#L3005 rel=external target=_blank>populated
lazily</a>
from the commands defined in <code>cmdtable_data</code> in
<code>cli_frontend.ml</code>, and <a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/cli_operations.ml#L740 rel=external target=_blank>automatically
generated</a>
low-level parameter commands (the ones defined in <a href=http://docs.citrix.com/content/dam/docs/en-us/xenserver/xenserver-7-0/downloads/xenserver-7-0-administrators-guide.pdf rel=external target=_blank>section
A.3.2 of the XenServer Administrator&rsquo;s
Guide</a>)
are also added for a list of standard classes</li><li>the command table maps command names to records that contain
the implementation of the command, among other things</li></ul></li><li>Then the command name <a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/xapi_cli.ml#L86 rel=external target=_blank>is looked
up</a>
in the command table, and the corresponding operation is
executed with the parsed key-value parameter list passed to it</li></ul></li></ul><h2 id=walk-through-cli-handler-in-xapi-external-calls>Walk-through: CLI handler in xapi (external calls)</h2><h3 id=definitions-for-the-http-handler>Definitions for the HTTP handler</h3><pre><code>Constants.cli_uri = &quot;/cli&quot;

Datamodel.http_actions = [...;
  (&quot;post_cli&quot;, (Post, Constants.cli_uri, false, [], _R_READ_ONLY, []));
...]

(* these public http actions will NOT be checked by RBAC *)
(* they are meant to be used in exceptional cases where RBAC is already *)
(* checked inside them, such as in the XMLRPC (API) calls *)
Datamodel.public_http_actions_with_no_rbac_check` = [...
  &quot;post_cli&quot;;  (* CLI commands -&gt; calls XMLRPC *)
...]

Xapi.common_http_handlers = [...;
  (&quot;post_cli&quot;, (Http_svr.BufIO Xapi_cli.handler));
...]

Xapi.server_init () =
  ...
  &quot;Registering http handlers&quot;, [], (fun () -&gt; List.iter Xapi_http.add_handler common_http_handlers);
  ...
</code></pre><p>Due to there definitions, <code>Xapi_http.add_handler</code> does not perform RBAC checks for <code>post_cli</code>. This means that the CLI handler does not use <code>Xapi_http.assert_credentials_ok</code> when a request comes in, as most other handlers do. The reason is that RBAC checking is delegated to the actual XenAPI calls that are being done by the commands in <code>Cli_operations</code>.</p><p>This means that the <code>Xapi_http.add_handler call</code> so resolves to simply:</p><pre><code>Http_svr.Server.add_handler server Http.Post &quot;/cli&quot; (Http_svr.BufIO Xapi_cli.handler))
</code></pre><p>&mldr;which means that the function <code>Xapi_cli.handler</code> is called directly when an HTTP POST request with path <code>/cli</code> comes in.</p><h3 id=high-level-request-processing>High-level request processing</h3><p><code>Xapi_cli.handler</code>:</p><ul><li>Reads the body of the HTTP request, limitted to <code>Xapi_globs.http_limit_max_cli_size = 200 * 1024</code> characters.</li><li>Sends a protocol version string to the client: <code>"XenSource thin CLI protocol"</code> plus binary encoded major (0) and (2) minor numbers.</li><li>Reads the protocol version from the client and exits with an error if it does not match the above.</li><li>Calls <code>Xapi_cli.parse_session_and_args</code> with the request&rsquo;s body to extract the session ref, if there.</li><li>Calls <code>Cli_frontend.parse_commandline</code> to parse the rest of the command line from the body.</li><li>Calls <code>Xapi_cli.exec_command</code> to execute the command.</li><li>On error, calls <code>exception_handler</code>.</li></ul><p><code>Xapi_cli.parse_session_and_args</code>:</p><ul><li>Is passed the request body and reads it line by line. Each line is considered an argument.</li><li>Removes any CR chars from the end of each argument.</li><li>If the first arg starts with <code>session_id=</code>, the the bit after this prefix is considered to be a session reference.</li><li>Returns the session ref (if there) and (remaining) list of args.</li></ul><p><code>Cli_frontend.parse_commandline</code>:</p><ul><li>Returns the command name and assoc list of param names and values. It handles <code>--name</code> and <code>-flag</code> arguments by turning them into key/value string pairs.</li></ul><p><code>Xapi_cli.exec_command</code>:</p><ul><li>Finds username/password params.</li><li>Get the rpc function: this is the so-called &ldquo;<code>fake_rpc</code> callback&rdquo;, which does not use the network or HTTP at all, but goes straight to <code>Api_server.callback1</code> (the XenAPI RPC entry point). This function is used by the CLI handler to do loopback XenAPI calls.</li><li>Logs the parsed xe command, omitting sensitive data.</li><li>Continues as <code>Xapi_cli.do_rpcs</code></li><li>Looks up the command name in the command table from <code>Cli_frontend</code> (raises an error if not found).</li><li>Checks if all required params have been supplied (raises an error if not).</li><li>Checks that the host is a pool master (raises an error if not).</li><li>Depending on the command, a <code>session.login_with_password</code> or <code>session.slave_local_login_with_password</code> XenAPI call is made with the supplied username and password. If the authentication passes, then a session reference is returned for the RBAC role that belongs to the user. This session is used to do further XenAPI calls.</li><li>Next, the implementation of the command in <code>Cli_operations</code> is executed.</li></ul><h3 id=command-implementations>Command implementations</h3><p>The various commands are implemented in <code>cli_operations.ml</code>. These functions are only called after user authentication has passed (see above). However, RBAC restrictions are only enforced inside any XenAPI calls that are made, and <em>not</em> on any of the other code in <code>cli_operations.ml</code>.</p><p>The type of each command implementation function is as follows (see <code>cli_cmdtable.ml</code>):</p><pre><code>type op =
  Cli_printer.print_fn -&gt;
  (Rpc.call -&gt; Rpc.response) -&gt;
  API.ref_session -&gt; ((string*string) list) -&gt; unit
</code></pre><p>So each function receives a printer for sending text output to the xe client, and rpc function and session reference for doing XenAPI calls, and a key/value pair param list. Here is a typical example:</p><pre><code>let bond_create printer rpc session_id params =
  let network = List.assoc &quot;network-uuid&quot; params in
  let mac = List.assoc_default &quot;mac&quot; params &quot;&quot; in
  let network = Client.Network.get_by_uuid rpc session_id network in
  let pifs = List.assoc &quot;pif-uuids&quot; params in
  let uuids = String.split ',' pifs in
  let pifs = List.map (fun uuid -&gt; Client.PIF.get_by_uuid rpc session_id uuid) uuids in
  let mode = Record_util.bond_mode_of_string (List.assoc_default &quot;mode&quot; params &quot;&quot;) in
  let properties = read_map_params &quot;properties&quot; params in
  let bond = Client.Bond.create rpc session_id network pifs mac mode properties in
  let uuid = Client.Bond.get_uuid rpc session_id bond in
  printer (Cli_printer.PList [ uuid])
</code></pre><ul><li>The necessary parameters are looked up in <code>params</code> using <code>List.assoc</code> or similar.</li><li>UUIDs are translated into reference by <code>get_by_uuid</code> XenAPI calls (note that the <code>Client</code> module is the XenAPI client, and functions in there require the rpc function and session reference).</li><li>Then the main API call is made (<code>Client.Bond.create</code> in this case).</li><li>Further API calls may be made to output data for the client, and passed to the <code>printer</code>.</li></ul><p>This is the common case for CLI operations: they do API calls based on the parameters that were passed in.</p><p>However, other commands are more complicated, for example <code>vm_import/export</code> and <code>vm_migrate</code>. These contain a lot more logic in the CLI commands, and also send commands to the client to instruct it to read or write files and/or do HTTP calls.</p><p>Yet other commands do not actually do any XenAPI calls, but instead get &ldquo;helpful&rdquo; information from other places. Example: <code>diagnostic_gc_stats</code>, which displays statistics from xapi&rsquo;s OCaml GC.</p><h2 id=tutorials>Tutorials</h2><p>The following tutorials show how to extend the CLI (and XenAPI):</p><ul><li><a href=/new-docs/xapi/guides/howtos/add-field/index.html>Adding a field</a></li><li><a href=/new-docs/xapi/guides/howtos/add-function/index.html>Adding a function</a></li></ul><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=database>Database</h1><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Database</h1><article class=default><header class=headline></header><h1 id=metadata-on-lun>Metadata-on-LUN</h1><p>In the present version of XenServer, metadata changes resulting in
writes to the database are not persisted in non-volatile storage. Hence,
in case of failure, up to five minutesâ€™ worth of metadata changes could
be lost. The Metadata-on-LUNÂ feature addresses the issue by
ensuring that all database writes are retained. This will be used to
improve recovery from failure by storing incremental <em>deltas</em> which can
be re-applied to an old version of the database to bring it more
up-to-date. An implication of this is that clients will no longer be
required to perform a â€˜pool-sync-databaseâ€™ to protect critical writes,
because all writes will be implicitly protected.</p><p>This is implemented by saving descriptions of all persistent database
writes to a LUN when HA is active. Upon xapi restart after failure, such
as on master fail-over, these descriptions are read and parsed to
restore the latest version of the database.</p><h1 id=layout-on-block-device>Layout on block device</h1><p>It is useful to store the database on the block device as well as the
deltas, so that it is unambiguous on recovery which version of the
database the deltas apply to.</p><p>The content of the block device will be structured as shown in
the table below. It consists of a header; the rest of the
device is split into two halves.</p><table><thead><tr><th></th><th style=text-align:right>Length (bytes)</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td style=text-align:right>16</td><td>Magic identifier</td></tr><tr><td></td><td style=text-align:right>1</td><td>ASCII NUL</td></tr><tr><td></td><td style=text-align:right>1</td><td>Validity byte</td></tr><tr><td>First half database</td><td style=text-align:right>36</td><td>UUID as ASCII string</td></tr><tr><td></td><td style=text-align:right>16</td><td>Length of database as decimal ASCII</td></tr><tr><td></td><td style=text-align:right><em>(as specified)</em></td><td>Database (binary data)</td></tr><tr><td></td><td style=text-align:right>16</td><td>Generation count as decimal ASCII</td></tr><tr><td></td><td style=text-align:right>36</td><td>UUID as ASCII string</td></tr><tr><td>First half deltas</td><td style=text-align:right>16</td><td>Length of database delta as decimal ASCII</td></tr><tr><td></td><td style=text-align:right><em>(as specified)</em></td><td>Database delta (binary data)</td></tr><tr><td></td><td style=text-align:right>16</td><td>Generation count as decimal ASCII</td></tr><tr><td></td><td style=text-align:right>36</td><td>UUID as ASCII string</td></tr><tr><td>Second half database</td><td style=text-align:right>36</td><td>UUID as ASCII string</td></tr><tr><td></td><td style=text-align:right>16</td><td>Length of database as decimal ASCII</td></tr><tr><td></td><td style=text-align:right><em>(as specified)</em></td><td>Database (binary data)</td></tr><tr><td></td><td style=text-align:right>16</td><td>Generation count as decimal ASCII</td></tr><tr><td></td><td style=text-align:right>36</td><td>UUID as ASCII string</td></tr><tr><td>Second half deltas</td><td style=text-align:right>16</td><td>Length of database delta as decimal ASCII</td></tr><tr><td></td><td style=text-align:right><em>(as specified)</em></td><td>Database delta (binary data)</td></tr><tr><td></td><td style=text-align:right>16</td><td>Generation count as decimal ASCII</td></tr><tr><td></td><td style=text-align:right>36</td><td>UUID as ASCII string</td></tr></tbody></table><p>After the header, one or both halves may be devoid of content. In a half
which contains a database, there may be zero or more deltas (repetitions
of the last three entries in each half).</p><p>The structure of the device is split into two halves to provide
double-buffering. In case of failure during write to one half, the other
half remains intact.</p><p>The magic identifier at the start of the file protect against attempting
to treat a different device as a redo log.</p><p>The validity byte is a single `ascii</span> character indicating the
state of the two halves. It can take the following values:</p><table><thead><tr><th>Byte</th><th>Description</th></tr></thead><tbody><tr><td><code>0</code></td><td>Neither half is valid</td></tr><tr><td><code>1</code></td><td>First half is valid</td></tr><tr><td><code>2</code></td><td>Second half is valid</td></tr></tbody></table><p>The use of lengths preceding data sections permit convenient reading.
The constant repetitions of the UUIDs act as nonces to protect
against reading in invalid data in the case of an incomplete or corrupt
write.</p><h1 id=architecture>Architecture</h1><p>The I/O to and from the block device may involve long delays. For
example, if there is a network problem, or the iSCSIÂ device disappears,
the I/O calls may block indefinitely. It is important to isolate this
from xapi. Hence, I/O with the block device will occur in a separate
process.</p><p>Xapi will communicate with the I/O process via a UNIX domain socket using a
simple text-based protocol described below. The I/O process will use to
ensure that it can always accept xapiâ€™s requests with a guaranteed upper
limit on the delay. Xapi can therefore communicate with the process
using blocking I/O.</p><p>Xapi will interact with the I/O process in a best-effort fashion. If it
cannot communicate with the process, or the process indicates that it
has not carried out the requested command, xapi will continue execution
regardless. Redo-log entries are idempotent (modulo the raising of
exceptions in some cases) so it is of little consequence if a particular
entry cannot be written but others can. If xapi notices that the process
has died, it will attempt to restart it.</p><p>The I/O process keeps track of a pointer for each half indicating the
position at which the next delta will be written in that half.</p><h2 id=protocol>Protocol</h2><p>Upon connection to the control socket, the I/O process will attempt to
connect to the block device. Depending on whether this is successful or
unsuccessful, one of two responses will be sent to the client.</p><ul><li><p><code>connect|ack_</code> if it is successful; or</p></li><li><p><code>connect|nack|&lt;length>|&lt;message></code> if it is unsuccessful, perhaps
because the block device does not exist or cannot be read from. The
<code>&lt;message></code> is a description of the error; the <code>&lt;length></code> of the message
is expressed using 16 digits of decimal ascii.</p></li></ul><p>The former message indicates that the I/O process is ready to receive
commands. The latter message indicates that commands can not be sent to
the I/O process.</p><p>There are threeÂ commands which xapi can send to the I/O
process. These are described below, with a high level description of the
operational semantics of the I/O processâ€™ actions, and the corresponding
responses. For ease of parsing, each command is ten bytes in length.</p><h3 id=write-database>Write database</h3><p>Xapi requests that a new database is written to the block device, and
sends its content using the data socket.</p><h5 id=command>Command:</h5><dl><dt>: <code>writedb___|&lt;uuid>|&lt;generation-count>|&lt;length></code></dt><dd>The UUID is expressed as 36 ASCII
characters. The <em>length</em> of the data and the <em>generation-count</em> are
expressed using 16 digits of decimal ASCII.</dd></dl><h5 id=semantics>Semantics:</h5><ol><li>Read the validity byte.</li><li>If one half is valid, we will use the other half. If no halves
are valid, we will use the first half.</li><li>Read the data from the data socket and write it into the
chosen half.</li><li>Set the pointer for the chosen half to point to the position
after the data.</li><li>Set the validity byte to indicate the chosen half is valid.</li></ol><h5 id=response>Response:</h5><dl><dt>: <code>writedb|ack_</code> in case of successful write; or</dt><dd><code>writedb|nack|&lt;length>|&lt;message></code> otherwise.</dd><dd>For error messages, the <em>length</em> of the message is expressed using
16 digits of decimal <span style=font-variant:small-caps>ascii</span>. In particular, the
error message for timeouts is the string <code>Timeout</code>.</dd></dl><h3 id=write-database-delta>Write database delta</h3><p>Xapi sends a description of a database delta to append to the block
device.</p><h5 id=command-1>Command:</h5><dl><dt>: <code>writedelta|&lt;uuid>|&lt;generation-count>|&lt;length>|&lt;data></code></dt><dd>The UUID is expressed as 36 ASCII
characters. The <em>length</em> of the data and the <em>generation-count</em> are
expressed using 16 digits of decimal ASCII.</dd></dl><h5 id=semantics-1>Semantics:</h5><ol><li>Read the validity byte to establish which half is valid. If
neither half is valid, return with a <code>nack</code>.</li><li>If the halfâ€™s pointer is set, seek to that position. Otherwise,
scan through the half and stop at the position after the
last write.</li><li>Write the entry.</li><li>Update the halfâ€™s pointer to point to the position after
the entry.</li></ol><h5 id=response-1>Response:</h5><dl><dt>: <code>writedelta|ack_</code> in case of successful append; or</dt><dd><code>writedelta|nack|&lt;length>|&lt;message></code> otherwise.</dd><dd>For error messages, the <em>length</em> of the message is expressed using
16 digits of decimal ASCII. In particular, the
error message for timeouts is the string <code>Timeout</code>.</dd></dl><h3 id=read-log>Read log</h3><p>Xapi requests the contents of the log.</p><h5 id=command-2>Command:</h5><p>: <code>read______</code></p><h5 id=semantics-2>Semantics:</h5><ol><li>Read the validity byte to establish which half is valid. If
neither half is valid, return with an <code>end</code>.</li><li>Attempt to read the database from the current half.</li><li>If this is successful, continue in that half reading entries up
to the position of the halfâ€™s pointer. If the pointer is not
set, read until a record of length zero is found or the end of
the half is reached. Otherwiseâ€”if the attempt to the read the
database was not successfulâ€”switch to using the other half and
try again from step 2.</li><li>Finally output an <code>end</code>.</li></ol><h5 id=response-2>Response:</h5><dl><dt>: <code>read|nack_|&lt;length>|&lt;message></code> in case of error; or</dt><dd><code>read|db___|&lt;generation-count>|&lt;length>|&lt;data></code> for a database record, then a
sequence of zero or more</dd><dd><code>read|delta|&lt;generation-count>|&lt;length>|&lt;data></code> for each delta record, then</dd><dd><code>read|end__</code></dd><dd>For each record, and for error messages, the <em>length</em> of the data or
message is expressed using 16 digits of decimal <span style=font-variant:small-caps>ascii</span>. In particular, the
error message for timeouts is the string <code>Timeout</code>.</dd></dl><h3 id=re-initialise-log>Re-initialise log</h3><p>Xapi requests that the block device is re-initialised with a fresh
redo-log.</p><h5 id=command-3>Command:</h5><p>: <code>empty_____</code>\</p><h5 id=semantics-3>Semantics:</h5><p>: 1. Set the validity byte to indicate that neither half is valid.</p><h5 id=response-3>Response:</h5><dl><dt>: <code>empty|ack_</code> in case of successful re-initialisation; or</dt><dt><code>empty|nack|&lt;length>|&lt;message></code> otherwise.</dt><dd>For error messages, the <em>length</em> of the message is expressed using
16 digits of decimal ASCII. In particular, the
error message for timeouts is the string <code>Timeout</code>.</dd></dl><h1 id=impact-on-xapi-performance>Impact on xapi performance</h1><p>The implementation of the feature causes a slow-down in xapi of around
6% in the general case. However, if the LUN becomes inaccessible this
can cause a slow-down of up to 25% in the worst case.</p><p>The figure below shows the result of testing four configurations,
counting the number of database writes effected through a command-line
â€˜xe pool-param-setâ€™ call.</p><ul><li><p>The first and second configurations are xapi <em>without</em> the
Metadata-on-LUNÂ feature, with HA disabled and
enabled respectively.</p></li><li><p>The third configuration shows xapi <em>with</em> the
Metadata-on-LUNÂ feature using a healthy LUN to which
all database writes can be successfully flushed.</p></li><li><p>The fourth configuration shows xapi <em>with</em> the
Metadata-on-LUNÂ feature using an inaccessible LUN for
which all database writes fail.</p></li></ul><p><img alt="Impact of feature on xapi database-writing performance. (Green points\nrepresent individual samples; red bars are the arithmetic means of\nsamples.)" class="noborder lazy nolightbox shadow figure-image" loading=lazy src=/new-docs/xapi/database/redo-log/performance.svg style=height:auto;width:auto></p><h1 id=testing-strategy>Testing strategy</h1><p>The section above shows how xapi performance is affected by this feature. The
sectionsÂ below describe the dev-testing which has already been undertaken, and
propose how this feature will impact on regression testing.</p><h2 id=dev-testing-performed>Dev-testing performed</h2><p>A variety of informal tests have been performed as part of the
development process:</p><dl><dt>Enable HA.</dt><dd><p>Confirm LUN starts being used to persist database writes.</p></dd><dt>Enable HA, disable HA.</dt><dd><p>Confirm LUN stops being used.</p></dd><dt>Enable HA, kill xapi on master, restart xapi on master.</dt><dd><p>Confirm that last database write before kill is successfully
restored on restart.</p></dd><dt>Repeatedly enable and disable HA.</dt><dd><p>Confirm that no file descriptors are leaked (verified by counting
the number of descriptors in /proc/<em>pid</em>/fd/).</p></dd><dt>Enable HA, reboot the master.</dt><dd><p>Due to HA, a slave becomes the master (or this can be forced using
â€˜xe pool-emergency-transition-to-masterâ€™). Confirm that the new
master starts is able to restore the database from the LUN from the
point the old master left off, and begins to write new changes to
the LUN.</p></dd><dt>Enable HA, disable the iSCSI volume.</dt><dd><p>Confirm that xapi continues to make progress, although database
writes are not persisted.</p></dd><dt>Enable HA, disable and enable the iSCSI volume.</dt><dd><p>Confirm that xapi begins to use the LUN when the iSCSI volume is
re-enabled and subsequent writes are persisted.</p></dd></dl><p>These tests have been undertaken using an iSCSI target VM and a real
iSCSI volume on lannik. In these scenarios, disabling the iSCSI volume
consists of stopping the VM and unmapping the LUN, respectively.</p><h2 id=proposed-new-regression-test>Proposed new regression test</h2><p>A new regression test is proposed to confirm that all database writes
are persisted across failure.</p><p>There are three types of database modification to test: row creation,
field-write and row deletion. Although these three kinds of write could
be tested in separate tests, the means of setting up the pre-conditions
for a field-write and a row deletion require a row creation, so it is
convenient to test them all in a single test.</p><ol><li><p>Start a pool containing three hosts.</p></li><li><p>Issue a CLI command on the master to create a row in the
database, e.g.</p><p><code>xe network-create name-label=a</code>.</p></li><li><p>Forcefully power-cycle the master.</p></li><li><p>On fail-over, issue a CLI command on the new master to check that
the row creation persisted:</p><p><code>xe network-list name-label=a</code>,</p><p>confirming that the returned string is non-empty.</p></li><li><p>Issue a CLI command on the master to modify a field in the new row
in the database:</p><p><code>xe network-param-set uuid=&lt;uuid> name-description=abcd</code>,</p><p>where <code>&lt;uuid></code> is the UUID returned from step 2.</p></li><li><p>Forcefully power-cycle the master.</p></li><li><p>On fail-over, issue a CLI command on the new master to check that
the field-write persisted:</p><p><code>xe network-param-get uuid=&lt;uuid> param-name=name-description</code>,</p><p>where <code>&lt;uuid></code> is the UUID returned from step 2. The returned string
should contain</p><p><code>abcd</code>.</p></li><li><p>Issue a CLI command on the master to delete the row from the
database:</p><p><code>xe network-destroy uuid=&lt;uuid></code>,</p><p>where <code>&lt;uuid></code> is the UUID returned from step 2.</p></li><li><p>Forcefully power-cycle the master.</p></li><li><p>On fail-over, issue a CLI command on the new master to check that
the row does not exist:</p><p><code>xe network-list name-label=a</code>,</p><p>confirming that the returned string is empty.</p></li></ol><h2 id=impact-on-existing-regression-tests>Impact on existing regression tests</h2><p>The Metadata-on-LUNÂ feature should mean that there is no
need to perform an â€˜xe pool-sync-databaseâ€™ operation in existing HA
regression tests to ensure that database state persists on xapi failure.</p><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=xapis-internals>XAPI's Internals</h1><p>The articles provided under this sub-section intend to act as a developer
resource for toolstack engineers.</p><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Internals</h1><article class=default><header class=headline></header><h1 id=certificates-and-pem-files>Certificates and PEM Files</h1><p>Xapi uses certificates for secure communication within a pool and with
external clients. These certificates are using the PEM file format and
reside in the Dom0 file system. This documents explains the purpose of
these files.</p><h2 id=design-documents>Â Design Documents</h2><ul><li><a href=/new-docs/design/pool-certificates/index.html>Pool Certificates</a></li><li><a href=/new-docs/design/user-certificates/index.html>User Certificates</a></li></ul><h2 id=paths>Paths</h2><p>Below are paths used by Xapi for certificates; additional certficates
may be installed but they are not fundamental for Xapi&rsquo;s operation.</p><div class="highlight wrap-code"><pre tabindex=0><code>/etc/xensource/xapi-ssl.pem
/etc/xensource/xapi-pool-tls.pem
/etc/stunnel/certs-pool/1c111a1f-412e-47c0-9003-60789b839bc3.pem
/etc/stunnel/certs-pool/960abfff-6017-4d97-bd56-0a8f1a43e51a.pem
/etc/stunnel/xapi-stunnel-ca-bundle.pem
/etc/stunnel/certs/
/etc/stunnel/xapi-pool-ca-bundle.pem</code></pre></div><h2 id=fundamental-certificates>Fundamental Certificates</h2><p>Certificates that identify a host. These certificates are comprised of
both a private and a public key. The public key may be distributed to
other hosts.</p><h3 id=xapi-sslpem>xapi-ssl.pem</h3><p>This certificate identifies a host for extra-pool clients.</p><p>This is the certificate used by the API HTTPS server that clients like
XenCenter or CVAD connect to. On installation of XenServer it is auto
generated but can be updated by a user using the API. This is the most
important certificate for a user to establish an HTTPS connection to a
pool or host to be used as an API.</p><ul><li>/etc/xensource/xapi-ssl.pem</li><li>contains private and public key for this host</li><li><code>Host.get_server_certificate</code> API call</li><li>referenced by /etc/stunnel/xapi.conf</li><li><code>xe host-server-certificate-install</code> XE command to replace the
certificate.</li><li>See below for xapi-stunnel-ca-bundle for additional certificates that
can be added to a pool in support of a user-supplied host certificate.</li><li><code>xe reset-server-certificate</code> creates a new self-signed certificate.</li></ul><h3 id=xapi-pool-tlspem><code>xapi-pool-tls.pem</code></h3><p>This certificate identifies a host inside a pool. It is auto generated
and used for all intra-pool HTTPS connections. It needs to be
distributed inside a pool to establish trust. The distribution of the
public part of the certificate is performed by the API and must not be
done manually.</p><ul><li>/etc/xensource/xapi-pool-tls.pem</li><li>contains private and public key for this host</li><li>referenced by /etc/stunnel/xapi.conf</li><li>This certificate can be re-generated using the API or XE</li><li><code>Host.refresh_server_certificate</code></li><li><code>xe host-refresh-server-certificate</code></li></ul><h2 id=certificate-bundles>Certificate Bundles</h2><p>Certifiacte bundles are used by stunnel. They are a collection of public
keys from hosts and certificates provided by a user. Knowing a host&rsquo;s
public key facilitates stunnel connecting to the host.</p><p>Bundles by themselves are a technicality as they organise a set of
certificates in a single file but don&rsquo;t add new certificates.</p><h3 id=xapi-pool-ca-bundlepem-and-certs-poolpem><code>xapi-pool-ca-bundle.pem</code> and <code>certs-pool/*.pem</code></h3><p>Collection of public keys from xapi-pool-tls.pem across the
pool. The public keys are collected in the certs-pool directory: each is
named after the UUID of its host and the bundle is constructed from
them.</p><ul><li>bundle of public keys from hosts&rsquo; <code>xapi-pool-tls.pem</code></li><li>constructed from PEM files in <code>certs-pool/</code></li><li><code>/opt/xensource/bin/update-ca-bundle.sh</code> generates the bundle from PEM
files</li></ul><h3 id=xapi-stunnel-ca-bundlepem-and-certspem><code>xapi-stunnel-ca-bundle.pem</code> and <code>certs/*.pem</code></h3><p>User-supplied certificates; they are not essential for the operation of
a pool from Xapi&rsquo;s perspective. They make stunnel aware of certificates
used by clients when using HTTPS for API calls.</p><ul><li>in a plain pool installation, these are empty; PEMs supplied by a user
are stored here and bundled into the <code>xapi-stunnerl-ca-bundle.pem</code>.</li><li>bundle of public keys supploed by a user</li><li>constructed from PEM files in <code>certs/</code></li><li><code>/opt/xensource/bin/update-ca-bundle.sh</code> generates the bundle from PEM files</li><li>Updated by a user using <code>xe pool-install-ca-certificate</code></li><li><code>Pool.install_ca_certificate</code></li><li><code>Pool.uninstall_ca_certificate</code></li><li><code>xe pool-certificate-sync</code> explicitly distribute these certificates in
the pool.</li><li>User-provided certificates can be used to let xapi connect to WLB.</li></ul><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=generated-parts-of-xapi>Generated Parts of Xapi</h1><h2 id=introduction>Introduction</h2><p>Many parts of <code>xapi</code> are auto-generated during the build process.
This article aims to document some of these modules and how they relate to each
other. The intention of this article is to serve as a developer resource and,
as such, its contents are prone to change (or become inaccurate) as the
codebase evolves. The ultimate source of truth remains the codebase itself.</p><h2 id=interface-description>Interface Description</h2><p>All of XenAPI&rsquo;s data model is described within the <code>ocaml/idl</code> subdirectory.
The data model itself describes the classes that make up the API.
The classes themselves comprise fields and messages (methods), relating
functionality together.</p><h2 id=api-types-apiml>API Types (<code>aPI.ml</code>)</h2><p>The internal representation of each object is a record whose type is specified
within the generated <code>API</code> module, as part of building <code>xapi-types</code>. For
example, the <code>task</code> object&rsquo;s structure is defined by the type <code>task_t</code>.
Similarly, <code>API</code> includes the internal type representation used to represent
fields. For example, a type such as <code>(string -> vdi_operations) map</code>, used by
the data model, is defined as <code>(string * vdi_operations) list</code> within <code>API</code>
(where <code>vdi_operations</code> itself is a polymorphic variant also defined by
<code>API</code>).</p><p>Note that the all the type definitions within <code>API</code> are annotated with
<code>[@@deriving rpc]</code>. This ensures that the final module, after preprocessing,
also contains functions to marshal each type to/from <code>Rpc.t</code> values (which is
important for <code>Server</code> - described later - which receives that format as
input).</p><h2 id=database-actions-db_actionsml>Database Actions (<code>db_actions.ml</code>)</h2><p>The majority of XenAPI consists of methods used to read and modify the fields
of objects in the database. These methods are automatically generated and
their implementations are placed within the generated <code>Db_actions</code> module.</p><p>The <code>Db_actions</code> module consists of various, related, parts: type definitions
for a subset of objects&rsquo; fields, marshallers for converting API types to/from
strings, and database action handlers. Briefly, the role of each of these is
described below:</p><ul><li><p>Type definitions for XenAPI objects are redefined in <code>Db_actions</code> in order to
exclude internal fields. If a field is marked as &ldquo;internal only&rdquo; within the
data model, then it should only exist within internal representations (those
defined by <code>API</code>, described above). For example, <code>task_t</code> (describing a
<code>task</code> object) - as described by <code>Db_actions</code> - notably omits the field
<code>task_session</code> (of type <code>session ref</code>) so as to not leak sensitive information
to clients (in this case, the reference to the session that created the task
object).</p></li><li><p>Fields of the database are internally stored as strings and must be
marshalled to typed values for use in OCaml code using DB actions. To this
end, submodules <code>String_to_DM</code> and <code>DM_to_String</code> are generated to include code
for doing these conversions. These submodules consist of the inverse
operations of the other. For example, for the data model type <code>Observer ref set</code>, the function <code>ref_Observer_set</code> exists in both <code>String_to_DM</code>
(as <code>string -> [`Observer] API.Ref.t list</code>) and
in <code>DM_to_String</code> (inversely, as <code>[`Observer] API.Ref.t list -> string</code>).</p></li><li><p>Handlers for actions that read/write fields of database objects are
implemented by <code>Db_actions</code>. Each handler uses the relevant marshallers to
marshal inputs and outputs. Note that <code>Db_actions</code> generates two variants of
<code>get_record</code> for each class: a normal <code>get_record</code> which returns the public
class representation as described by the types defined in <code>Db_actions</code>, and a
<code>get_record_internal</code>, which returns the full class representation (including
internal fields) as described by the <code>API</code> module.</p></li></ul><h3 id=registering-for-snapshots>Registering for Snapshots</h3><p>The <code>Db_actions</code> module also generates modules that register callbacks
for Xapi&rsquo;s event mechanisms. These modules are named in the format
<code>Class_init</code> and consist only of top-level code, evaluated for its
effect.</p><p>As each event must provide a snapshot of the related object, the event
mechanism must be able to read records from the database. To do this,
<code>Eventgen</code> exposes an API that <code>Db_actions</code> uses to register callbacks
(one for each type of object in the database).</p><p>For example, within <code>Db_actions</code>, there is a module <code>VM_init</code>,
consisting of:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>VM_init</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#f92672>_</span>  <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    Hashtbl.add Eventgen.get_record_table <span style=color:#e6db74>&#34;VM&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> API.rpc_of_vM_t <span style=color:#f92672>(</span>VM.get_record <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:(</span>Ref.of_string self<span style=color:#f92672>))))</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span></span></span></code></pre></div><p>As snapshots are served to external clients, the functions use the
public <code>get_record</code> functions - returning types defined by <code>API</code> -
which omits internal fields.</p><p>Notice that the type of values being mapped to is <code>__context:Context.t -> self:string -> unit -> Rpc.t</code>.</p><p>The presence of <code>unit</code> in the type is to permit partial application
(of <code>__context</code> and <code>self</code>) to create thunks. The type <code>unit -> Rpc.t</code>
is lossy, it says nothing about the context or object reference being
used to fetch the snapshot; these details are captured by the closure
arising from partial application. This means that code can arbitrarily
delay the fetching of a snapshot and then &ldquo;force&rdquo; it (on demand)
later. In practice, these snapshots are not delayed for long, see
<code>Eventgen</code> for more information.</p><h2 id=custom-actions-custom_actionsml>Custom Actions (<code>custom_actions.ml</code>)</h2><p>The API operations that require a custom implementation (i.e. are not
automatically generated) are grouped together into a signature called
<code>CUSTOM_ACTIONS</code> within <code>custom_actions.ml</code>.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>open</span> <span style=color:#a6e22e>API</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CUSTOM_ACTIONS</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>sig</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Session</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>sig</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> login_with_password <span style=color:#f92672>:</span> <span style=color:#f92672>__</span>context<span style=color:#f92672>:</span>Context.t <span style=color:#f92672>-&gt;</span> uname<span style=color:#f92672>:</span><span style=color:#66d9ef>string</span> <span style=color:#f92672>-&gt;</span> pwd<span style=color:#f92672>:</span><span style=color:#66d9ef>string</span> <span style=color:#f92672>-&gt;</span> version<span style=color:#f92672>:</span><span style=color:#66d9ef>string</span> <span style=color:#f92672>-&gt;</span> originator<span style=color:#f92672>:</span><span style=color:#66d9ef>string</span> <span style=color:#f92672>-&gt;</span> ref_session
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> logout <span style=color:#f92672>:</span> <span style=color:#f92672>__</span>context<span style=color:#f92672>:</span>Context.t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>unit</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* ... *)</span></span></span></code></pre></div><p>The isolation of these methods into their own signature is important for
ensuring implementations exist for them.</p><p>The <code>Actions</code> submodule of <code>Api_server_common</code> can be ascribed
this signature. The purpose of the <code>Actions</code> sub-module is to group custom
implementations together whilst renaming them using module aliases. For
example, the custom implementations of messages associate with the <code>task</code> class
exist within <code>xapi_task.ml</code> - the module arising from this file is aliased,
within <code>Actions</code>, to rename it and satisfy the <code>CUSTOM_ACTIONS</code> signature (e.g.
<code>module Task = Xapi_task</code>).</p><p>The signature is not explicitly ascribed to <code>Actions</code> at its definition site,
but is used by functors which are parameterised by modules satisfying
<code>CUSTOM_ACTIONS</code>. The important modules of note are <code>Actions</code> itself (which
comprise the concrete implementations of custom messages in Xapi) and the
<code>Forwarder</code> sub-module (of <code>Api_server_common</code>) which uses the
<code>Message_forwarding.Forward</code> functor to potentially override (via shadowing)
the implementations of custom actions, in order to define policies around
forwarding (e.g. whether the coordinator should handle a custom action by
appealing to a subordinate host, usually via the <code>Client</code> module - described
later).</p><h2 id=server-serverml>Server (<code>server.ml</code>)</h2><p>The <code>Server</code> modules contains the logic to handle incoming calls from Xapi&rsquo;s
HTTP server. At the top level, it contains a functor (parameterised by <code>Local</code>
and <code>Forward</code> - both satisfying the <code>CUSTOM_ACTIONS</code> signature), that contains a
large pattern match on the name of the supplied message (e.g.
<code>Host.get_record</code>). Then, dependent on the semantics of the message itself, the
body of each handler differs in slight ways when doing dispatch.</p><h3 id=the-top-level-dispatch_call-function>The top-level <code>dispatch_call</code> function</h3><p>The top-level dispatch function, <code>dispatch_call</code>, has the following header:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> dispatch_call <span style=color:#f92672>(</span>http_req<span style=color:#f92672>:</span> Http.Request.t<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>fd<span style=color:#f92672>:</span> Unix.file_descr<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>call<span style=color:#f92672>:</span> Rpc.call<span style=color:#f92672>)</span> <span style=color:#f92672>=</span></span></span></code></pre></div><p>The incoming HTTP request (<code>http_req</code>) and - related - socket&rsquo;s file descriptor
(<code>Unix.file_descr)</code> are forwarded - within handler code - to
<code>Server_helpers.do_dispatch</code>. The HTTP request is important because task and
tracing-related metadata can be propagated using fields within the request
header. The file descriptor can be used to determine the origin of the request
(whether it&rsquo;s local or not) but also can permit flexibility in upgrading
protocols (as is done in other parts of Xapi, such as the <code>/cli</code> handler, where
the connection starts off as HTTP but continues as something else).</p><h3 id=the-anatomy-of-a-handler>The Anatomy of a Handler</h3><p>A typical handler, within <code>dispatch_call</code>, looks like the following:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;task.get_name_label&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;task_get_name_label&#34;</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>begin</span> <span style=color:#66d9ef>match</span> <span style=color:#f92672>__</span>params <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#f92672>[</span>session_id_rpc<span style=color:#f92672>;</span> self_rpc<span style=color:#f92672>]</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>(* has no side-effect; should be handled by DB action *)</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>(* has no asynchronous mode *)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> session_id <span style=color:#f92672>=</span> ref_session_of_rpc session_id_rpc <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> self <span style=color:#f92672>=</span> ref_task_of_rpc self_rpc <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            Session_check.check <span style=color:#f92672>~</span>intra_pool_only<span style=color:#f92672>:</span>false <span style=color:#f92672>~</span>session_id <span style=color:#f92672>~</span>action<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;task.get_name_label&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> arg_names_values <span style=color:#f92672>=</span> <span style=color:#f92672>[(</span><span style=color:#e6db74>&#34;session_id&#34;</span><span style=color:#f92672>,</span> session_id_rpc<span style=color:#f92672>);</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;self&#34;</span><span style=color:#f92672>,</span> self_rpc<span style=color:#f92672>)]</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> key_names <span style=color:#f92672>=</span> [] <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> rbac <span style=color:#f92672>__</span>context fn <span style=color:#f92672>=</span> Rbac.check session_id <span style=color:#f92672>__</span>call <span style=color:#f92672>~</span>args<span style=color:#f92672>:</span>arg_names_values <span style=color:#f92672>~</span>keys<span style=color:#f92672>:</span>key_names <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>fn <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> marshaller <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> rpc_of_string x<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> local_op <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> <span style=color:#f92672>~__</span>context <span style=color:#f92672>-&gt;(</span>rbac <span style=color:#f92672>__</span>context <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span>()<span style=color:#f92672>-&gt;(</span>Db_actions.DB_Action.Task.get_name_label <span style=color:#f92672>~__</span>context<span style=color:#f92672>:(</span>Context.check_for_foreign_database <span style=color:#f92672>~__</span>context<span style=color:#f92672>)</span>  <span style=color:#f92672>~</span>self<span style=color:#f92672>)))</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> supports_async <span style=color:#f92672>=</span> false <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> generate_task_for <span style=color:#f92672>=</span> false <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            ApiLogRead.debug <span style=color:#e6db74>&#34;task.get_name_label&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> resp <span style=color:#f92672>=</span> Server_helpers.do_dispatch <span style=color:#f92672>~</span>session_id  supports_async <span style=color:#f92672>__</span>call local_op marshaller fd http_req <span style=color:#f92672>__</span>label <span style=color:#f92672>__</span>sync_ty generate_task_for <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            resp
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            Server_helpers.parameter_count_mismatch_failure <span style=color:#f92672>__</span>call <span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#f92672>(</span>string_of_int <span style=color:#f92672>((</span>List.length <span style=color:#f92672>__</span>params<span style=color:#f92672>)</span> <span style=color:#f92672>-</span> 1<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span></span></span></code></pre></div><p>The start of each handler contains calls to unmarshal arguments from their
<code>Rpc.t</code> representation to that defined by the <code>API</code> module. These functions are
automatically generated during preprocessing of the <code>aPI.ml</code> file (<code>API</code>
modules from <code>xapi-types</code>, described above). The conversion from the incoming
XML-RPC (or JSON-RPC) to the <code>Rpc.t</code> encoding is handled by <code>Api_server</code> before
it calls <code>dispatch_call</code>.</p><p>In the example above, the &ldquo;local&rdquo; operation (<code>local_op</code>) uses handlers
generated within <code>Db_actions</code> (described above). This is typical of handlers
for DB-related actions (the most common type of action): they have no
forwarding logic (thus, no entry in the <code>CUSTOM_ACTIONS</code> signature) as they can
only be carried out on the coordinator host (which maintains the database). If
a subordinate host wishes to change the database, it must use a custom endpoint
and protocol (not described here).</p><hr><p>To see more about how the <code>CUSTOM_ACTIONS</code> signature is used in practice, you
can look at the &ldquo;local&rdquo; and &ldquo;forward&rdquo; operations for a message with custom
handling. For example, in <code>Pool_patch.apply</code>:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* ... *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> local_op <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> <span style=color:#f92672>~__</span>context <span style=color:#f92672>-&gt;(</span>rbac <span style=color:#f92672>__</span>context <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span>()<span style=color:#f92672>-&gt;(</span>Custom.Pool_patch.apply <span style=color:#f92672>~__</span>context<span style=color:#f92672>:(</span>Context.check_for_foreign_database <span style=color:#f92672>~__</span>context<span style=color:#f92672>)</span>  <span style=color:#f92672>~</span>self <span style=color:#f92672>~</span>host<span style=color:#f92672>)))</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* ...  *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> forward_op <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> <span style=color:#f92672>~</span>local_fn <span style=color:#f92672>~__</span>context <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span>rbac <span style=color:#f92672>__</span>context <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span>()<span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span>Forward.Pool_patch.apply <span style=color:#f92672>~__</span>context<span style=color:#f92672>:(</span>Context.check_for_foreign_database <span style=color:#f92672>~__</span>context<span style=color:#f92672>)</span>  <span style=color:#f92672>~</span>self <span style=color:#f92672>~</span>host<span style=color:#f92672>)</span> <span style=color:#f92672>))</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* ...  *)</span></span></span></code></pre></div><p>As mentioned above, the <code>Custom</code> and <code>Forward</code> modules are both inputs
to <code>Server</code>&rsquo;s <code>Make</code> functor. The difference lies in how they are
instantiated: <code>Api_server</code> ensures that <code>Custom</code> is referring to local
implementations (such as that arising from modules defined by files
named <code>xapi_*.ml</code>) and <code>Forward</code> is referring to the module derived by
<code>Message_forwarding</code> (but shadowed with implementations that may apply
different handling to the call).</p><h3 id=rbac-checking-and-auditing>RBAC Checking and Auditing</h3><p>In order to implement RBAC (Role Based Access Control) checking for individual
messages, each handler contains logic that wraps an action (as a callback)
within code that calls into the <code>Rbac</code> module (specifically, the <code>Rbac.check</code>
function).</p><p>In the typical case, <code>Rbac.check</code> compares the name of a call against the list
of RBAC permissions granted to the role associated with the originator&rsquo;s
session/context. There is more involved logic for key-related RBAC checks
(explained later).</p><p>For an accessible listing of each (static) RBAC permission, Xapi auto-generates
a CSV file containing this information in a tabular format (within
<code>rbac_static.csv</code>). The information in that file is consistent with the
auto-generated <code>Rbac_static</code> module described in this document.</p><p>Along with providing authorisation checking, the <code>Rbac.check</code> function also
appends to an audit log which contains a (sanitised) list of actions (alongside
their RBAC check outcome).</p><h3 id=rbac-checking-of-keys>RBAC Checking of Keys</h3><p>In auto-generated handlers for <code>add_to</code> and <code>remove_from</code> messages (e.g.
<code>pool.add_to_other_config</code>), the RBAC check may cite a list of key
descriptors. For example:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* pool.add_to_other_config ...  *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> arg_names_values <span style=color:#f92672>=</span> <span style=color:#f92672>[(</span><span style=color:#e6db74>&#34;session_id&#34;</span><span style=color:#f92672>,</span> session_id_rpc<span style=color:#f92672>);</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;self&#34;</span><span style=color:#f92672>,</span> self_rpc<span style=color:#f92672>);</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;key&#34;</span><span style=color:#f92672>,</span> key_rpc<span style=color:#f92672>);</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;value&#34;</span><span style=color:#f92672>,</span> value_rpc<span style=color:#f92672>)]</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> key_names <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;folder&#34;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#34;XenCenter.CustomFields.*&#34;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#34;EMPTY_FOLDERS&#34;</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> rbac <span style=color:#f92672>__</span>context fn <span style=color:#f92672>=</span> Rbac.check session_id <span style=color:#f92672>__</span>call <span style=color:#f92672>~</span>args<span style=color:#f92672>:</span>arg_names_values <span style=color:#f92672>~</span>keys<span style=color:#f92672>:</span>key_names <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>fn <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* ... *)</span></span></span></code></pre></div><p>These keys are specified within the data model as being tied to specific roles,
in order to apply role-based exclusions to specific keys. The usual situation
is that the setter for such a <code>(string -> string) map</code> field (e.g.
<code>pool.set_other_config</code>) requires a more privileged role than the roles
specified for individual keys.</p><p>The mechanism that enforces this check is somewhat brittle at present: the
<code>Rbac.check</code> function is provided the list of key descriptors and the
(association) list of (unmarshalled) arguments. If the key descriptor list is
non-empty, it will consult the argument listing for the cited key (i.e. the key
name mapped to by &ldquo;key&rdquo; in the argument listing) and then attempt to match that
against a descriptor. If there is a match, it will check the current session
against the list of RBAC permissions. The key-related RBAC permissions are
encoded in the format <code>action/key:key</code> (all lowercase) - for example,
<code>pool.add_to_other_config/key:xencenter.customfields.*</code>.</p><h3 id=alternative-wire-names>Alternative Wire Names</h3><p>In order to support languages that have keywords that collide with message
names within Xapi, an alternative wire format is also cased upon within
<code>dispatch_call</code>.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;task.get_name_label&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;task_get_name_label&#34;</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* ... *)</span></span></span></code></pre></div><p>For example, Python uses the keyword <code>from</code> to handle imports and, so, an API
call (using <code>xmlrpc.client</code>) - rendered as <code>event.from</code> - is a syntactic error.
To get around this, the API permits an underscore to be substituted in place of
the period (<code>.</code>) that separates the class name from the message name (e.g.
<code>event_from</code>).</p><p>This apparent duplication of cases does not amount to a concrete duplication of
matching code within the compiled module (due to how OCaml special cases the
compilation of pattern matching over constant strings). However, in future, we
could avoid casing on both of them by normalising the name of the incoming call
(i.e. transform <code>event.from</code> to <code>event_from</code> prior to matching).</p><h2 id=client-clientml>Client (<code>client.ml</code>)</h2><p>The <code>Client</code> module serves as the main module of the <code>xapi-client</code> library. The
primary consumer of this library is Xapi itself, for use when a host may call
into another host (or itself).</p><p>For example, when defining a message forwarding policy, the implementation of a
handler may use the <code>Client</code> module to invoke a function on another host. For
instance, the message forwarding of <code>Pool_patch.apply</code> (from
<code>xapi/message_forwarding.ml</code>):</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> apply <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self <span style=color:#f92672>~</span>host <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  info <span style=color:#e6db74>&#34;Pool_patch.apply: pool patch = &#39;%s&#39;; host = &#39;%s&#39;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>(</span>pool_patch_uuid <span style=color:#f92672>~__</span>context self<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>(</span>host_uuid <span style=color:#f92672>~__</span>context host<span style=color:#f92672>)</span> <span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> local_fn <span style=color:#f92672>=</span> Local.Pool_patch.apply <span style=color:#f92672>~</span>self <span style=color:#f92672>~</span>host <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  do_op_on <span style=color:#f92672>~</span>local_fn <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>host <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> session_id rpc <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    Client.Pool_patch.apply <span style=color:#f92672>~</span>rpc <span style=color:#f92672>~</span>session_id <span style=color:#f92672>~</span>self <span style=color:#f92672>~</span>host
</span></span><span style=display:flex><span>  <span style=color:#f92672>)</span></span></span></code></pre></div><p>The <code>do_op_on</code> machinery provides the <code>rpc</code> transport (<code>Rpc.call -> Rpc.response</code>) to the callback which passes it to <code>Client</code>&rsquo;s implementation
(which just performs the relevant marshalling). The RPC transport itself is
XML-RPC over HTTP (as implemented by the internal <code>http-lib</code> library -
<code>ocaml/libs/http-lib</code>).</p><h3 id=client-internals>Client Internals</h3><p>Internally, the <code>Client</code> module contains a few functors. The top-level functor,
<code>ClientF</code> is parameterised by a signature describing an arbitrary monad. The
intention is to permit users to instantiate clients defined in terms of an RPC
transport that may be asynchronous (for example, within the context of a
program using <code>Lwt</code> or <code>Async</code> for its networking).</p><p>There is also a sub-functor <code>AsyncF</code> (within <code>ClientF</code>) that is parameterised
by a module that provides a qualifier string to be prepended to calls&rsquo; method
names. A few messages in Xapi can be qualified with async qualifiers (in
particular, <code>Async</code> and <code>InternalAsync</code>). The <code>AsyncF</code> functor provides
handling of those calls and is used to define the sub-modules (within
<code>ClientF</code>) <code>Async</code> and <code>InternalAsync</code>. (the former prepending <code>Async</code> and the
latter further prepending <code>Internal</code>). Code at the top-level of <code>Server</code>&rsquo;s
<code>dispatch_call</code> function is used to parse (and remove) this async qualifier
from the provided message name.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>ClientF</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>functor</span><span style=color:#f92672>(</span><span style=color:#a6e22e>X</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>IO</span><span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span><span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* ... *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>AsyncF</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>functor</span><span style=color:#f92672>(</span><span style=color:#a6e22e>AQ</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>AsyncQualifier</span><span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span><span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* handling of messages with asynchronous modes *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Session</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> create_from_db_file <span style=color:#f92672>~</span>rpc <span style=color:#f92672>~</span>session_id <span style=color:#f92672>~</span>filename <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> session_id <span style=color:#f92672>=</span> rpc_of_ref_session session_id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> filename <span style=color:#f92672>=</span> rpc_of_string filename <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        rpc_wrapper rpc <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;%sAsync.session.create_from_db_file&#34;</span> AQ.async_qualifier<span style=color:#f92672>)</span> <span style=color:#f92672>[</span> session_id<span style=color:#f92672>;</span> filename <span style=color:#f92672>]</span> <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> return <span style=color:#f92672>(</span>ref_task_of_rpc  x<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(* ... *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* ...  *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* handling of messages with synchronous modes; similar to above, but without prefixing of &#34;Async&#34; *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Async</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>AsyncF</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> async_qualifier <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>InternalAsync</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>AsyncF</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> async_qualifier <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Internal&#34;</span> <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* instantiate Client with the identity monad *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Client</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ClientF</span><span style=color:#f92672>(</span><span style=color:#a6e22e>Id</span><span style=color:#f92672>)</span></span></span></code></pre></div><p>The usual <code>Client</code> module used by users of <code>xapi-client</code> is the <code>Client</code>
sub-module, defined in terms of the identity monad (which simply applies the
given continuation as its sequencing logic and performs no wrapping):</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Id</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>=</span> <span style=color:#66d9ef>&#39;</span>a
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> bind x f <span style=color:#f92672>=</span> f x 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> return x <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Client</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ClientF</span><span style=color:#f92672>(</span><span style=color:#a6e22e>Id</span><span style=color:#f92672>)</span></span></span></code></pre></div><p>This results in synchronous semantics, whereby any code within <code>Xapi</code> that uses
it would block as it waits for a response via the RPC transport. This is not an
issue in practice, as each call is given its own thread during the dispatch logic.</p><p>Note that the RPC transport itself is defined in terms of the provided monad.
In the identity case, it&rsquo;s a simple alias, and so the type of <code>rpc</code> is rendered
<code>Rpc.call -> Rpc.response</code>. However, if you were to provide a monad defined,
for example, in terms of <code>Lwt.t</code> (i.e. <code>type 'a t = 'a Lwt.t</code>), the expected
type of the transport would reflect that: <code>Rpc.call -> Rpc.response Lwt.t</code>.</p><h2 id=rbac_static>Rbac_static</h2><p>The data model assigns specific roles to messages and fields. In order
to permit RBAC (Role Based Access Control) checking for the related
actions, Xapi must be able to determine the required role(s) for a
given action. To this end, <code>Rbac_static</code> is generated to contain
entries that encode this information.</p><p>The format of the entries in <code>Rbac_static</code> is rather peculiar. For
example, for the action <code>Pool_patch.apply</code>, we find
<code>permission_pool_patch_apply</code> defined at the top-level:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> permission_pool_patch_apply <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>  <span style=color:#f92672>{</span> <span style=color:#75715e>(* 311/2196 *)</span>
</span></span><span style=display:flex><span>  role_uuid <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;d4385002-b920-5412-4c57-b010f451fa81&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  role_name_label <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;pool_patch.apply&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  role_name_description <span style=color:#f92672>=</span> permission_description<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  role_subroles <span style=color:#f92672>=</span> []<span style=color:#f92672>;</span> <span style=color:#75715e>(* permission cannot have any subroles *)</span>
</span></span><span style=display:flex><span>  role_is_internal <span style=color:#f92672>=</span> true<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span></span></span></code></pre></div><p>This record is of type <code>role_t</code> (as defined by <code>Db_actions</code>). This
record is later incorporated into role-specific lists of permissions
(for each statically known role).</p><p>The reason that <code>Rbac_static</code> defines permissions in a format defined
by <code>Db_actions</code> is because, to avoid flooding the database with
thousands of entries, <code>Rbac_static</code> acts as its own database. In
<code>Xapi_role</code>, functions are defined that mirror the functionality of
functions within <code>Db_actions</code> (e.g. <code>get_by_uuid</code>).</p><p>The <code>get_by_uuid</code> function (within <code>Xapi_role</code>) illustrates the bypassing of the database clearly:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> get_by_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>uuid <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>match</span> find_role_by_uuid uuid <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> static_record <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      ref_of_role <span style=color:#f92672>~</span>role<span style=color:#f92672>:</span>static_record
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* pass-through to Db *)</span>
</span></span><span style=display:flex><span>      Db.Role.get_by_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>uuid</span></span></code></pre></div><p>If a role can be found (by UUID) statically (within <code>Rbac_static</code>),
then that is used. Otherwise, the database is queried. Using the
database as a fallback is important because there is still a dynamic
component to the RBAC checking in Xapi: users can define their own
roles that incorporate other roles as sub-roles - it&rsquo;s just that
the statically-known roles won&rsquo;t be stored in the database. Precluding
static roles from the database helps to avoid making the database
larger and prevents users from deleting static roles from the
database.</p><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=host-memory-accounting>Host memory accounting</h1><p>Memory is used for many things:</p><ul><li>the hypervisor code: this is the Xen executable itself</li><li>the hypervisor heap: this is needed for per-domain structures and per-vCPU
structures</li><li>the crash kernel: this is needed to collect information after a host crash</li><li>domain RAM: this is the memory the VM believes it has</li><li>shadow memory: for HVM guests running on hosts without hardware assisted
paging (HAP) Xen uses shadow to optimise page table updates. For all guests
shadow is used during live migration for tracking the memory transfer.</li><li>video RAM for the virtual graphics card</li></ul><p>Some of these are constants (e.g. hypervisor code) while some depend on the VM
configuration (e.g. domain RAM). Xapi calls the constants &ldquo;host overhead&rdquo; and
the variables due to VM configuration as &ldquo;VM overhead&rdquo;. There is no low-level
API to query this information, therefore xapi will sample the host overheads
at system boot time and model the per-VM overheads.</p><h2 id=host-overhead>Host overhead</h2><p>The host overhead is not managed by xapi, instead it is sampled. After the host
boots and before any VMs start, xapi asks Xen how much memory the host has in
total, and how much memory is currently free. Xapi subtracts the free from the
total and stores this as the host overhead.</p><h2 id=vm-overhead>VM overhead</h2><p>The inputs to the model are</p><ul><li><code>VM.memory_static_max</code>: the maximum amount of RAM the domain will be able to use</li><li><code>VM.HVM_shadow_multiplier</code>: allows the shadow memory to be increased</li><li><code>VM.VCPUs_max</code>: the maximum number of vCPUs the domain will be able to use</li></ul><p>First the shadow memory is calculated, in MiB</p><p><img alt="Shadow memory in MiB" class="noborder lazy nolightbox shadow figure-image" loading=lazy src=/new-docs/xapi/memory/shadow.svg style=height:auto;width:auto></p><p>Second the VM overhead is calculated, in MiB</p><p><img alt="Memory overhead in MiB" class="noborder lazy nolightbox shadow figure-image" loading=lazy src=/new-docs/xapi/memory/overhead.svg style=height:auto;width:auto></p><h2 id=memory-required-to-start-a-vm>Memory required to start a VM</h2><p>If ballooning is disabled, the memory required to start a VM is the same as the VM
overhead above.</p><p>If ballooning is enabled then the memory calculation above is modified to use the
<code>VM.memory_dynamic_max</code> rather than the <code>VM.memory_static_max</code>.</p><h2 id=memory-required-to-migrate-a-vm>Memory required to migrate a VM</h2><p>If ballooning is disabled, the memory required to receive a migrating VM is the same
as the VM overhead above.</p><p>If ballooning is enabled, then the VM will first be ballooned down to <code>VM.memory_dynamic_min</code>
and then it will be migrated across. If the VM fails to balloon all the way down, then
correspondingly more memory will be required on the receiving side.</p><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapis-storage-layers>XAPI's Storage Layers</h1><details open class="box cstyle notices info"><summary class=box-label tabindex=-1><i class="fa-fw fas fa-info-circle"></i>
Info</summary><div class=box-content><p>The links in this page point to the source files of xapi
<a href=https://github.com/xapi-project/xen-api/tree/v25.11.0 rel=external target=_blank>v25.11.0</a>.</p></div></details><p>Xapi directly communicates only with the SMAPIv2 layer. There are no
plugins directly implementing the SMAPIv2 interface, but the plugins in
other layers are accessed through it:</p><pre class="mermaid align-center">graph TD
A[xapi] --&gt; B[SMAPIv2 interface]
B --&gt; C[SMAPIv2 &lt;-&gt; SMAPIv1 state machine: storage_smapiv1_wrapper.ml]
C --&gt; G[SMAPIv2 &lt;-&gt; SMAPIv1 translation: storage_smapiv1.ml]
B --&gt; D[SMAPIv2 &lt;-&gt; SMAPIv3 translation: xapi-storage-script]
G --&gt; E[SMAPIv1 plugins]
D --&gt; F[SMAPIv3 plugins]</pre><h2 id=smapiv1>SMAPIv1</h2><p>These are the files related to SMAPIv1 in <a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi rel=external target=_blank><code>/ocaml/xapi/</code></a>:</p><ul><li><a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/sm.ml rel=external target=_blank><code>sm.ml</code></a>:
OCaml &ldquo;bindings&rdquo; for the SMAPIv1 Python &ldquo;drivers&rdquo; (SM)</li><li><a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/sm_exec.ml rel=external target=_blank><code>sm_exec.ml</code></a>:
support for implementing the above &ldquo;bindings&rdquo;.
The parameters are converted to XML-RPC, passed to the relevant python script (&ldquo;driver&rdquo;),
and then the standard output of the program is parsed as an XML-RPC response (we use
<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/libs/http-lib/xMLRPC.ml rel=external target=_blank><code>ocaml/libs/http-lib/xMLRPC.ml</code></a>
for parsing XML-RPC).
When adding new functionality, we can modify <code>type call</code> to add parameters,
but when we don&rsquo;t add any common ones, we should just pass the new
parameters in the args record.</li><li><a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/smint.ml rel=external target=_blank><code>smint.ml</code></a>:
Contains types, exceptions, &mldr; for the SMAPIv1 OCaml interface.</li><li><a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_smapiv1_wrapper.ml rel=external target=_blank><code>storage_smapiv1_wrapper.ml</code></a>:
The <a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_smapiv1_wrapper.ml#L360 rel=external target=_blank><code>Wrapper</code></a>
module wraps a SMAPIv2 server (<code>Server_impl</code>) and takes care of
locking and datapaths (in case of multiple connections (=datapaths)
from VMs to the same VDI, using a state machine for SMAPIv1 operations.
It will use the superstate computed by the
<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi-idl/storage/vdi_automaton.ml rel=external target=_blank><code>vdi_automaton.ml</code></a>
in xapi-idl) to compute the required actions to reach the desired state from the current one.
It also implements some functionality, like the <code>DP</code> module, that is not implemented in lower layers.</li><li><a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_smapiv1.ml rel=external target=_blank><code>storage_smapiv1.ml</code></a>:
a SMAPIv2 server that translates SMAPIv2 calls to SMAPIv1 ones, by calling
<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/sm.ml rel=external target=_blank><code>ocaml/xapi/sm.ml</code></a>.
It calls passes the XML-RPC requests as the first command-line argument to the
corresponding Python script, which returns an XML-RPC response on standard
output.</li></ul><h2 id=smapiv2>SMAPIv2</h2><p>These are the files related to SMAPIv2, which need to be modified to
implement new calls:</p><ul><li><a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi-idl/storage/storage_interface.ml rel=external target=_blank><code>ocaml/xapi-idl/storage/storage_interface.ml</code></a>:
Contains the SMAPIv2 interface</li><li><a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi-idl/storage/storage_skeleton.ml rel=external target=_blank><code>ocaml/xapi-idl/storage/storage_skeleton.ml</code></a>:
A stub SMAPIv2 storage server implementation that matches the
SMAPIv2 storage server interface (this is verified by
<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi-idl/storage/storage_skeleton_test.ml rel=external target=_blank><code>storage_skeleton_test.ml</code></a>),
each of its function just raise a <code>Storage_interface.Unimplemented</code>
error. This skeleton is used to automatically fill the unimplemented
methods of the below storage servers to satisfy the interface.</li><li><a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_mux.ml rel=external target=_blank><code>ocaml/xapi/storage_mux.ml</code></a>:
A SMAPIv2 server, which multiplexes between other servers. A
different SMAPIv2 server can be registered for each SR. Then it
forwards the calls for each SR to the &ldquo;storage plugin&rdquo; registered
for that SR.</li><li><a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_smapiv1_wrapper.ml rel=external target=_blank><code>ocaml/xapi/storage_smapiv1_wrapper.ml</code></a>:
Implements a state machine to compute SMAPIv1 actions needed to reach the desired state, see <a href=/new-docs/xapi/storage/index.html#smapiv1>SMAPIv1</a>.</li><li><a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_smapiv1.ml rel=external target=_blank><code>ocaml/xapi/storage_smapiv1.ml</code></a>:
Translates the SMAPIv2 calls to SMAPIv1, see <a href=/new-docs/xapi/storage/index.html#smapiv1>SMAPIv1</a>.</li></ul><h3 id=how-smapiv2-works>How SMAPIv2 works:</h3><p>We use <a href=https://github.com/xapi-project/message-switch rel=external target=_blank>message-switch</a> under the hood for RPC communication between
<a href=https://github.com/xapi-project/xen-api/tree/v25.11.0/ocaml/xapi-idl rel=external target=_blank>xapi-idl</a> components. The
main <code>Storage_mux.Server</code> (basically <code>Storage_impl.Wrapper(Mux)</code>) is
<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_access.ml#L500 rel=external target=_blank>registered to
listen</a>
on the &ldquo;<code>org.xen.xapi.storage</code>&rdquo; queue <a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/xapi.ml#L1080 rel=external target=_blank>during xapi&rsquo;s
startup</a>,
and this is the main entry point for incoming SMAPIv2 function calls.
<code>Storage_mux</code> does not really multiplex between different plugins right
now: <a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/xapi.ml#L1076 rel=external target=_blank>earlier during xapi&rsquo;s
startup</a>,
the same SMAPIv1 storage server module <a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_access.ml#L934 rel=external target=_blank>is
registered</a>
on the various &ldquo;<code>org.xen.xapi.storage.&lt;sr type></code>&rdquo; queues for each
supported SR type. (This will change with SMAPIv3, which is accessed via
a SMAPIv2 plugin outside of xapi that translates between SMAPIv2 and
SMAPIv3.) Then, in
<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_access.ml#L802 rel=external target=_blank>Storage_access.create_sr</a>,
which is called
<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/xapi_sr.ml#L391 rel=external target=_blank>during SR.create</a>,
and also
<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/xapi_pbd.ml#L175 rel=external target=_blank>during PBD.plug</a>,
the relevant &ldquo;<code>org.xen.xapi.storage.&lt;sr type></code>&rdquo; queue needed for that
PBD is <a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_access.ml#L267 rel=external target=_blank>registered with Storage_mux in
Storage_access.bind</a>
for the SR of that PBD.<br>So basically what happens is that xapi registers itself as a SMAPIv2
server, and forwards incoming function calls to itself through
<code>message-switch</code>, using its <code>Storage_mux</code> module. These calls are
forwarded to xapi&rsquo;s <code>SMAPIv1</code> module doing SMAPIv2 -> SMAPIv1
translation.</p><h4 id=registration-of-the-various-storage-servers>Registration of the various storage servers</h4><pre class="mermaid align-center">sequenceDiagram
participant q as message-switch
participant v1 as Storage_smapiv1.SMAPIv1
participant svr as Storage_mux.Server

Note over q, svr: xapi startup, &#34;Starting SMAPIv1 proxies&#34;
q -&gt;&gt; v1:org.xen.xapi.storage.sr_type_1
q -&gt;&gt; v1:org.xen.xapi.storage.sr_type_2
q -&gt;&gt; v1:org.xen.xapi.storage.sr_type_3

Note over q, svr: xapi startup, &#34;Starting SM service&#34;
q -&gt;&gt; svr:org.xen.xapi.storage 

Note over q, svr: SR.create, PBD.plug
svr -&gt;&gt; q:org.xapi.storage.sr_type_2</pre><h4 id=what-happens-when-a-smapiv2-function-is-called>What happens when a SMAPIv2 &ldquo;function&rdquo; is called</h4><pre class="mermaid align-center">graph TD

call[SMAPIv2 call] --VDI.attach2--&gt; org.xen.xapi.storage

subgraph message-switch
org.xen.xapi.storage
org.xen.xapi.storage.SR_type_x
end

org.xen.xapi.storage --VDI.attach2--&gt; Storage_smapiv1_wrapper.Wrapper

subgraph xapi
subgraph Storage_mux.server
Storage_smapiv1_wrapper.Wrapper --&gt; Storage_mux.mux
end
Storage_smapiv1.SMAPIv1
end

Storage_mux.mux --VDI.attach2--&gt; org.xen.xapi.storage.SR_type_x
org.xen.xapi.storage.SR_type_x --VDI.attach2--&gt; Storage_smapiv1.SMAPIv1

subgraph SMAPIv1
driver_x[SMAPIv1 driver for SR_type_x]
end

Storage_smapiv1.SMAPIv1 --vdi_attach--&gt; driver_x</pre><h3 id=interface-changes-backward-compatibility--sxm>Interface Changes, Backward Compatibility, & SXM</h3><p>During SXM, xapi calls SMAPIv2 functions on a remote xapi. Therefore it
is important to keep all those SMAPIv2 functions backward-compatible
that we call remotely (e.g. Remote.VDI.attach), otherwise SXM from an
older to a newer xapi will break.</p><h3 id=functionality-implemented-in-smapiv2-layers>Functionality implemented in SMAPIv2 layers</h3><p>The layer between SMAPIv2 and SMAPIv1 is much fatter than the one between
SMAPIv2 and SMAPIv3. The latter does not do much, apart from simple
translation. However, the former has large portions of code in its intermediate
layers, in addition to the basic SMAPIv2 &lt;-> SMAPIv1 translation in
<code>storage_access.ml</code>.</p><p>These are the two files in xapi that implement the SMAPIv2 storage interface,
from higher to lower level:</p><ul><li><a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_mux.ml rel=external target=_blank>xen-api/ocaml/xapi/storage_mux.ml</a>:</li><li><a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_access.ml rel=external target=_blank>xen-api/ocaml/xapi/storage_access.ml</a>:</li></ul><p>Functionality implemented by higher layers is not implemented by the layers below it.</p><h4 id=extra-functionality-in-storage_taskml>Extra functionality in <code>storage_task.ml</code></h4><p><code>storage_smapiv1_wrapper.ml</code> also implements the <code>UPDATES</code> and <code>TASK</code> SMAPIv2 APIs. These are backed by the <code>Updates</code>, <code>Task_server</code>, and <code>Scheduler</code> modules from
xcp-idl, instantiated in xapi&rsquo;s <code>Storage_task</code> module. Migration code in
<code>Storage_mux</code> will interact with these to update task progress. There is also
an event loop in xapi that keeps calling <code>UPDATES.get</code> to keep the tasks in
xapi&rsquo;s database in sync with the storage manager&rsquo;s tasks.</p><p><code>Storage_smapiv1_wrapper.ml</code> also implements the legacy <code>VDI.attach</code> call by simply
calling the newer <code>VDI.attach2</code> call in the same module. In general, this is a
good place to implement a compatibility layer for deprecated functionality
removed from other layers, because this is the first module that intercepts a
SMAPIv2 call.</p><h4 id=extra-functionality-in-storage_muxml>Extra functionality in <code>storage_mux.ml</code></h4><p><code>Storage_mux</code> redirects all storage motion (SXM) code to <code>storage_migrate.ml</code>,
and the multiplexed will be managed by <code>storage_migrate.ml</code>. The main implementation
resides in the <code>DATA</code> and <code>DATA.MIRROR</code> modules. Migration code will use
the <code>Storage_task</code> module to run the operations and update the task&rsquo;s progress.</p><p>It also implements the <code>Policy</code> module from the SMAPIv2 interface.</p><h2 id=smapiv3>SMAPIv3</h2><p><a href=https://xapi-project.github.io/xapi-storage/ rel=external target=_blank>SMAPIv3</a> has a slightly different interface from SMAPIv2.
The
<a href=https://github.com/xapi-project/xen-api/tree/v25.11.0/ocaml/xapi-storage-script rel=external target=_blank><code>xapi-storage-script</code></a>
daemon is a SMAPIv2 plugin separate from xapi that is doing the SMAPIv2 â†” SMAPIv3 translation.
It keeps the plugins registered with xapi-idl (their message-switch queues)
up to date as their files appear or disappear from the relevant directory.</p><h3 id=smapiv3-interface>SMAPIv3 Interface</h3><p>The SMAPIv3 interface is defined using an OCaml-based IDL from the
<a href=https://github.com/mirage/ocaml-rpc rel=external target=_blank><code>ocaml-rpc</code></a> library, and is located at
<a href=https://github.com/xapi-project/xen-api/tree/v25.11.0/ocaml/xapi-storage rel=external target=_blank><code>xen-api/ocaml/xapi-storage</code></a></p><p>From this interface we generate</p><ul><li>OCaml RPC client bindings used in <code>xapi-storage-script</code></li><li>The
<a href=https://xapi-project.github.io/xapi-storage rel=external target=_blank>SMAPIv3 API reference</a></li><li>Python bindings, used by the SM scripts that implement the SMAPIv3
interface.<ul><li>These bindings are built by running <code>make</code> at the root level,
and appear in the<code> _build/default/ocaml/xapi-storage/python/xapi/storage/api/v5/</code>
directory.</li><li>On a XenServer host, they are stored in the
<code>/usr/lib/python3.6/site-packages/xapi/storage/api/v5/</code>
directory</li></ul></li></ul><h3 id=smapiv3-plugins>SMAPIv3 Plugins</h3><p>For <a href=https://xapi-project.github.io/xapi-storage/ rel=external target=_blank>SMAPIv3</a> we have
volume plugins to manipulate SRs and volumes (=VDIs) in them, and
datapath plugins for connecting to the volumes. Volume plugins tell us
which datapath plugins we can use with each volume, and what to pass to
the plugin. Both volume and datapath plugins implement some common
functionality: the SMAPIv3 <a href=https://xapi-project.github.io/xapi-storage/#plugin rel=external target=_blank>plugin
interface</a>.</p><h3 id=how-smapiv3-works>How SMAPIv3 works:</h3><p>The <code>xapi-storage-script</code> daemon detects volume and datapath plugins
stored in subdirectories of the
<code>/usr/libexec/xapi-storage-script/volume/</code> and
<code>/usr/libexec/xapi-storage-script/datapath/</code> directories, respectively.
When it finds a new datapath plugin, it adds the plugin to a lookup table and
uses it the next time that datapath is required.
When it finds a new volume plugin, it binds a new
<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi-storage-script/main.ml#L2023 rel=external target=_blank><code>message-switch</code></a>
queue named after the plugin&rsquo;s subdirectory to a new server instance that uses these volume scripts.</p><p>To invoke a SMAPIv3 method, it executes a program named
<code>&lt;Interface name>.&lt;function name></code> in the plugin&rsquo;s directory,
for example
<code>/usr/libexec/xapi-storage-script/volume/org.xen.xapi.storage.gfs2/SR.ls</code>.
The inputs to each script can be passed as command-line arguments and
are type-checked using the generated Python bindings, and so are the outputs.
The URIs of the SRs that xapi-storage-script knows about are stored in the
Â <code>/var/run/nonpersistent/xapi-storage-script/state.db</code> file,
these URIs can be used on the command line when an sr argument is expected.</p><h4 id=registration-of-the-various-smapiv3-plugins>Registration of the various SMAPIv3 plugins</h4><pre class="mermaid align-center">sequenceDiagram
participant q as message-switch
participant v1 as (Storage_access.SMAPIv1)
participant svr as Storage_mux.Server
participant vol_dir as /../volume/
participant dp_dir as /../datapath/
participant script as xapi-storage-script

Note over script, vol_dir: xapi-storage-script startup
script -&gt;&gt; vol_dir: new subdir org.xen.xapi.storage.sr_type_4
q -&gt;&gt; script: org.xen.xapi.storage.sr_type_4
script -&gt;&gt; dp_dir: new subdir sr_type_4_dp

Note over q, svr: xapi startup, &#34;Starting SMAPIv1 proxies&#34;
q --&gt;&gt; v1:org.xen.xapi.storage.sr_type_1
q --&gt;&gt; v1:org.xen.xapi.storage.sr_type_2
q --&gt;&gt; v1:org.xen.xapi.storage.sr_type_3

Note over q, svr: xapi startup, &#34;Starting SM service&#34;
q -&gt;&gt; svr:org.xen.xapi.storage 

Note over q, svr: SR.create, PBD.plug
svr -&gt;&gt; q:org.xapi.storage.sr_type_4</pre><h4 id=what-happens-when-a-smapiv3-function-is-called>What happens when a SMAPIv3 &ldquo;function&rdquo; is called</h4><pre class="mermaid align-center">graph TD

call[SMAPIv2 call] --VDI.attach2--&gt; org.xen.xapi.storage

subgraph message-switch
org.xen.xapi.storage
org.xen.xapi.storage.SR_type_x
end

org.xen.xapi.storage --VDI.attach2--&gt; Storage_impl.Wrapper

subgraph xapi
subgraph Storage_mux.server
Storage_impl.Wrapper --&gt; Storage_mux.mux
end
Storage_access.SMAPIv1
end

Storage_mux.mux --VDI.attach2--&gt; org.xen.xapi.storage.SR_type_x

org.xen.xapi.storage.SR_type_x -.&#34;VDI.attach2&#34;.-&gt; Storage_access.SMAPIv1

subgraph SMAPIv1
driver_x[SMAPIv1 driver for SR_type_x]
end

Storage_access.SMAPIv1 -.vdi_attach.-&gt; driver_x

subgraph SMAPIv3
xapi-storage-script --Datapath.attach--&gt; v3_dp_plugin_x
subgraph SMAPIv3 plugins
v3_vol_plugin_x[volume plugin for SR_type_x]
v3_dp_plugin_x[datapath plugin for SR_type_x]
end
end

org.xen.xapi.storage.SR_type_x --VDI.attach2--&gt;xapi-storage-script</pre><h2 id=error-reporting>Error reporting</h2><p>In our SMAPIv1 OCaml &ldquo;bindings&rdquo; in xapi
(<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/sm_exec.ml rel=external target=_blank>xen-api/ocaml/xapi/sm_exec.ml</a>),
<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/sm_exec.ml#L421 rel=external target=_blank>when we inspect the error codes returned from a call to
SM</a>,
we translate some of the SMAPIv1/SM error codes to XenAPI errors, and
for others, we just <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/sm_exec.ml#L214 rel=external target=_blank>construct an error
code</a>
of the form <code>SR_BACKEND_FAILURE_&lt;SM error number></code>.</p><p>The file
<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi-idl/storage/storage_interface.ml#L343 rel=external target=_blank>xcp-idl/storage/storage_interface.ml</a>
defines a number of SMAPIv2 errors, ultimately all errors from the various
SMAPIv2 storage servers in xapi will be returned as one of these. Most of the
errors aren&rsquo;t converted into a specific exception in <code>Storage_interface</code>, but
are simply wrapped with <code>Storage_interface.Backend_error</code>.</p><p>The
<a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/storage_utils.ml#L133 rel=external target=_blank>Storage_utils.transform_storage_exn</a>
function is used by the client code in xapi to translate the SMAPIv2
errors into XenAPI errors again, this unwraps the errors wrapped with
<code>Storage_interface.Backend_error</code>.</p><h2 id=message-forwarding>Message Forwarding</h2><p>In the message forwarding layer, first we check the validity of VDI
operations using <code>mark_vdi</code> and <code>mark_sr</code>. These first check that the
operation is valid operations,
usingÂ <a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/xapi_vdi.ml#L65 rel=external target=_blank>Xapi_vdi.check_operation_error</a>,
for <code>mark_vdi</code>, which also inspects the current operations of the VDI,
and then, if the operation is valid, it is added to the VDI&rsquo;s current
operations, and update_allowed_operations is called. Then we forward
the VDI operation to a suitable host that has a PBD plugged for the
VDI&rsquo;s SR.</p><h3 id=checking-that-the-sr-is-attached>Checking that the SR is attached</h3><p>For the VDI operations, we check at two different places whether the SR
is attached: first, at the Xapi level, <a href=https://github.com/xapi-project/xen-api/blob/v25.11.0/ocaml/xapi/xapi_vdi.ml#L133 rel=external target=_blank>in
Xapi_vdi.check_operation_error</a>,
for the resize operation, and then, at the SMAPIv1 level,Â in
<code>Sm.assert_pbd_is_plugged</code>. <code>Sm.assert_pbd_is_plugged</code> performs the
same checks, plus it checks that the PBD is attached to the localhost,
unlike Xapi_vdi.check_operation_error. This behaviour is correct,
because <code>Xapi_vdi.check_operation_error</code> is called from the message
forwarding layer, which forwards the call to a host that has the SR
attached.</p><h2 id=vdi-identifiers-and-storage-motion>VDI Identifiers and Storage Motion</h2><ul><li>VDI &ldquo;location&rdquo;: this is the VDI identifier used by the SM backend.
It is usually the UUID of the VDI, but for ISO SRs it is the name of
the ISO.</li><li>VDI &ldquo;content_id&rdquo;: this is used for storage motion, to reduce the
amount of data copied. When we copy over a VDI, the content_id will
initially be the same. However, when we attach a VDI as read-write,
and then detach it, then we will blank its content_id (set it to a
random UUID), because we may have written to it, so the content
could be different. .</li></ul><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Storage</h1><article class=default><header class=headline></header><h1 id=storage-migration>Storage migration</h1><ul><li><a href=/new-docs/xapi/storage/sxm/index.html#overview>Overview</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#sxm-multiplexing>SXM Multiplexing</a><ul><li><a href=/new-docs/xapi/storage/sxm/index.html#motivation>Motivation</a><ul><li><a href=/new-docs/xapi/storage/sxm/index.html#but-we-have-storage_muxml>But we have storage_mux.ml</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#thought-experiments-on-an-alternative-design>Thought experiments on an alternative design</a></li></ul></li><li><a href=/new-docs/xapi/storage/sxm/index.html#design>Design</a></li></ul></li><li><a href=/new-docs/xapi/storage/sxm/index.html#smapiv1-migration>SMAPIv1 migration</a><ul><li><a href=/new-docs/xapi/storage/sxm/index.html#preparation>Preparation</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#establishing-mirror>Establishing mirror</a><ul><li><a href=/new-docs/xapi/storage/sxm/index.html#mirror>Mirror</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#snapshot>Snapshot</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#copy-and-compose>Copy and compose</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#finish>Finish</a></li></ul></li></ul></li><li><a href=/new-docs/xapi/storage/sxm/index.html#smapiv3-migration>SMAPIv3 migration</a><ul><li><a href=/new-docs/xapi/storage/sxm/index.html#preparation-1>Preparation</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#establishing-mirror-1>Establishing mirror</a><ul><li><a href=/new-docs/xapi/storage/sxm/index.html#limitations>Limitations</a></li></ul></li><li><a href=/new-docs/xapi/storage/sxm/index.html#finish-1>Finish</a></li></ul></li><li><a href=/new-docs/xapi/storage/sxm/index.html#error-handling>Error Handling</a><ul><li><a href=/new-docs/xapi/storage/sxm/index.html#preparation-smapiv1-and-smapiv3>Preparation (SMAPIv1 and SMAPIv3)</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#snapshot-and-mirror-failure-smapiv1>Snapshot and mirror failure (SMAPIv1)</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#mirror-failure-smapiv3>Mirror failure (SMAPIv3)</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#copy-failure-smapiv1>Copy failure (SMAPIv1)</a></li></ul></li><li><a href=/new-docs/xapi/storage/sxm/index.html#smapiv1-migration-implementation-detail>SMAPIv1 Migration implementation detail</a><ul><li><a href=/new-docs/xapi/storage/sxm/index.html#receiving-sxm>Receiving SXM</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#xapi-code>Xapi code</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#storage-code>Storage code</a><ul><li><a href=/new-docs/xapi/storage/sxm/index.html#copying-a-vdi>Copying a VDI</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#mirroring-a-vdi>Mirroring a VDI</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#code-walkthrough>Code walkthrough</a><ul><li><a href=/new-docs/xapi/storage/sxm/index.html#datacopy>DATA.copy</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#datacopy_into>DATA.copy_into</a></li><li><a href=/new-docs/xapi/storage/sxm/index.html#datamirrorstart>DATA.MIRROR.start</a></li></ul></li></ul></li></ul></li></ul><h2 id=overview>Overview</h2><p>The core idea of storage migration is surprisingly simple: We have VDIs attached to a VM,
and we wish to migrate these VDIs from one SR to another. This necessarily requires
us to copy the data stored in these VDIs over to the new SR, which can be a long-running
process if there are gigabytes or even terabytes of them. We wish to minimise the
down time of this process to allow the VM to keep running as much as possible.</p><p>At a very high level, the SXM process generally only consists of two stages: preparation
and mirroring. The preparation is about getting the receiving host ready for the
mirroring operation, while the mirroring itself can be further divided into two
more operations: 1. sending new writes to both sides; 2.copying existing data from
source to destination. The exact detail of how to set up a mirror differs significantly
between SMAPIv1 and SMAPIv3, but both of them will have to perform the above two
operations.
Once the mirroring is established, it is a matter of checking the status of the
mirroring and carry on with the follwoing VM migration.</p><p>The reality is more complex than what we had hoped for. For example, in SMAPIv1,
the mirror establishment is quite an involved process and is itself divided into
several stages, which will be discussed in more detail later on.</p><h2 id=sxm-multiplexing>SXM Multiplexing</h2><p>This section is about the design idea behind the additional layer of mutiplexing specifically
for Storage Xen Motion (SXM) from SRs using SMAPIv3. It is recommended that you have read the
<a href=/new-docs/xapi/storage/index.html>introduction doc</a> for the storage layer first to understand how storage
multiplexing is done between SMAPIv2 and SMAPI{v1, v3} before reading this.</p><h3 id=motivation>Motivation</h3><p>The existing SXM code was designed to work only with SMAPIv1 SRs, and therefore
does not take into account the dramatic difference in the ways SXM is done between
SMAPIv1 and SMAPIv3. The exact difference will be covered later on in this doc, for this section
it is sufficient to assume that they have two ways of doing migration. Therefore,
we need different code paths for migration from SMAPIv1 and SMAPIv3.</p><h4 id=but-we-have-storage_muxml>But we have storage_mux.ml</h4><p>Indeed, storage_mux.ml is responsible for multiplexing and forwarding requests to
the correct storage backend, based on the SR type that the caller specifies. And
in fact, for inbound SXM to SMAPIv3 (i.e. migrating into a SMAPIv3 SR, GFS2 for example),
storage_mux is doing the heavy lifting of multiplexing between different storage
backends. Every time a <code>Remote.</code> call is invoked, this will go through the SMAPIv2
layer to the remote host and get multiplexed on the destination host, based on
whether we are migrating into a SMAPIv1 or SMAPIv3 SR (see the diagram below).
And the inbound SXM is implemented
by implementing the existing SMAPIv2 -> SMAPIv3 calls (see <code>import_activate</code> for example)
which may not have been implemented before.</p><p><img alt="mux for inbound" class="noborder lazy nolightbox shadow figure-image" loading=lazy src=/new-docs/xapi/storage/sxm/sxm_mux_inbound.svg style=height:auto;width:auto></p><p>While this works fine for inbound SXM, it does not work for outbound SXM. A typical SXM
consists of four combinations, the source sr type (v1/v3) and the destiantion sr
type (v1/v3), any of the four combinations is possible. We have already covered the
destination multiplexing (v1/v3) by utilising storage_mux, and at this point we
have run out of multiplexer for multiplexing on the source. In other words, we
can only mutiplex once for each SMAPIv2 call, and we can either use that chance for
either the source or the destination, and we have already used it for the latter.</p><h4 id=thought-experiments-on-an-alternative-design>Thought experiments on an alternative design</h4><p>To make it even more concrete, let us consider an example: the mirroring logic in
SXM is different based on the source SR type of the SXM call. You might imagine
defining a function like <code>MIRROR.start v3_sr v1_sr</code> that will be multiplexed
by the storage_mux based on the source SR type, and forwarded to storage_smapiv3_migrate,
or even just xapi-storage-script, which is indeed quite possible.
Now at this point we have already done the multiplexing, but we still wish to
multiplex operations on destination SRs, for example, we might want to attach a
VDI belonging to a SMAPIv1 SR on the remote host. But as we have already done the
multiplexing and is now inside xapi-storage-script, we have lost any chance of doing
any further multiplexing :(</p><h3 id=design>Design</h3><p>The idea of this new design is to introduce an additional multiplexing layer that
is specific for multiplexing calls based on the source SR type. For example, in
the diagram below the <code>send_start src_sr dest_sr</code> will take both the src SR and the
destination SR as parameters, and suppose the mirroring logic is different for different
types of source SRs (i.e. SMAPIv1 or SMAPIv3), the storage migration code will
necessarily choose the right code path based on the source SR type. And this is
exactly what is done in this additional multiplexing layer. The respective logic
for doing {v1,v3}-specifi mirroring, for example, will stay in storage_smapi{v1,v3}_migrate.ml</p><p><img alt="mux for outbound" class="noborder lazy nolightbox shadow figure-image" loading=lazy src=/new-docs/xapi/storage/sxm/sxm_mux_outbound.svg style=height:auto;width:auto></p><p>Note that later on storage_smapi{v1,v3}_migrate.ml will still have the flexibility
to call remote SMAPIv2 functions, such as <code>Remote.VDI.attach dest_sr vdi</code>, and
it will be handled just as before.</p><h2 id=smapiv1-migration>SMAPIv1 migration</h2><p>This section is about migration from SMAPIv1 SRs to SMAPIv1 or SMAPIv3 SRs, since
the migration is driven by the source host, it is usally the source host that
determines most of the logic during a storage migration.</p><p>First we take a look at an overview diagram of what happens during SMAPIv1 SXM:
the diagram is labelled with S1, S2 &mldr; which indicates different stages of the migration.
We will talk about each stage in more detail below.</p><p><img alt=overview-v1 class="noborder lazy nolightbox shadow figure-image" loading=lazy src=/new-docs/xapi/storage/sxm/sxm-overview-v1.svg style=height:auto;width:auto></p><h3 id=preparation>Preparation</h3><p>Before we can start our migration process, there are a number of preparations
needed to prepare for the following mirror. For SMAPIv1 this involves:</p><ol><li>Create a new VDI (called leaf) that will be used as the receiving VDI for all the new writes</li><li>Create a dummy snapshot of the VDI above to make sure it is a differencing disk and can be composed later on</li><li>Create a VDI (called parent) that will be used to receive the existing content of the disk (the snapshot)</li></ol><p>Note that the leaf VDI needs to be attached and activated on the destination host (to a non-exsiting <code>mirror_vm</code>)
since it will later on accept writes to mirror what is written on the source host.</p><p>The parent VDI may be created in two different ways: 1. If there is a &ldquo;similar VDI&rdquo;,
clone it on the destination host and use it as the parent VDI; 2. If there is no
such VDI, create a new blank VDI. The similarity here is defined by the distances
between different VDIs in the VHD tree, which is exploiting the internal representation
of the storage layer, hence we will not go into too much detail about this here.</p><p>Once these preparations are done, a <code>mirror_receive_result</code> data structure is then
passed back to the source host that will contain all the necessary information about
these new VDIs, etc.</p><h3 id=establishing-mirror>Establishing mirror</h3><p>At a high level, mirror establishment for SMAPIv1 works as follows:</p><ol><li>Take a snapshot of a VDI that is attached to VM1. This gives us an immutable
copy of the current state of the VDI, with all the data up until the point we took
the snapshot. This is illustrated in the diagram as a VDI and its snapshot connecting
to a shared parent, which stores the shared content for the snapshot and the writable
VDI from which we took the snapshot (snapshot)</li><li>Mirror the writable VDI to the server hosts: this means that all writes that goes to the
client VDI will also be written to the mirrored VDI on the remote host (mirror)</li><li>Copy the immutable snapshot from our local host to the remote (copy)</li><li>Compose the mirror and the snapshot to form a single VDI</li><li>Destroy the snapshot on the local host (cleanup)</li></ol><h4 id=mirror>Mirror</h4><p>The mirroring process for SMAPIv1 is rather unconventional, so it is worth
documenting how this works. Instead of a conventional client server architecture,
where the source client connects to the destination server directly through the
NBD protocol in tapdisk, the connection is established in xapi and then passed
onto tapdisk. It was done in this rather unusual way mainly due to authentication
issues. Because it is xapi that is creating the connection, tapdisk does not need
to be concerned about authentication of the connection, thus simplifying the storage
component. This is reasonable as the storage component should focus on handling
storage requests rather than worrying about network security.</p><p>The diagram below illustrates this prcess. First, xapi on the source host will
initiate an https request to the remote xapi. This request contains the necessary
information about the VDI to be mirrored, and the SR that contains it, etc. This
information is then passed onto the https handler on the destination host (called
<code>nbd_handler</code>) which then processes this information. Now the unusual step is that
both the source and the destination xapi will pass this connection onto tapdisk,
by sending the fd representing the socket connection to the tapdisk process. On
the source this would be nbd client process of tapdisk, and on the destination
this would be the nbd server process of the tapdisk. After this step, we can consider
a client-server connection is established between two tapdisks on the client and
server, as if the tapdisk on the source host makes a request to the tapdisk on the
destination host and initiates the connection. On the diagram, this is indicated
by the dashed lines between the tapdisk processes. Logically, we can view this as
xapi creates the connection, and then passes this connection down into tapdisk.</p><p><img alt=mirror class="noborder lazy nolightbox shadow figure-image" loading=lazy src=/new-docs/xapi/storage/sxm/sxm-mirror-v1.svg style=height:auto;width:auto></p><h4 id=snapshot>Snapshot</h4><p>The next step would be create a snapshot of the VDI. This is easily done as a
<code>VDI.snapshot</code> operation. If the VDI was in VHD format, then internally this would
create two children for, one for the snapshot, which only contains the metadata
information and tends to be small, the other for the writable VDI where all the
new writes will go to. The shared base copy contains the shared blocks.</p><p><img alt=snapshot class="noborder lazy nolightbox shadow figure-image" loading=lazy src=/new-docs/xapi/storage/sxm/sxm-snapshot-v1.svg style=height:auto;width:auto></p><h4 id=copy-and-compose>Copy and compose</h4><p>Once the snapshot is created, we can then copy the snapshot from the source
to the destination. This step is done by <code>sparse_dd</code> using the nbd protocol. This
is also the step that takes the most time to complete.</p><p><code>sparse_dd</code> is a process forked by xapi that does the copying of the disk blocks.
<code>sparse_dd</code> can supports a number of protocols, including nbd. In this case, <code>sparse_dd</code>
will initiate an https put request to the destination host, with a url of the form
<code>&lt;address>/services/SM/nbdproxy/&lt;sr>/&lt;vdi></code>. This https request then
gets handled by the https handler on the destination host B, which will then spawn
a handler thread. This handler will find the
&ldquo;generic&rdquo; nbd server<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> of either tapdisk or qemu-dp, depending on the destination
SR type, and then start proxying data between the https connection socket and the
socket connected to the nbd server.</p><p><img alt="sxm new copy" class="noborder lazy nolightbox shadow figure-image" loading=lazy src=/new-docs/xapi/storage/sxm/sxm-new-copy-v1.svg style=height:auto;width:auto></p><p>Once copying is done, the snapshot and mirrored VDI can be then composed into a
single VDI.</p><h4 id=finish>Finish</h4><p>At this point the VDI is synchronised to the new host! Mirror is still working at this point
though because that will not be destroyed until the VM itself has been migrated
as well. Some cleanups are done at this point, such as deleting the snapshot
that is taken on the source, destroying the mirror datapath, etc.</p><p>The end results look like the following. Note that VM2 is in dashed line as it
is not yet created yet. The next steps would be to migrate the VM1 itself to the
destination as well, but this is part of the VM migration process and will not
be covered here.</p><p><img alt=final class="noborder lazy nolightbox shadow figure-image" loading=lazy src=/new-docs/xapi/storage/sxm/sxm-final-v1.svg style=height:auto;width:auto></p><h2 id=smapiv3-migration>SMAPIv3 migration</h2><p>This section covers the mechanism of migrations <em>from</em> SRs using SMAPIv3 (to
SMAPIv1 or SMAPIv3). Although the core ideas are the same, SMAPIv3 has a rather
different mechanism for mirroring: 1. it does not require xapi to take snapshot
of the VDI anymore, since the mirror itself will take care of replicating the
existing data to the destination; 2. there is no fd passing for connection establishment anymore, and instead proxies are used for connection setup.</p><h3 id=preparation-1>Preparation</h3><p>The preparation work for SMAPIv3 is greatly simplified by the fact that the mirror
at the storage layer will copy the existing data in the VDI to the destination.
This means that snapshot of the source VDI is not required anymore. So we are left
with only one thing:</p><ol><li>Create a VDI used for mirroring the data of the source VDI</li></ol><p>For this reason, the implementation logic for SMAPIv3 preparation is also shorter,
as the complexity is now handled by the storage layer, which is where it is supposed
to be handled.</p><h3 id=establishing-mirror-1>Establishing mirror</h3><p>The other significant difference is that the storage backend for SMAPIv3 <code>qemu-dp</code>
SRs no longer accepts fds, so xapi needs to proxy the data between two nbd client
and nbd server.</p><p>SMAPIv3 provides the <code>Data.mirror uri domain remote</code> which needs three parameters:
<code>uri</code> for accessing the local disk, <code>doamin</code> for the domain slice on which mirroring
should happen, and most importantly for this design, a <code>remote</code> url which represents
the remote nbd server to which the blocks of data can be sent to.</p><p>This function itself, when called by xapi and forwarded to the storage layer&rsquo;s qemu-dp
nbd client, will initiate a nbd connection to the nbd server pointed to by <code>remote</code>.
This works fine when the storage migration happens entirely within a local host,
where qemu-dp&rsquo;s nbd client and nbd server can communicate over unix domain sockets.
However, it does not work for inter-host migrations as qemu-dp&rsquo;s nbd server is not
exposed publicly over the network (just as tapdisk&rsquo;s nbd server). Therefore a proxying
service on the source host is needed for forwarding the nbd connection from the
source host to the destination host. And it would be the responsiblity of
xapi to manage this proxy service.</p><p>The following diagram illustrates the mirroring process of a single VDI:</p><p><img alt="sxm mirror" class="noborder lazy nolightbox shadow figure-image" loading=lazy src=/new-docs/xapi/storage/sxm/sxm-mirror-v3.svg style=height:auto;width:auto></p><p>The first step for xapi is then to set up a nbd proxy thread that will be listening
on a local unix domain socket with path <code>/var/run/nbdproxy/export/&lt;domain></code> where
domain is the <code>domain</code> parameter mentioned above in <code>Data.mirror</code>. The nbd proxy
thread will accept nbd connections (or rather any connections, it does not
speak/care about nbd protocol at all) and sends an https put request
to the remote xapi. The proxy itself will then forward the data exactly as it is
to the remote side through the https connection.</p><p>Once the proxy is set up, xapi will call <code>Data.mirror</code>, which
will be forwarded to the xapi-storage-script and is further forwarded to the qemu-dp.
This call contains, among other parameters, the destination NBD server url (<code>remote</code>)
to be connected. In this case the destination nbd server is exactly the domain
socket to which the proxy thread is listening. Therefore the <code>remote</code> parameter
will be of the form <code>nbd+unix:///&lt;export>?socket=&lt;socket></code> where the export is provided
by the destination nbd server that represents the VDI prepared on the destination
host, and the socket will be the path of the unix domain socket where the proxy
thread (which we just created) is listening at.</p><p>When this connection is set up, the proxy process will talk to the remote xapi via
https requests, and on the remote side, an https handler will proxy this request to
the appropriate nbd server of either tapdisk or qemu-dp, using exactly the same
<a href=/new-docs/xapi/storage/sxm/index.html#copy-and-compose>import proxy</a> as mentioned before.</p><p>Note that this proxying service is tightly integrated with outbound SXM of SMAPIv3
SRs. This is to make it simple to focus on the migration itself.</p><p>Although there is no need to explicitly copy the VDI anymore, we still need to
transfer the data and wait for it finish. For this we use <code>Data.stat</code> call provided
by the storage backend to query the status of the mirror, and wait for it to finish
as needed.</p><h4 id=limitations>Limitations</h4><p>This way of establishing the connection simplifies the implementation of the migration
for SMAPIv3, but it also has limitations:</p><p>One proxy per live VDI migration is needed, which can potentially consume lots of resources in dom0, and we should measure the impact of this before we switch to using more resource-efficient ways such as wire guard that allows establishing a single connection between multiple hosts.</p><h3 id=finish-1>Finish</h3><p>As there is no need to copy a VDI, there is also no need to compose or delete the
snapshot. The cleanup procedure would therefore just involve destroy the datapath
that was used for receiving writes for the mirrored VDI.</p><h2 id=error-handling>Error Handling</h2><p>Storage migration is a long-running process, and is prone to failures in each
step. Hence it is important specifying what errors could be raised at each step
and their significance. This is beneficial both for the user and for triaging.</p><p>There are two general cleanup functions in SXM: <code>MIRROR.receive_cancel</code> and
<code>MIRROR.stop</code>. The former is for cleaning up whatever has been created by <code>MIRROR.receive_start</code>
on the destination host (such as VDIs for receiving mirrored data). The latter is
a more comprehensive function that attempts to &ldquo;undo&rdquo; all the side effects that
was done during the SXM, and also calls <code>receive_cancel</code> as part of its operations.</p><p>Currently error handling was done by building up a list of cleanup functions in
the <code>on_fail</code> list ref as the function executes. For example, if the <code>receive_start</code>
has been completed successfully, add <code>receive_cancel</code> to the list of cleanup functions.
And whenever an exception is encountered, just execute whatever has been added
to the <code>on_fail</code> list ref. This is convenient, but does entangle all the error
handling logic with the core SXM logic itself, making the code rather than hard
to understand and maintain.</p><p>The idea to fix this is to introduce explicit &ldquo;stages&rdquo; during the SXM and define
explicitly what error handling should be done if it fails at a certain stage. This
helps separate the error handling logic into the <code>with</code> part of a <code>try with</code> block,
which is where they are supposed to be. Since we need to accommodate the existing
SMAPIv1 migration (which has more stages than SMAPIv3), the following stages are
introduced: preparation (v1,v3), snapshot(v1), mirror(v1, v3), copy(v1). Note that
each stage also roughly corresponds to a helper function that is called within <code>Storage_migrate.start</code>,
which is the wrapper function that initiates storage migration. And each helper
functions themselves would also have error handling logic within themselves as
needed (e.g. see <code>Storage_smapiv1_migrate.receive_start</code>) to deal with exceptions
that happen within each helper functions.</p><h3 id=preparation-smapiv1-and-smapiv3>Preparation (SMAPIv1 and SMAPIv3)</h3><p>The preparation stage generally corresponds to what is done in <code>receive_start</code>, and
this function itself will handle exceptions when there are partial failures within
the function itself, such as an exception after the receiving VDI is created.
It will use the old-style <code>on_fail</code> function but only with a limited scope.</p><p>There is nothing to be done at a higher level (i.e within <code>MIRROR.start</code> which
calls <code>receive_start</code>) if preparation has failed.</p><h3 id=snapshot-and-mirror-failure-smapiv1>Snapshot and mirror failure (SMAPIv1)</h3><p>For SMAPIv1, the mirror is done in a bit cumbersome way. The end goal is to establish
connections between two tapdisk processes on the source and destination hosts.
To achieve this goal, xapi will do two main jobs: 1. create a connection between two
hosts and pass the connection to tapdisk; 2. create a snapshot as a starting point
of the mirroring process.</p><p>Therefore handling of failures at these two stages are similar: clean up what was
done in the preparation stage by calling <code>receive_cancel</code>, and that is almost it.
Again, we will leave whatever is needed for partial failure handling within those
functions themselves and only clean up at a stage-level in <code>storage_migrate.ml</code></p><p>Note that <code>receive_cancel</code> is a multiplexed function for SMAPIv1 and SMAPIv3, which
means different clean up logic will be executed depending on what type of SR we
are migrating from.</p><h3 id=mirror-failure-smapiv3>Mirror failure (SMAPIv3)</h3><p>The <code>Data.stat</code> call in SMAPIv3 returns a data structure that includes the current
progress of the mirror job, whether it has completed syncing the existing data and
whether the mirorr has failed. Similar to how it is done in SMAPIv1, we wait for
the sync to complete once we issue the <code>Data.mirror</code> call, by repeatedly polling
the status of the mirror using the <code>Data.stat</code> call. During this process, the status
of the mirror is also checked and if a failure is detected, a <code>Migration_mirror_failure</code>
will be raised and then gets handled by the code in <code>storage_migrate.ml</code> by calling
<code>Storage_smapiv3_migrate.receive_cancel2</code>, which will clean up the mirror datapath
and destroy the mirror VDI, similar to what is done in SMAPIv1.</p><h3 id=copy-failure-smapiv1>Copy failure (SMAPIv1)</h3><p>The final step of storage migration for SMAPIv1 is to copy the snapshot from the
source to the destination. At this stage, most of the side effectful work has been
done, so we do need to call <code>MIRROR.stop</code> to clean things up if we experience an
failure during copying.</p><h2 id=smapiv1-migration-implementation-detail>SMAPIv1 Migration implementation detail</h2><details open class="box cstyle notices info"><summary class=box-label tabindex=-1><i class="fa-fw fas fa-info-circle"></i>
Info</summary><div class=box-content><p>The following doc refers to the xapi a <a href=https://github.com/xapi-project/xen-api/blob/v24.37.0/ocaml/xapi/storage_migrate.ml rel=external target=_blank>version</a>
of xapi that is before 24.37 after which point this code structure has undergone
many changes as part of adding support for SMAPIv3 SXM. Therefore the following
tutorial might be less relevant in terms of the implementation detail. Although
the general principle should remain the same.</p></div></details><pre class="mermaid align-center">sequenceDiagram
participant local_tapdisk as local tapdisk
participant local_smapiv2 as local SMAPIv2
participant xapi
participant remote_xapi as remote xapi
participant remote_smapiv2 as remote SMAPIv2 (might redirect)
participant remote_tapdisk as remote tapdisk

Note over xapi: Sort VDIs increasingly by size and then age

loop VM&#39;s &amp; snapshots&#39; VDIs &amp; suspend images
  xapi-&gt;&gt;remote_xapi: plug dest SR to dest host and pool master
  alt VDI is not mirrored
    Note over xapi: We don&#39;t mirror RO VDIs &amp; VDIs of snapshots
    xapi-&gt;&gt;local_smapiv2: DATA.copy remote_sm_url

    activate local_smapiv2
    local_smapiv2--&gt;&gt;local_smapiv2: SR.scan
    local_smapiv2--&gt;&gt;local_smapiv2: VDI.similar_content
    local_smapiv2--&gt;&gt;remote_smapiv2: SR.scan
    Note over local_smapiv2: Find nearest smaller remote VDI remote_base, if any
    alt remote_base
      local_smapiv2--&gt;&gt;remote_smapiv2: VDI.clone
      local_smapiv2--&gt;&gt;remote_smapiv2: VDI.resize
    else no remote_base
      local_smapiv2--&gt;&gt;remote_smapiv2: VDI.create
    end

    Note over local_smapiv2: call copy&#39;
    activate local_smapiv2
    local_smapiv2--&gt;&gt;remote_smapiv2: SR.list
    local_smapiv2--&gt;&gt;remote_smapiv2: SR.scan
    Note over local_smapiv2: create new datapaths remote_dp, base_dp, leaf_dp
    Note over local_smapiv2: find local base_vdi with same content_id as dest, if any
    local_smapiv2--&gt;&gt;remote_smapiv2: VDI.attach2 remote_dp dest
    local_smapiv2--&gt;&gt;remote_smapiv2: VDI.activate remote_dp dest
    opt base_vdi
      local_smapiv2--&gt;&gt;local_smapiv2: VDI.attach2 base_dp base_vdi
      local_smapiv2--&gt;&gt;local_smapiv2: VDI.activate base_dp base_vdi
    end
    local_smapiv2--&gt;&gt;local_smapiv2: VDI.attach2 leaf_dp vdi
    local_smapiv2--&gt;&gt;local_smapiv2: VDI.activate leaf_dp vdi
    local_smapiv2--&gt;&gt;remote_xapi: sparse_dd base_vdi vdi dest [NBD URI for dest &amp; remote_dp]
    Note over remote_xapi: HTTP handler verifies credentials
    remote_xapi--&gt;&gt;remote_tapdisk: then passes connection to tapdisk&#39;s NBD server
    local_smapiv2--&gt;&gt;local_smapiv2: VDI.deactivate leaf_dp vdi
    local_smapiv2--&gt;&gt;local_smapiv2: VDI.detach leaf_dp vdi
    opt base_vdi
      local_smapiv2--&gt;&gt;local_smapiv2: VDI.deactivate base_dp base_vdi
      local_smapiv2--&gt;&gt;local_smapiv2: VDI.detach base_dp base_vdi
    end
    local_smapiv2--&gt;&gt;remote_smapiv2: DP.destroy remote_dp
    deactivate local_smapiv2

    local_smapiv2--&gt;&gt;remote_smapiv2: VDI.snapshot remote_copy
    local_smapiv2--&gt;&gt;remote_smapiv2: VDI.destroy remote_copy
    local_smapiv2-&gt;&gt;xapi: task(snapshot)
    deactivate local_smapiv2

  else VDI is mirrored
    Note over xapi: We mirror RW VDIs of the VM
    Note over xapi: create new datapath dp
    xapi-&gt;&gt;local_smapiv2: VDI.attach2 dp
    xapi-&gt;&gt;local_smapiv2: VDI.activate dp
    xapi-&gt;&gt;local_smapiv2: DATA.MIRROR.start dp remote_sm_url

    activate local_smapiv2
    Note over local_smapiv2: copy disk data &amp; mirror local writes
    local_smapiv2--&gt;&gt;local_smapiv2: SR.scan
    local_smapiv2--&gt;&gt;local_smapiv2: VDI.similar_content
    local_smapiv2--&gt;&gt;remote_smapiv2: DATA.MIRROR.receive_start similars
    activate remote_smapiv2
    remote_smapiv2--&gt;&gt;local_smapiv2: mirror_vdi,mirror_dp,copy_diffs_from,copy_diffs_to,dummy_vdi
    deactivate remote_smapiv2
    local_smapiv2--&gt;&gt;local_smapiv2: DP.attach_info dp
    local_smapiv2--&gt;&gt;remote_xapi: connect to [NBD URI for mirror_vdi &amp; mirror_dp]
    Note over remote_xapi: HTTP handler verifies credentials
    remote_xapi--&gt;&gt;remote_tapdisk: then passes connection to tapdisk&#39;s NBD server
    local_smapiv2--&gt;&gt;local_tapdisk: pass socket &amp; dp to tapdisk of dp
    local_smapiv2--&gt;&gt;local_smapiv2: VDI.snapshot local_vdi [mirror:dp]
    local_smapiv2--&gt;&gt;local_tapdisk: [Python] unpause disk, pass dp
    local_tapdisk--&gt;&gt;remote_tapdisk: mirror new writes via NBD to socket
    Note over local_smapiv2: call copy&#39; snapshot copy_diffs_to
    local_smapiv2--&gt;&gt;remote_smapiv2: VDI.compose copy_diffs_to mirror_vdi
    local_smapiv2--&gt;&gt;remote_smapiv2: VDI.remove_from_sm_config mirror_vdi base_mirror
    local_smapiv2--&gt;&gt;remote_smapiv2: VDI.destroy dummy_vdi
    local_smapiv2--&gt;&gt;local_smapiv2: VDI.destroy snapshot
    local_smapiv2-&gt;&gt;xapi: task(mirror ID)
    deactivate local_smapiv2

    xapi-&gt;&gt;local_smapiv2: DATA.MIRROR.stat
    activate local_smapiv2
    local_smapiv2-&gt;&gt;xapi: dest_vdi
    deactivate local_smapiv2
  end

  loop until task finished
    xapi-&gt;&gt;local_smapiv2: UPDATES.get
    xapi-&gt;&gt;local_smapiv2: TASK.stat
  end
  xapi-&gt;&gt;local_smapiv2: TASK.stat
  xapi-&gt;&gt;local_smapiv2: TASK.destroy
end
opt for snapshot VDIs
  xapi-&gt;&gt;local_smapiv2: SR.update_snapshot_info_src remote_sm_url
  activate local_smapiv2
  local_smapiv2--&gt;&gt;remote_smapiv2: SR.update_snapshot_info_dest
  deactivate local_smapiv2
end
Note over xapi: ...
Note over xapi: reserve resources for the new VM in dest host
loop all VDIs
  opt VDI is mirrored
    xapi-&gt;&gt;local_smapiv2: DP.destroy dp
  end
end
opt post_detach_hook
  opt active local mirror
    local_smapiv2--&gt;&gt;remote_smapiv2: DATA.MIRROR.receive_finalize [mirror ID]
    Note over remote_smapiv2: destroy mirror dp
  end
end
Note over xapi: memory image migration by xenopsd
Note over xapi: destroy the VM record</pre><h3 id=receiving-sxm>Receiving SXM</h3><p>These are the remote calls in the above diagram sent from the remote host to
the receiving end of storage motion:</p><ul><li>Remote SMAPIv2 -> local SMAPIv2 RPC calls:<ul><li><code>SR.list</code></li><li><code>SR.scan</code></li><li><code>SR.update_snapshot_info_dest</code></li><li><code>VDI.attach2</code></li><li><code>VDI.activate</code></li><li><code>VDI.snapshot</code></li><li><code>VDI.destroy</code></li><li>For copying:<ul><li>For copying from base:<ul><li><code>VDI.clone</code></li><li><code>VDI.resize</code></li></ul></li><li>For copying without base:<ul><li><code>VDI.create</code></li></ul></li></ul></li><li>For mirroring:<ul><li><code>DATA.MIRROR.receive_start</code></li><li><code>VDI.compose</code></li><li><code>VDI.remove_from_sm_config</code></li><li><code>DATA.MIRROR.receive_finalize</code></li></ul></li></ul></li><li>HTTP requests to xapi:<ul><li>Connecting to NBD URI via xapi&rsquo;s HTTP handler</li></ul></li></ul><hr><p>This is how xapi coordinates storage migration. We&rsquo;ll do it as a code walkthrough through the two layers: xapi and storage-in-xapi (SMAPIv2).</p><h3 id=xapi-code>Xapi code</h3><p>The entry point is in <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/xapi_vm_migrate.ml#L786 rel=external target=_blank>xapi_vm_migration.ml</a></p><p>The function takes several arguments:</p><ul><li>a vm reference (<code>vm</code>)</li><li>a dictionary of <code>(string * string)</code> key-value pairs about the destination (<code>dest)</code>. This is the result of a previous call to the destination pool, <code>Host.migrate_receive</code></li><li><code>live</code>, a boolean of whether we should live-migrate or suspend-resume,</li><li><code>vdi_map</code>, a mapping of VDI references to destination SR references,</li><li><code>vif_map</code>, a mapping of VIF references to destination network references,</li><li><code>vgpu_map</code>, similar for VGPUs</li><li><code>options</code>, another dictionary of options</li></ul><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> migrate_send&#39;  <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>live <span style=color:#f92672>~</span>vdi_map <span style=color:#f92672>~</span>vif_map <span style=color:#f92672>~</span>vgpu_map <span style=color:#f92672>~</span>options <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  SMPERF.debug <span style=color:#e6db74>&#34;vm.migrate_send called vm:%s&#34;</span> <span style=color:#f92672>(</span>Db.VM.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Xapi_xenops</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> localhost <span style=color:#f92672>=</span> Helpers.get_localhost <span style=color:#f92672>~__</span>context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote <span style=color:#f92672>=</span> remote_of_dest dest <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Copy mode means we don&#39;t destroy the VM on the source host. We also don&#39;t
</span></span></span><span style=display:flex><span><span style=color:#75715e>     	   copy over the RRDs/messages *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> copy <span style=color:#f92672>=</span> <span style=color:#66d9ef>try</span> bool_of_string <span style=color:#f92672>(</span>List.assoc <span style=color:#e6db74>&#34;copy&#34;</span> options<span style=color:#f92672>)</span> <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> false <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>It begins by getting the local host reference, deciding whether we&rsquo;re copying or moving, and converting the input <code>dest</code> parameter from an untyped string association list to a typed record, <code>remote</code>, which is declared further up the file:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> remote <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  rpc <span style=color:#f92672>:</span> Rpc.call <span style=color:#f92672>-&gt;</span> Rpc.response<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  session <span style=color:#f92672>:</span> API.ref_session<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  sm_url <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  xenops_url <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  master_url <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  remote_ip <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span> <span style=color:#75715e>(* IP address *)</span>
</span></span><span style=display:flex><span>  remote_master_ip <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span> <span style=color:#75715e>(* IP address *)</span>
</span></span><span style=display:flex><span>  dest_host <span style=color:#f92672>:</span> API.ref_host<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p>this contains:</p><ul><li>A function, <code>rpc</code>, for calling XenAPI RPCs on the destination</li><li>A <code>session</code> valid on the destination</li><li>A <code>sm_url</code> on which SMAPIv2 APIs can be called on the destination</li><li>A <code>master_url</code> on which XenAPI commands can be called (not currently used)</li><li>The IP address, <code>remote_ip</code>, of the destination host</li><li>The IP address, <code>remote_master_ip</code>, of the master of the destination pool</li></ul><p>Next, we determine which VDIs to copy:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* The first thing to do is to create mirrors of all the disks on the remote.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     We look through the VM&#39;s VBDs and all of those of the snapshots. We then
</span></span></span><span style=display:flex><span><span style=color:#75715e>     compile a list of all of the associated VDIs, whether we mirror them or not
</span></span></span><span style=display:flex><span><span style=color:#75715e>     (mirroring means we believe the VDI to be active and new writes should be
</span></span></span><span style=display:flex><span><span style=color:#75715e>     mirrored to the destination - otherwise we just copy it)
</span></span></span><span style=display:flex><span><span style=color:#75715e>     We look at the VDIs of the VM, the VDIs of all of the snapshots, and any
</span></span></span><span style=display:flex><span><span style=color:#75715e>     suspend-image VDIs. *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vm_uuid <span style=color:#f92672>=</span> Db.VM.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vbds <span style=color:#f92672>=</span> Db.VM.get_VBDs <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vifs <span style=color:#f92672>=</span> Db.VM.get_VIFs <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> snapshots <span style=color:#f92672>=</span> Db.VM.get_snapshots <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vm_and_snapshots <span style=color:#f92672>=</span> vm <span style=color:#f92672>::</span> snapshots <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> snapshots_vbds <span style=color:#f92672>=</span> List.concat_map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span> Db.VM.get_VBDs <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>)</span> snapshots <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> snapshot_vifs <span style=color:#f92672>=</span> List.concat_map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span> Db.VM.get_VIFs <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>)</span> snapshots <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>we now decide whether we&rsquo;re intra-pool or not, and if we&rsquo;re intra-pool whether we&rsquo;re migrating onto the same host (localhost migrate). Intra-pool is decided by trying to do a lookup of our current host uuid on the destination pool.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> is_intra_pool <span style=color:#f92672>=</span> <span style=color:#66d9ef>try</span> ignore<span style=color:#f92672>(</span>Db.Host.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>);</span> true <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> false <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> is_same_host <span style=color:#f92672>=</span> is_intra_pool <span style=color:#f92672>&amp;&amp;</span> remote<span style=color:#f92672>.</span>dest_host <span style=color:#f92672>==</span> localhost <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> copy <span style=color:#f92672>&amp;&amp;</span> is_intra_pool <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.operation_not_allowed<span style=color:#f92672>,</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;Copy mode is disallowed on intra pool storage migration, try efficient alternatives e.g. VM.copy/clone.&#34;</span><span style=color:#f92672>]));</span></span></span></code></pre></div><p>Having got all of the VBDs of the VM, we now need to find the associated VDIs, filtering out empty CDs, and decide whether we&rsquo;re going to copy them or mirror them - read-only VDIs can be copied but RW VDIs must be mirrored.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vms_vdis <span style=color:#f92672>=</span> List.filter_map <span style=color:#f92672>(</span>vdi_filter <span style=color:#f92672>__</span>context true<span style=color:#f92672>)</span> vbds <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>where <code>vdi_filter</code> is defined earler:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* We ignore empty or CD VBDs - nothing to do there. Possible redundancy here:
</span></span></span><span style=display:flex><span><span style=color:#75715e>   I don&#39;t think any VBDs other than CD VBDs can be &#39;empty&#39; *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> vdi_filter <span style=color:#f92672>__</span>context allow_mirror vbd <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> Db.VBD.get_empty <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#f92672>||</span> Db.VBD.get_type <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#f92672>=</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>CD</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>then</span> <span style=color:#a6e22e>None</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> do_mirror <span style=color:#f92672>=</span> allow_mirror <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>(</span>Db.VBD.get_mode <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#f92672>=</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>RW</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vm <span style=color:#f92672>=</span> Db.VBD.get_VM <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vdi <span style=color:#f92672>=</span> Db.VBD.get_VDI <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span>get_vdi_mirror <span style=color:#f92672>__</span>context vm vdi do_mirror<span style=color:#f92672>)</span></span></span></code></pre></div><p>This in turn calls <code>get_vdi_mirror</code> which gathers together some important info:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> get_vdi_mirror <span style=color:#f92672>__</span>context vm vdi do_mirror <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> snapshot_of <span style=color:#f92672>=</span> Db.VDI.get_snapshot_of <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> size <span style=color:#f92672>=</span> Db.VDI.get_virtual_size <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> xenops_locator <span style=color:#f92672>=</span> Xapi_xenops.xenops_vdi_locator <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> location <span style=color:#f92672>=</span> Db.VDI.get_location <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dp <span style=color:#f92672>=</span> Storage_access.presentative_datapath_of_vbd <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> sr <span style=color:#f92672>=</span> Db.SR.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:(</span>Db.VDI.get_SR <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>{</span>vdi<span style=color:#f92672>;</span> dp<span style=color:#f92672>;</span> location<span style=color:#f92672>;</span> sr<span style=color:#f92672>;</span> xenops_locator<span style=color:#f92672>;</span> size<span style=color:#f92672>;</span> snapshot_of<span style=color:#f92672>;</span> do_mirror<span style=color:#f92672>}</span></span></span></code></pre></div><p>The record is helpfully commented above:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> vdi_mirror <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  vdi <span style=color:#f92672>:</span> <span style=color:#f92672>[</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>VDI</span> <span style=color:#f92672>]</span> API.Ref.t<span style=color:#f92672>;</span>           <span style=color:#75715e>(* The API reference of the local VDI *)</span>
</span></span><span style=display:flex><span>  dp <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>                        <span style=color:#75715e>(* The datapath the VDI will be using if the VM is running *)</span>
</span></span><span style=display:flex><span>  location <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>                  <span style=color:#75715e>(* The location of the VDI in the current SR *)</span>
</span></span><span style=display:flex><span>  sr <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>                        <span style=color:#75715e>(* The VDI&#39;s current SR uuid *)</span>
</span></span><span style=display:flex><span>  xenops_locator <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>            <span style=color:#75715e>(* The &#39;locator&#39; xenops uses to refer to the VDI on the current host *)</span>
</span></span><span style=display:flex><span>  size <span style=color:#f92672>:</span> Int64.t<span style=color:#f92672>;</span>                     <span style=color:#75715e>(* Size of the VDI *)</span>
</span></span><span style=display:flex><span>  snapshot_of <span style=color:#f92672>:</span> <span style=color:#f92672>[</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>VDI</span> <span style=color:#f92672>]</span> API.Ref.t<span style=color:#f92672>;</span>   <span style=color:#75715e>(* API&#39;s snapshot_of reference *)</span>
</span></span><span style=display:flex><span>  do_mirror <span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span><span style=color:#f92672>;</span>                   <span style=color:#75715e>(* Whether we should mirror or just copy the VDI *)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p><code>xenops_locator</code> is <code>&lt;sr uuid>/&lt;vdi uuid></code>, and <code>dp</code> is <code>vbd/&lt;domid>/&lt;device></code> if the VM is running and <code>vbd/&lt;vm_uuid>/&lt;vdi_uuid></code> if not.</p><p>So now we have a list of these records for all VDIs attached to the VM. For these we check explicitly that they&rsquo;re all defined in the <code>vdi_map</code>, the mapping of VDI references to their destination SR references.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  check_vdi_map <span style=color:#f92672>~__</span>context vms_vdis vdi_map<span style=color:#f92672>;</span></span></span></code></pre></div><p>We then figure out the VIF map:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span> <span style=color:#66d9ef>let</span> vif_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> is_intra_pool <span style=color:#66d9ef>then</span> vif_map
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> infer_vif_map <span style=color:#f92672>~__</span>context <span style=color:#f92672>(</span>vifs <span style=color:#f92672>@</span> snapshot_vifs<span style=color:#f92672>)</span> vif_map
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>More sanity checks: We can&rsquo;t do a storage migration if any of the VDIs is a reset-on-boot one - since the state will be lost on the destination when it&rsquo;s attached:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* Block SXM when VM has a VDI with on_boot=reset *)</span>
</span></span><span style=display:flex><span>  List.<span style=color:#f92672>(</span>iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vconf <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> vdi <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>Db.VDI.get_on_boot <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#f92672>==`</span>reset<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.vdi_on_boot_mode_incompatible_with_operation<span style=color:#f92672>,</span> <span style=color:#f92672>[</span>Ref.string_of vdi<span style=color:#f92672>])))</span> vms_vdis<span style=color:#f92672>)</span> <span style=color:#f92672>;</span></span></span></code></pre></div><p>We now consider all of the VDIs associated with the snapshots. As for the VM&rsquo;s VBDs above, we end up with a <code>vdi_mirror</code> list. Note we pass <code>false</code> to the <code>allow_mirror</code> parameter of the <code>get_vdi_mirror</code> function as none of these snapshot VDIs will ever require mirrorring.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> snapshots_vdis <span style=color:#f92672>=</span> List.filter_map <span style=color:#f92672>(</span>vdi_filter <span style=color:#f92672>__</span>context false<span style=color:#f92672>)</span></span></span></code></pre></div><p>Finally we get all of the suspend-image VDIs from all snapshots as well as the actual VM, since it might be suspended itself:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>snapshots_vbds <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> suspends_vdis <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    List.fold_left
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> acc vm <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span> Db.VM.get_power_state <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#f92672>=</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>Suspended</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>let</span> vdi <span style=color:#f92672>=</span> Db.VM.get_suspend_VDI <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>let</span> sr <span style=color:#f92672>=</span> Db.VDI.get_SR <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>if</span> is_intra_pool <span style=color:#f92672>&amp;&amp;</span> Helpers.host_has_pbd_for_sr <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>host<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>dest_host <span style=color:#f92672>~</span>sr
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>then</span> acc
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>else</span> <span style=color:#f92672>(</span>get_vdi_mirror <span style=color:#f92672>__</span>context vm vdi false<span style=color:#f92672>)::</span> acc
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>else</span> acc<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      [] vm_and_snapshots <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Sanity check that we can see all of the suspend-image VDIs on this host:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span> <span style=color:#75715e>(* Double check that all of the suspend VDIs are all visible on the source *)</span>
</span></span><span style=display:flex><span>  List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vdi_mirror <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> sr <span style=color:#f92672>=</span> Db.VDI.get_SR <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi_mirror<span style=color:#f92672>.</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not <span style=color:#f92672>(</span>Helpers.host_has_pbd_for_sr <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>host<span style=color:#f92672>:</span>localhost <span style=color:#f92672>~</span>sr<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span> <span style=color:#f92672>(</span>Api_errors.suspend_image_not_accessible<span style=color:#f92672>,</span> <span style=color:#f92672>[</span> Ref.string_of vdi_mirror<span style=color:#f92672>.</span>vdi <span style=color:#f92672>])))</span> suspends_vdis<span style=color:#f92672>;</span></span></span></code></pre></div><p>Next is a fairly complex piece that determines the destination SR for all of these VDIs. We don&rsquo;t require API uses to decide destinations for all of the VDIs on snapshots and hence we have to make some decisions here:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_pool <span style=color:#f92672>=</span> List.hd <span style=color:#f92672>(</span>XenAPI.Pool.get_all remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> default_sr_ref <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    XenAPI.Pool.get_default_SR remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_pool <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> suspend_sr_ref <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pool_suspend_SR <span style=color:#f92672>=</span> XenAPI.Pool.get_suspend_image_SR remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_pool
</span></span><span style=display:flex><span>    <span style=color:#f92672>and</span> host_suspend_SR <span style=color:#f92672>=</span> XenAPI.Host.get_suspend_image_sr remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session remote<span style=color:#f92672>.</span>dest_host <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pool_suspend_SR <span style=color:#f92672>&lt;&gt;</span> Ref.null <span style=color:#66d9ef>then</span> pool_suspend_SR <span style=color:#66d9ef>else</span> host_suspend_SR <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Resolve placement of unspecified VDIs here - unspecified VDIs that
</span></span></span><span style=display:flex><span><span style=color:#75715e>            are &#39;snapshot_of&#39; a specified VDI go to the same place. suspend VDIs
</span></span></span><span style=display:flex><span><span style=color:#75715e>            that are unspecified go to the suspend_sr_ref defined above *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> extra_vdis <span style=color:#f92672>=</span> suspends_vdis <span style=color:#f92672>@</span> snapshots_vdis <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> extra_vdi_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    List.map
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vconf <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>let</span> dest_sr_ref <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>let</span> is_mapped <span style=color:#f92672>=</span> List.mem_assoc vconf<span style=color:#f92672>.</span>vdi vdi_map
</span></span><span style=display:flex><span>           <span style=color:#f92672>and</span> snapshot_of_is_mapped <span style=color:#f92672>=</span> List.mem_assoc vconf<span style=color:#f92672>.</span>snapshot_of vdi_map
</span></span><span style=display:flex><span>           <span style=color:#f92672>and</span> is_suspend_vdi <span style=color:#f92672>=</span> List.mem vconf suspends_vdis
</span></span><span style=display:flex><span>           <span style=color:#f92672>and</span> remote_has_suspend_sr <span style=color:#f92672>=</span> suspend_sr_ref <span style=color:#f92672>&lt;&gt;</span> Ref.null
</span></span><span style=display:flex><span>           <span style=color:#f92672>and</span> remote_has_default_sr <span style=color:#f92672>=</span> default_sr_ref <span style=color:#f92672>&lt;&gt;</span> Ref.null <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>let</span> log_prefix <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>             Printf.sprintf <span style=color:#e6db74>&#34;Resolving VDI-&gt;SR map for VDI %s:&#34;</span> <span style=color:#f92672>(</span>Db.VDI.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>if</span> is_mapped <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s VDI has been specified in the map&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             List.assoc vconf<span style=color:#f92672>.</span>vdi vdi_map
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> snapshot_of_is_mapped <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s Snapshot VDI has entry in map for it&#39;s snapshot_of link&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             List.assoc vconf<span style=color:#f92672>.</span>snapshot_of vdi_map
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> is_suspend_vdi <span style=color:#f92672>&amp;&amp;</span> remote_has_suspend_sr <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s Mapping suspend VDI to remote suspend SR&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             suspend_sr_ref
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> is_suspend_vdi <span style=color:#f92672>&amp;&amp;</span> remote_has_default_sr <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s Remote suspend SR not set, mapping suspend VDI to remote default SR&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             default_sr_ref
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> remote_has_default_sr <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s Mapping unspecified VDI to remote default SR&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             default_sr_ref
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             error <span style=color:#e6db74>&#34;%s VDI not in VDI-&gt;SR map and no remote default SR is set&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.vdi_not_in_map<span style=color:#f92672>,</span> <span style=color:#f92672>[</span> Ref.string_of vconf<span style=color:#f92672>.</span>vdi <span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>         <span style=color:#f92672>(</span>vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>,</span> dest_sr_ref<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>      extra_vdis <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>At the end of this we&rsquo;ve got all of the VDIs that need to be copied and destinations for all of them:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdi_map <span style=color:#f92672>=</span> vdi_map <span style=color:#f92672>@</span> extra_vdi_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> all_vdis <span style=color:#f92672>=</span> vms_vdis <span style=color:#f92672>@</span> extra_vdis <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* The vdi_map should be complete at this point - it should include all the
</span></span></span><span style=display:flex><span><span style=color:#75715e>     VDIs in the all_vdis list. *)</span></span></span></code></pre></div><p>Now we gather some final information together:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  assert_no_cbt_enabled_vdi_migrated <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vdi_map<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dbg <span style=color:#f92672>=</span> Context.string_of_task <span style=color:#f92672>__</span>context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Xapi_xenops_queue</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> queue_name <span style=color:#f92672>=</span> queue_of_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>XenopsAPI</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>val</span> make_client queue_name <span style=color:#f92672>:</span> <span style=color:#a6e22e>XENOPS</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_vdis <span style=color:#f92672>=</span> ref [] <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> ha_always_run_reset <span style=color:#f92672>=</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> Db.VM.get_ha_always_run <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> cd_vbds <span style=color:#f92672>=</span> find_cds_to_eject <span style=color:#f92672>__</span>context vdi_map vbds <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  eject_cds <span style=color:#f92672>__</span>context cd_vbds<span style=color:#f92672>;</span></span></span></code></pre></div><p>check there&rsquo;s no CBT (we can&rsquo;t currently migrate the CBT metadata), make our client to talk to Xenopsd, make a mutable list of remote VDIs (which I think is redundant right now), decide whether we need to do anything for HA (we disable HA protection for this VM on the destination until it&rsquo;s fully migrated) and eject any CDs from the VM.</p><p>Up until now this has mostly been gathering info (aside from the ejecting CDs bit), but now we&rsquo;ll start to do some actions, so we begin a <code>try-catch</code> block:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>try</span></span></span></code></pre></div><p>but we&rsquo;ve still got a bit of thinking to do: we sort the VDIs to copy based on age/size:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#75715e>(* Sort VDIs by size in principle and then age secondly. This gives better
</span></span></span><span style=display:flex><span><span style=color:#75715e>       chances that similar but smaller VDIs would arrive comparatively
</span></span></span><span style=display:flex><span><span style=color:#75715e>       earlier, which can serve as base for incremental copying the larger
</span></span></span><span style=display:flex><span><span style=color:#75715e>       ones. *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> compare_fun v1 v2 <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> Int64.compare v1<span style=color:#f92672>.</span>size v2<span style=color:#f92672>.</span>size <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> r <span style=color:#f92672>=</span> 0 <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> t1 <span style=color:#f92672>=</span> Date.to_unix_time <span style=color:#f92672>(</span>Db.VDI.get_snapshot_time <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>v1<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> t2 <span style=color:#f92672>=</span> Date.to_unix_time <span style=color:#f92672>(</span>Db.VDI.get_snapshot_time <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>v2<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        compare t1 t2
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> r <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> all_vdis <span style=color:#f92672>=</span> all_vdis <span style=color:#f92672>|&gt;</span> List.sort compare_fun <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> total_size <span style=color:#f92672>=</span> List.fold_left <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> acc vconf <span style=color:#f92672>-&gt;</span> Int64.add acc vconf<span style=color:#f92672>.</span>size<span style=color:#f92672>)</span> 0L all_vdis <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> so_far <span style=color:#f92672>=</span> ref 0L <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>OK, let&rsquo;s copy/mirror:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    with_many <span style=color:#f92672>(</span>vdi_copy_fun <span style=color:#f92672>__</span>context dbg vdi_map remote is_intra_pool remote_vdis so_far total_size copy<span style=color:#f92672>)</span> all_vdis <span style=color:#f92672>@@</span> <span style=color:#66d9ef>fun</span> all_map <span style=color:#f92672>-&gt;</span></span></span></code></pre></div><p>The copy functions are written such that they take continuations. This it to make the error handling simpler - each individual component function can perform its setup and execute the continuation. In the event of an exception coming from the continuation it can then unroll its bit of state and rethrow the exception for the next layer to handle.</p><p><code>with_many</code> is a simple helper function for nesting invocations of functions that take continuations. It has the delightful type:</p><div class="highlight wrap-code"><pre tabindex=0><code>(&#39;a -&gt; (&#39;b -&gt; &#39;c) -&gt; &#39;c) -&gt; &#39;a list -&gt; (&#39;b list -&gt; &#39;c) -&gt; &#39;c</code></pre></div><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* Helper function to apply a &#39;with_x&#39; function to a list *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> with_many withfn many fn <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> inner l acc <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> l <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> [] <span style=color:#f92672>-&gt;</span> fn acc
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> x<span style=color:#f92672>::</span>xs <span style=color:#f92672>-&gt;</span> withfn x <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> y <span style=color:#f92672>-&gt;</span> inner xs <span style=color:#f92672>(</span>y<span style=color:#f92672>::</span>acc<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span> inner many []</span></span></code></pre></div><p>As an example of its operation, imagine our withfn is as follows:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> withfn x c <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  Printf.printf <span style=color:#e6db74>&#34;Starting withfn: x=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> x<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    c <span style=color:#f92672>(</span>string_of_int x<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    Printf.printf <span style=color:#e6db74>&#34;Handling exception for x=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> x<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> e<span style=color:#f92672>;;</span></span></span></code></pre></div><p>applying this gives the output:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>utop <span style=color:#f92672>#</span> with_many withfn <span style=color:#f92672>[</span>1<span style=color:#f92672>;</span>2<span style=color:#f92672>;</span>3<span style=color:#f92672>;</span>4<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>String.concat <span style=color:#e6db74>&#34;,&#34;</span><span style=color:#f92672>);;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>1
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>2
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>3
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>4
</span></span><span style=display:flex><span><span style=color:#f92672>-</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;4,3,2,1&#34;</span></span></span></code></pre></div><p>whereas raising an exception in the continutation results in the following:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>utop <span style=color:#f92672>#</span> with_many with_fn <span style=color:#f92672>[</span>1<span style=color:#f92672>;</span>2<span style=color:#f92672>;</span>3<span style=color:#f92672>;</span>4<span style=color:#f92672>]</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#e6db74>&#34;error&#34;</span><span style=color:#f92672>);;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>1
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>2
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>3
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>4
</span></span><span style=display:flex><span><span style=color:#a6e22e>Handling</span> <span style=color:#66d9ef>exception</span> <span style=color:#66d9ef>for</span> x<span style=color:#f92672>=</span>4
</span></span><span style=display:flex><span><span style=color:#a6e22e>Handling</span> <span style=color:#66d9ef>exception</span> <span style=color:#66d9ef>for</span> x<span style=color:#f92672>=</span>3
</span></span><span style=display:flex><span><span style=color:#a6e22e>Handling</span> <span style=color:#66d9ef>exception</span> <span style=color:#66d9ef>for</span> x<span style=color:#f92672>=</span>2
</span></span><span style=display:flex><span><span style=color:#a6e22e>Handling</span> <span style=color:#66d9ef>exception</span> <span style=color:#66d9ef>for</span> x<span style=color:#f92672>=</span>1
</span></span><span style=display:flex><span><span style=color:#a6e22e>Exception</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Failure</span> <span style=color:#e6db74>&#34;error&#34;</span><span style=color:#f92672>.</span></span></span></code></pre></div><p>All the real action is in <code>vdi_copy_fun</code>, which copies or mirrors a single VDI:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> vdi_copy_fun <span style=color:#f92672>__</span>context dbg vdi_map remote is_intra_pool remote_vdis so_far total_size copy vconf continuation <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Storage_access</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_sr_ref <span style=color:#f92672>=</span> List.assoc vconf<span style=color:#f92672>.</span>vdi vdi_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_sr_uuid <span style=color:#f92672>=</span> XenAPI.SR.get_uuid remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_sr_ref <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Plug the destination shared SR into destination host and pool master if unplugged.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     Plug the local SR into destination host only if unplugged *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_pool <span style=color:#f92672>=</span> List.hd <span style=color:#f92672>(</span>XenAPI.Pool.get_all remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> master_host <span style=color:#f92672>=</span> XenAPI.Pool.get_master remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_pool <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pbds <span style=color:#f92672>=</span> XenAPI.SR.get_PBDs remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_sr_ref <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pbd_host_pair <span style=color:#f92672>=</span> List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> pbd <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span>pbd<span style=color:#f92672>,</span> XenAPI.PBD.get_host remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session pbd<span style=color:#f92672>))</span> pbds <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> hosts_to_be_attached <span style=color:#f92672>=</span> <span style=color:#f92672>[</span>master_host<span style=color:#f92672>;</span> remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>]</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pbds_to_be_plugged <span style=color:#f92672>=</span> List.filter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(_,</span> host<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span>List.mem host hosts_to_be_attached<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>(</span>XenAPI.Host.get_enabled remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session host<span style=color:#f92672>))</span> pbd_host_pair <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>pbd<span style=color:#f92672>,</span> <span style=color:#f92672>_)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not <span style=color:#f92672>(</span>XenAPI.PBD.get_currently_attached remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session pbd<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        XenAPI.PBD.plug remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session pbd<span style=color:#f92672>)</span> pbds_to_be_plugged<span style=color:#f92672>;</span></span></span></code></pre></div><p>It begins by attempting to ensure the SRs we require are definitely attached on the destination host and on the destination pool master.</p><p>There&rsquo;s now a little logic to support the case where we have cross-pool SRs and the VDI is already visible to the destination pool. Since this is outside our normal support envelope there is a key in xapi_globs that has to be set (via xapi.conf) to enable this:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> dest_vdi_exists_on_sr vdi_uuid sr_ref retry <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> dest_vdi_ref <span style=color:#f92672>=</span> XenAPI.VDI.get_by_uuid remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session vdi_uuid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> dest_vdi_sr_ref <span style=color:#f92672>=</span> XenAPI.VDI.get_SR remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_vdi_ref <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> dest_vdi_sr_ref <span style=color:#f92672>=</span> sr_ref <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        true
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        false
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> retry <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>          XenAPI.SR.scan remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session sr_ref<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          dest_vdi_exists_on_sr vdi_uuid sr_ref false
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        false
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* CP-4498 added an unsupported mode to use cross-pool shared SRs - the initial
</span></span></span><span style=display:flex><span><span style=color:#75715e>     use case is for a shared raw iSCSI SR (same uuid, same VDI uuid) *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdi_uuid <span style=color:#f92672>=</span> Db.VDI.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> mirror <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>Xapi_globs.relax_xsm_sr_check <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>dest_sr_uuid <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>sr<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(* Check if the VDI uuid already exists in the target SR *)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>dest_vdi_exists_on_sr vdi_uuid dest_sr_ref true<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            false
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            failwith <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;SR UUID matches on destination but VDI does not exist&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        true
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span>not is_intra_pool<span style=color:#f92672>)</span> <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>dest_sr_uuid <span style=color:#f92672>&lt;&gt;</span> vconf<span style=color:#f92672>.</span>sr<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>The check also covers the case where we&rsquo;re doing an intra-pool migration and not copying all of the disks, in which case we don&rsquo;t need to do anything for that disk.</p><p>We now have a wrapper function that creates a new datapath and passes it to a continuation function. On error it handles the destruction of the datapath:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> with_new_dp cont <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dp <span style=color:#f92672>=</span> Printf.sprintf <span style=color:#f92672>(</span><span style=color:#66d9ef>if</span> vconf<span style=color:#f92672>.</span>do_mirror <span style=color:#66d9ef>then</span> <span style=color:#e6db74>&#34;mirror_%s&#34;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;copy_%s&#34;</span><span style=color:#f92672>)</span> vconf<span style=color:#f92672>.</span>dp <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> cont dp
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>try</span> SMAPI.DP.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>allow_leak<span style=color:#f92672>:</span>false <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> info <span style=color:#e6db74>&#34;Failed to cleanup datapath: %s&#34;</span> dp<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> e <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>and now a helper that, given a remote VDI uuid, looks up the reference on the remote host and gives it to a continuation function. On failure of the continuation it will destroy the remote VDI:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> with_remote_vdi remote_vdi cont <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Executing remote scan to ensure VDI is known to xapi&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    XenAPI.SR.scan remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_sr_ref<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> query <span style=color:#f92672>=</span> Printf.sprintf <span style=color:#e6db74>&#34;(field </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>location</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>=</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>%s</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>) and (field </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>SR</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>=</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>%s</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>)&#34;</span> remote_vdi <span style=color:#f92672>(</span>Ref.string_of dest_sr_ref<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> XenAPI.VDI.get_all_records_where remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session query <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> remote_vdi_ref <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> vdis <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> [] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.vdi_location_missing<span style=color:#f92672>,</span> <span style=color:#f92672>[</span>Ref.string_of dest_sr_ref<span style=color:#f92672>;</span> remote_vdi<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> h <span style=color:#f92672>::</span> [] <span style=color:#f92672>-&gt;</span> debug <span style=color:#e6db74>&#34;Found remote vdi reference: %s&#34;</span> <span style=color:#f92672>(</span>Ref.string_of <span style=color:#f92672>(</span>fst h<span style=color:#f92672>));</span> fst h
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.location_not_unique<span style=color:#f92672>,</span> <span style=color:#f92672>[</span>Ref.string_of dest_sr_ref<span style=color:#f92672>;</span> remote_vdi<span style=color:#f92672>]))</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> cont remote_vdi_ref
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>try</span> XenAPI.VDI.destroy remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session remote_vdi_ref <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> error <span style=color:#e6db74>&#34;Failed to destroy remote VDI&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> e <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>another helper to gather together info about a mirrored VDI:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> get_mirror_record <span style=color:#f92672>?</span>new_dp remote_vdi remote_vdi_reference <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span> mr_dp <span style=color:#f92672>=</span> new_dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_mirrored <span style=color:#f92672>=</span> mirror<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_local_sr <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>sr<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_local_vdi <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>location<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_remote_sr <span style=color:#f92672>=</span> dest_sr_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_remote_vdi <span style=color:#f92672>=</span> remote_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_local_xenops_locator <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>xenops_locator<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_remote_xenops_locator <span style=color:#f92672>=</span> Xapi_xenops.xenops_vdi_locator_of_strings dest_sr_uuid remote_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_local_vdi_reference <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_remote_vdi_reference <span style=color:#f92672>=</span> remote_vdi_reference <span style=color:#f92672>}</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>and finally the really important function:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> mirror_to_remote new_dp <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> task <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not vconf<span style=color:#f92672>.</span>do_mirror <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        SMAPI.DATA.copy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>location <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>new_dp <span style=color:#f92672>~</span>url<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>sm_url <span style=color:#f92672>~</span>dest<span style=color:#f92672>:</span>dest_sr_uuid
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(* Though we have no intention of &#34;write&#34;, here we use the same mode as the
</span></span></span><span style=display:flex><span><span style=color:#75715e>           associated VBD on a mirrored VDIs (i.e. always RW). This avoids problem
</span></span></span><span style=display:flex><span><span style=color:#75715e>           when we need to start/stop the VM along the migration. *)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> read_write <span style=color:#f92672>=</span> true <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(* DP set up is only essential for MIRROR.start/stop due to their open ended pattern.
</span></span></span><span style=display:flex><span><span style=color:#75715e>           It&#39;s not necessary for copy which will take care of that itself. *)</span>
</span></span><span style=display:flex><span>        ignore<span style=color:#f92672>(</span>SMAPI.VDI.attach <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>new_dp <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>location <span style=color:#f92672>~</span>read_write<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        SMAPI.VDI.activate <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>new_dp <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>location<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        ignore<span style=color:#f92672>(</span>Storage_access.register_mirror <span style=color:#f92672>__</span>context vconf<span style=color:#f92672>.</span>location<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        SMAPI.DATA.MIRROR.start <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>location <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>new_dp <span style=color:#f92672>~</span>url<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>sm_url <span style=color:#f92672>~</span>dest<span style=color:#f92672>:</span>dest_sr_uuid
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mapfn x <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> total <span style=color:#f92672>=</span> Int64.to_float total_size <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> done_ <span style=color:#f92672>=</span> Int64.to_float <span style=color:#f92672>!</span>so_far <span style=color:#f92672>/.</span> total <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> remaining <span style=color:#f92672>=</span> Int64.to_float vconf<span style=color:#f92672>.</span>size <span style=color:#f92672>/.</span> total <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      done_ <span style=color:#f92672>+.</span> x <span style=color:#f92672>*.</span> remaining <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Storage_access</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> task_result <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      task <span style=color:#f92672>|&gt;</span> register_task <span style=color:#f92672>__</span>context
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> add_to_progress_map mapfn
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> wait_for_task dbg
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> remove_from_progress_map
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> unregister_task <span style=color:#f92672>__</span>context
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> success_task dbg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mirror_id<span style=color:#f92672>,</span> remote_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not vconf<span style=color:#f92672>.</span>do_mirror <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> vdi <span style=color:#f92672>=</span> task_result <span style=color:#f92672>|&gt;</span> vdi_of_task dbg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        remote_vdis <span style=color:#f92672>:=</span> vdi<span style=color:#f92672>.</span>vdi <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>remote_vdis<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>None</span><span style=color:#f92672>,</span> vdi<span style=color:#f92672>.</span>vdi
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> mirrorid <span style=color:#f92672>=</span> task_result <span style=color:#f92672>|&gt;</span> mirror_of_task dbg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> m <span style=color:#f92672>=</span> SMAPI.DATA.MIRROR.stat <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>:</span>mirrorid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Some</span> mirrorid<span style=color:#f92672>,</span> m<span style=color:#f92672>.</span>Mirror.dest_vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    so_far <span style=color:#f92672>:=</span> Int64.add <span style=color:#f92672>!</span>so_far vconf<span style=color:#f92672>.</span>size<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Local VDI %s %s to %s&#34;</span> vconf<span style=color:#f92672>.</span>location <span style=color:#f92672>(</span><span style=color:#66d9ef>if</span> vconf<span style=color:#f92672>.</span>do_mirror <span style=color:#66d9ef>then</span> <span style=color:#e6db74>&#34;mirrored&#34;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;copied&#34;</span><span style=color:#f92672>)</span> remote_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    mirror_id<span style=color:#f92672>,</span> remote_vdi <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This is the bit that actually starts the mirroring or copying. Before the call to mirror we call <code>VDI.attach</code> and <code>VDI.activate</code> locally to ensure that if the VM is shutdown then the detach/deactivate there doesn&rsquo;t kill the mirroring process.</p><p>Note the parameters to the SMAPI call are <code>sr</code> and <code>vdi</code>, locating the local VDI and SM backend, <code>new_dp</code>, the datapath we&rsquo;re using for the mirroring, <code>url</code>, which is the remote url on which SMAPI calls work, and <code>dest</code>, the destination SR uuid. These are also the arguments to <code>copy</code> above too.</p><p>There&rsquo;s a little function to calculate the overall progress of the task, and the function waits until the completion of the task before it continues. The function <code>success_task</code> will raise an exception if the task failed. For <code>DATA.mirror</code>, completion implies both that the disk data has been copied to the destination and that all local writes are being mirrored to the destination. Hence more cleanup must be done on cancellation. In contrast, if the <code>DATA.copy</code> path had been taken then the operation at this point has completely finished.</p><p>The result of this function is an optional mirror id and the remote VDI uuid.</p><p>Next, there is a <code>post_mirror</code> function:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> post_mirror mirror_id mirror_record <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> continuation mirror_record <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>match</span> mirror_id <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> mid <span style=color:#f92672>-&gt;</span> ignore<span style=color:#f92672>(</span>Storage_access.unregister_mirror mid<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> mirror <span style=color:#f92672>&amp;&amp;</span> not <span style=color:#f92672>(</span>Xapi_fist.storage_motion_keep_vdi () <span style=color:#f92672>||</span> copy<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        Helpers.call_api_functions <span style=color:#f92672>~__</span>context <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> rpc session_id <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            XenAPI.VDI.destroy rpc session_id vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      result
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> mirror_failed <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> mirror_id <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> mid <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          ignore<span style=color:#f92672>(</span>Storage_access.unregister_mirror mid<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> m <span style=color:#f92672>=</span> SMAPI.DATA.MIRROR.stat <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>:</span>mid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span><span style=color:#66d9ef>try</span> SMAPI.DATA.MIRROR.stop <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>:</span>mid <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          m<span style=color:#f92672>.</span>Mirror.failed
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> false <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> mirror_failed <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.mirror_failed<span style=color:#f92672>,[</span>Ref.string_of vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>raise</span> e <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This is poorly named - it is post mirror <em>and</em> copy. The aim of this function is to destroy the source VDIs on successful completion of the continuation function, which will have migrated the VM to the destination. In its exception handler it will stop the mirroring, but before doing so it will check to see if the mirroring process it was looking after has itself failed, and raise <code>mirror_failed</code> if so. This is because a failed mirror can result in a range of actual errors, and we decide here that the failed mirror was probably the root cause.</p><p>These functions are assembled together at the end of the <code>vdi_copy_fun</code> function:</p><div class="highlight wrap-code"><pre tabindex=0><code>   if mirror then
    with_new_dp (fun new_dp -&gt;
        let mirror_id, remote_vdi = mirror_to_remote new_dp in
        with_remote_vdi remote_vdi (fun remote_vdi_ref -&gt;
            let mirror_record = get_mirror_record ~new_dp remote_vdi remote_vdi_ref in
            post_mirror mirror_id mirror_record))
  else
    let mirror_record = get_mirror_record vconf.location (XenAPI.VDI.get_by_uuid remote.rpc remote.session vdi_uuid) in
    continuation mirror_record</code></pre></div><p>again, <code>mirror</code> here is poorly named, and means mirror <em>or</em> copy.</p><p>Once all of the disks have been mirrored or copied, we jump back to the body of <code>migrate_send</code>. We split apart the mirror records according to the source of the VDI:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#66d9ef>let</span> was_from vmap <span style=color:#f92672>=</span> List.exists <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vconf <span style=color:#f92672>-&gt;</span> vconf<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> vmap<span style=color:#f92672>.</span>mr_local_vdi_reference<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> suspends_map<span style=color:#f92672>,</span> snapshots_map<span style=color:#f92672>,</span> vdi_map <span style=color:#f92672>=</span> List.fold_left <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>suspends<span style=color:#f92672>,</span> snapshots<span style=color:#f92672>,</span> vdis<span style=color:#f92672>)</span> vmap <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> was_from vmap suspends_vdis <span style=color:#66d9ef>then</span>  vmap <span style=color:#f92672>::</span> suspends<span style=color:#f92672>,</span> snapshots<span style=color:#f92672>,</span> vdis
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> was_from vmap snapshots_vdis <span style=color:#66d9ef>then</span> suspends<span style=color:#f92672>,</span> vmap <span style=color:#f92672>::</span> snapshots<span style=color:#f92672>,</span> vdis
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span> suspends<span style=color:#f92672>,</span> snapshots<span style=color:#f92672>,</span> vmap <span style=color:#f92672>::</span> vdis
</span></span><span style=display:flex><span>        <span style=color:#f92672>)</span> <span style=color:#f92672>(</span>[]<span style=color:#f92672>,</span>[]<span style=color:#f92672>,</span>[]<span style=color:#f92672>)</span> all_map <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>then we reassemble all_map from this, for some reason:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> all_map <span style=color:#f92672>=</span> List.concat <span style=color:#f92672>[</span>suspends_map<span style=color:#f92672>;</span> snapshots_map<span style=color:#f92672>;</span> vdi_map<span style=color:#f92672>]</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Now we need to update the snapshot-of links:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>     <span style=color:#75715e>(* All the disks and snapshots have been created in the remote SR(s),
</span></span></span><span style=display:flex><span><span style=color:#75715e>       * so update the snapshot links if there are any snapshots. *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> snapshots_map <span style=color:#f92672>&lt;&gt;</span> [] <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        update_snapshot_info <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>url<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>sm_url <span style=color:#f92672>~</span>vdi_map <span style=color:#f92672>~</span>snapshots_map<span style=color:#f92672>;</span></span></span></code></pre></div><p>I&rsquo;m not entirely sure why this is done in this layer as opposed to in the storage layer.</p><p>A little housekeeping:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>     <span style=color:#66d9ef>let</span> xenops_vdi_map <span style=color:#f92672>=</span> List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> mirror_record <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span>mirror_record<span style=color:#f92672>.</span>mr_local_xenops_locator<span style=color:#f92672>,</span> mirror_record<span style=color:#f92672>.</span>mr_remote_xenops_locator<span style=color:#f92672>))</span> all_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* Wait for delay fist to disappear *)</span>
</span></span><span style=display:flex><span>      wait_for_fist <span style=color:#f92672>__</span>context Xapi_fist.pause_storage_migrate <span style=color:#e6db74>&#34;pause_storage_migrate&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span></span></span></code></pre></div><p>the <code>fist</code> thing here simply allows tests to put in a delay at this specific point.</p><p>We also check the task to see if we&rsquo;ve been cancelled and raise an exception if so.</p><p>The VM metadata is now imported into the remote pool, with all the XenAPI level objects remapped:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> new_vm <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_intra_pool
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>then</span> vm
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(* Make sure HA replaning cycle won&#39;t occur right during the import process or immediately after *)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> ha_always_run_reset <span style=color:#66d9ef>then</span> XenAPI.Pool.ha_prevent_restarts_for <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>seconds<span style=color:#f92672>:(</span>Int64.of_float <span style=color:#f92672>!</span>Xapi_globs.ha_monitor_interval<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(* Move the xapi VM metadata to the remote pool. *)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> vms <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vdi_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>              List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> mirror_record <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    local_vdi_reference <span style=color:#f92672>=</span> mirror_record<span style=color:#f92672>.</span>mr_local_vdi_reference<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    remote_vdi_reference <span style=color:#f92672>=</span> <span style=color:#a6e22e>Some</span> mirror_record<span style=color:#f92672>.</span>mr_remote_vdi_reference<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>                all_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vif_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>              List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>vif<span style=color:#f92672>,</span> network<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    local_vif_reference <span style=color:#f92672>=</span> vif<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    remote_network_reference <span style=color:#f92672>=</span> network<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>                vif_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vgpu_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>              List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>vgpu<span style=color:#f92672>,</span> gpu_group<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    local_vgpu_reference <span style=color:#f92672>=</span> vgpu<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    remote_gpu_group_reference <span style=color:#f92672>=</span> gpu_group<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>                vgpu_map
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            inter_pool_metadata_transfer <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>remote <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>vdi_map
</span></span><span style=display:flex><span>              <span style=color:#f92672>~</span>vif_map <span style=color:#f92672>~</span>vgpu_map <span style=color:#f92672>~</span>dry_run<span style=color:#f92672>:</span>false <span style=color:#f92672>~</span>live<span style=color:#f92672>:</span>true <span style=color:#f92672>~</span>copy
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> vm <span style=color:#f92672>=</span> List.hd vms <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> ha_always_run_reset <span style=color:#66d9ef>then</span> XenAPI.VM.set_ha_always_run <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#f92672>~</span><span style=color:#66d9ef>value</span><span style=color:#f92672>:</span>false <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(* Reserve resources for the new VM on the destination pool&#39;s host *)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span> XenAPI.Host.allocate_resources_for_vm remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session remote<span style=color:#f92672>.</span>dest_host vm true <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          vm <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>More waiting for fist points:</p><div class="highlight wrap-code"><pre tabindex=0><code>     wait_for_fist __context Xapi_fist.pause_storage_migrate2 &#34;pause_storage_migrate2&#34;;

      (* Attach networks on remote *)
      XenAPI.Network.attach_for_vm ~rpc:remote.rpc ~session_id:remote.session ~host:remote.dest_host ~vm:new_vm;</code></pre></div><p>also make sure all the networks are plugged for the VM on the destination.
Next we create the xenopsd-level vif map, equivalent to the vdi_map above:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* Create the vif-map for xenops, linking VIF devices to bridge names on the remote *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> xenops_vif_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> vifs <span style=color:#f92672>=</span> XenAPI.VM.get_VIFs <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>new_vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vif <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vifr <span style=color:#f92672>=</span> XenAPI.VIF.get_record <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vif <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> bridge <span style=color:#f92672>=</span> Xenops_interface.Network.<span style=color:#a6e22e>Local</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>(</span>XenAPI.Network.get_bridge <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vifr<span style=color:#f92672>.</span>API.vIF_network<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            vifr<span style=color:#f92672>.</span>API.vIF_device<span style=color:#f92672>,</span> bridge
</span></span><span style=display:flex><span>          <span style=color:#f92672>)</span> vifs
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Now we destroy any extra mirror datapaths we set up previously:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>     <span style=color:#75715e>(* Destroy the local datapaths - this allows the VDIs to properly detach, invoking the migrate_finalize calls *)</span>
</span></span><span style=display:flex><span>      List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> mirror_record <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> mirror_record<span style=color:#f92672>.</span>mr_mirrored
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>match</span> mirror_record<span style=color:#f92672>.</span>mr_dp <span style=color:#66d9ef>with</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> dp <span style=color:#f92672>-&gt;</span>  SMAPI.DP.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>allow_leak<span style=color:#f92672>:</span>false <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> ()<span style=color:#f92672>)</span> all_map<span style=color:#f92672>;</span></span></span></code></pre></div><p>More housekeeping:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;vm.migrate_send: migration initiated vm:%s&#34;</span> vm_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* In case when we do SXM on the same host (mostly likely a VDI
</span></span></span><span style=display:flex><span><span style=color:#75715e>         migration), the VM&#39;s metadata in xenopsd will be in-place updated
</span></span></span><span style=display:flex><span><span style=color:#75715e>         as soon as the domain migration starts. For these case, there
</span></span></span><span style=display:flex><span><span style=color:#75715e>         will be no (clean) way back from this point. So we disable task
</span></span></span><span style=display:flex><span><span style=color:#75715e>         cancellation for them here.
</span></span></span><span style=display:flex><span><span style=color:#75715e>       *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> is_same_host <span style=color:#66d9ef>then</span> <span style=color:#f92672>(</span>TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span> TaskHelper.set_not_cancellable <span style=color:#f92672>~__</span>context<span style=color:#f92672>);</span></span></span></code></pre></div><p>Finally we get to the memory-image part of the migration:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#75715e>(* It&#39;s acceptable for the VM not to exist at this point; shutdown commutes with storage migrate *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>          Xapi_xenops.Events_from_xenopsd.with_suppressed queue_name dbg vm_uuid
</span></span><span style=display:flex><span>            <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>let</span> xenops_vgpu_map <span style=color:#f92672>=</span> <span style=color:#75715e>(* can raise VGPU_mapping *)</span>
</span></span><span style=display:flex><span>                 infer_vgpu_map <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>remote new_vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>               migrate_with_retry
</span></span><span style=display:flex><span>                 <span style=color:#f92672>~__</span>context queue_name dbg vm_uuid xenops_vdi_map
</span></span><span style=display:flex><span>                 xenops_vif_map xenops_vgpu_map remote<span style=color:#f92672>.</span>xenops_url<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>               Xapi_xenops.Xenopsd_metadata.delete <span style=color:#f92672>~__</span>context vm_uuid<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> Xenops_interface.<span style=color:#a6e22e>Does_not_exist</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;VM&#34;</span><span style=color:#f92672>,_)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> Xenops_interface.<span style=color:#a6e22e>Does_not_exist</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;extra&#34;</span><span style=color:#f92672>,_)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          info <span style=color:#e6db74>&#34;%s: VM %s stopped being live during migration&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;vm_migrate_send&#34;</span> vm_uuid
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>VGPU_mapping</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          info <span style=color:#e6db74>&#34;%s: VM %s - can&#39;t infer vGPU map: %s&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;vm_migrate_send&#34;</span> vm_uuid msg<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>raise</span> Api_errors.
</span></span><span style=display:flex><span>                  <span style=color:#f92672>(</span><span style=color:#a6e22e>Server_error</span>
</span></span><span style=display:flex><span>                     <span style=color:#f92672>(</span>vm_migrate_failed<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                      <span style=color:#f92672>([</span> vm_uuid
</span></span><span style=display:flex><span>                       <span style=color:#f92672>;</span> Helpers.get_localhost_uuid ()
</span></span><span style=display:flex><span>                       <span style=color:#f92672>;</span> Db.Host.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>dest_host
</span></span><span style=display:flex><span>                       <span style=color:#f92672>;</span> <span style=color:#e6db74>&#34;The VM changed its power state during migration&#34;</span>
</span></span><span style=display:flex><span>                       <span style=color:#f92672>])))</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Migration complete&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      SMPERF.debug <span style=color:#e6db74>&#34;vm.migrate_send: migration complete vm:%s&#34;</span> vm_uuid<span style=color:#f92672>;</span></span></span></code></pre></div><p>Now we tidy up after ourselves:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#75715e>(* So far the main body of migration is completed, and the rests are
</span></span></span><span style=display:flex><span><span style=color:#75715e>         updates, config or cleanup on the source and destination. There will
</span></span></span><span style=display:flex><span><span style=color:#75715e>         be no (clean) way back from this point, due to these destructive
</span></span></span><span style=display:flex><span><span style=color:#75715e>         changes, so we don&#39;t want user intervention e.g. task cancellation.
</span></span></span><span style=display:flex><span><span style=color:#75715e>       *)</span>
</span></span><span style=display:flex><span>      TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      TaskHelper.set_not_cancellable <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      XenAPI.VM.pool_migrate_complete remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session new_vm remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      detach_local_network_for_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>destination<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      Xapi_xenops.refresh_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm<span style=color:#f92672>;</span></span></span></code></pre></div><p>the function <code>pool_migrate_complete</code> is called on the destination host, and consists of a few things that ordinarily would be set up during VM.start or the like:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> pool_migrate_complete <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>host <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> Db.VM.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;VM.pool_migrate_complete %s&#34;</span> id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dbg <span style=color:#f92672>=</span> Context.string_of_task <span style=color:#f92672>__</span>context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> queue_name <span style=color:#f92672>=</span> Xapi_xenops_queue.queue_of_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> Xapi_xenops.vm_exists_in_xenopsd queue_name dbg id <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    Cpuid_helpers.update_cpu_flags <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>host<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Xapi_xenops.set_resident_on <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Xapi_xenops.add_caches id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Xapi_xenops.refresh_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Monitor_dbcalls_cache.clear_cache_for_vm <span style=color:#f92672>~</span>vm_uuid<span style=color:#f92672>:</span>id
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span></span></span></code></pre></div><p>More tidying up, remapping some remaining VBDs and clearing state on the sender:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#75715e>(* Those disks that were attached at the point the migration happened will have been
</span></span></span><span style=display:flex><span><span style=color:#75715e>         remapped by the Events_from_xenopsd logic. We need to remap any other disks at
</span></span></span><span style=display:flex><span><span style=color:#75715e>         this point here *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> is_intra_pool
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        List.iter
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vm&#39; <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>             intra_pool_vdi_remap <span style=color:#f92672>~__</span>context vm&#39; all_map<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             intra_pool_fix_suspend_sr <span style=color:#f92672>~__</span>context remote<span style=color:#f92672>.</span>dest_host vm&#39;<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          vm_and_snapshots<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* If it&#39;s an inter-pool migrate, the VBDs will still be &#39;currently-attached=true&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>         because we supressed the events coming from xenopsd. Destroy them, so that the
</span></span></span><span style=display:flex><span><span style=color:#75715e>         VDIs can be destroyed *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> not copy
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>then</span> List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vbd <span style=color:#f92672>-&gt;</span> Db.VBD.destroy <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>vbds <span style=color:#f92672>@</span> snapshots_vbds<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      new_vm
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>The remark about the <code>Events_from_xenopsd</code> is that we have a thread watching for events that are emitted by xenopsd, and we resynchronise xapi&rsquo;s state according to xenopsd&rsquo;s state for several fields for which xenopsd is considered the canonical source of truth. One of these is the exact VDI the VBD is associated with.</p><p>The suspend_SR field of the VM is set to the source&rsquo;s value, so we reset that.</p><p>Now we move the RRDs:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>if</span> not copy <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      Rrdd_proxy.migrate_rrd <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>remote_address<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>remote_ip <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:(</span>Ref.string_of remote<span style=color:#f92672>.</span>session<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>vm_uuid<span style=color:#f92672>:</span>vm_uuid <span style=color:#f92672>~</span>host_uuid<span style=color:#f92672>:(</span>Ref.string_of remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>)</span> ()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>This can be done for intra- and inter- pool migrates in the same way, simplifying the logic.</p><p>However, for messages and blobs we have to only migrate them for inter-pool migrations:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>   <span style=color:#66d9ef>if</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> not copy <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* Replicate HA runtime flag if necessary *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> ha_always_run_reset <span style=color:#66d9ef>then</span> XenAPI.VM.set_ha_always_run <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>new_vm <span style=color:#f92672>~</span><span style=color:#66d9ef>value</span><span style=color:#f92672>:</span>true<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* Send non-database metadata *)</span>
</span></span><span style=display:flex><span>      Xapi_message.send_messages <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>cls<span style=color:#f92672>:`</span><span style=color:#a6e22e>VM</span> <span style=color:#f92672>~</span>obj_uuid<span style=color:#f92672>:</span>vm_uuid
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>remote_address<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>remote_master_ip<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      Xapi_blob.migrate_push <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>remote_address<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>remote_master_ip <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>old_vm<span style=color:#f92672>:</span>vm <span style=color:#f92672>~</span>new_vm <span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* Signal the remote pool that we&#39;re done *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>Lastly, we destroy the VM record on the source:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    Helpers.call_api_functions <span style=color:#f92672>~__</span>context <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> rpc session_id <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> not copy <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>          info <span style=color:#e6db74>&#34;Destroying VM ref=%s uuid=%s&#34;</span> <span style=color:#f92672>(</span>Ref.string_of vm<span style=color:#f92672>)</span> vm_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          Xapi_vm_lifecycle.force_state_reset <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#f92672>~</span><span style=color:#66d9ef>value</span><span style=color:#f92672>:`</span><span style=color:#a6e22e>Halted</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span> Db.VM.destroy <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>)</span> vm_and_snapshots
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;vm.migrate_send exiting vm:%s&#34;</span> vm_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    new_vm</span></span></code></pre></div><p>The exception handler still has to clean some state, but mostly things are handled in the CPS functions declared above:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    error <span style=color:#e6db74>&#34;Caught %s: cleaning up&#34;</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* We do our best to tidy up the state left behind *)</span>
</span></span><span style=display:flex><span>    Events_from_xenopsd.with_suppressed queue_name dbg vm_uuid <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> <span style=color:#f92672>_,</span> state <span style=color:#f92672>=</span> XenopsAPI.VM.stat dbg vm_uuid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> Xenops_interface.<span style=color:#f92672>(</span>state<span style=color:#f92672>.</span>Vm.power_state <span style=color:#f92672>=</span> <span style=color:#a6e22e>Suspended</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            debug <span style=color:#e6db74>&#34;xenops: %s: shutting down suspended VM&#34;</span> vm_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            Xapi_xenops.shutdown <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#a6e22e>None</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> Db.is_valid_ref <span style=color:#f92672>__</span>context vm <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span> Db.VM.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>)</span> vm_and_snapshots
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vm_ref <span style=color:#f92672>=</span> XenAPI.VM.get_by_uuid remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session self <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            info <span style=color:#e6db74>&#34;Destroying stale VM uuid=%s on destination host&#34;</span> self<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            XenAPI.VM.destroy remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session vm_ref
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span> error <span style=color:#e6db74>&#34;Caught %s while destroying VM uuid=%s on destination host&#34;</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>)</span> self<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> task <span style=color:#f92672>=</span> Context.get_task_id <span style=color:#f92672>__</span>context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> oc <span style=color:#f92672>=</span> Db.Task.get_other_config <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>task <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> List.mem_assoc <span style=color:#e6db74>&#34;mirror_failed&#34;</span> oc <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> failed_vdi <span style=color:#f92672>=</span> List.assoc <span style=color:#e6db74>&#34;mirror_failed&#34;</span> oc <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> vconf <span style=color:#f92672>=</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vconf <span style=color:#f92672>-&gt;</span> vconf<span style=color:#f92672>.</span>location<span style=color:#f92672>=</span>failed_vdi<span style=color:#f92672>)</span> vms_vdis <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Mirror failed for VDI: %s&#34;</span> failed_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.mirror_failed<span style=color:#f92672>,[</span>Ref.string_of vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>begin</span> <span style=color:#66d9ef>match</span> e <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> Storage_interface.<span style=color:#a6e22e>Backend_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> Storage_interface.<span style=color:#a6e22e>Unimplemented</span><span style=color:#f92672>(</span>code<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.unimplemented_in_sm_backend<span style=color:#f92672>,</span> <span style=color:#f92672>[</span>code<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> Xenops_interface.<span style=color:#a6e22e>Cancelled</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> TaskHelper.raise_cancelled <span style=color:#f92672>~__</span>context
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> e
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span></span></span></code></pre></div><p>Failures during the migration can result in the VM being in a suspended state. There&rsquo;s no point leaving it like this since there&rsquo;s nothing that can be done to resume it, so we force shut it down.</p><p>We also try to remove the VM record from the destination if we managed to send it there.</p><p>Finally we check for mirror failure in the task - this is set by the events thread watching for events from the storage layer, in <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_access.ml#L1169-L1207 rel=external target=_blank>storage_access.ml</a></p><h3 id=storage-code>Storage code</h3><p>The part of the code that is conceptually in the storage layer, but physically in xapi, is located in
<a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml rel=external target=_blank>storage_migrate.ml</a>. There are logically a few separate parts to this file:</p><ul><li>A <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L34-L204 rel=external target=_blank>stateful module</a> for persisting state across xapi restarts.</li><li>Some general <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L206-L281 rel=external target=_blank>helper functions</a></li><li>Some quite specific <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L206-L281 rel=external target=_blank>helper</a> <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L738-L791 rel=external target=_blank>functions</a> related to actions to be taken on deactivate/detach</li><li>An <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L793-L818 rel=external target=_blank>NBD handler</a></li><li>The implementations of the SMAPIv2 <a href=https://github.com/xapi-project/xcp-idl/blob/master/storage/storage_interface.ml#L430-L460 rel=external target=_blank>mirroring APIs</a></li></ul><p>Let&rsquo;s start by considering the way the storage APIs are intended to be used.</p><h4 id=copying-a-vdi>Copying a VDI</h4><p><code>DATA.copy</code> takes several parameters:</p><ul><li><code>dbg</code> - a debug string</li><li><code>sr</code> - the source SR (a uuid)</li><li><code>vdi</code> - the source VDI (a uuid)</li><li><code>dp</code> - <strong>unused</strong></li><li><code>url</code> - a URL on which SMAPIv2 API calls can be made</li><li><code>sr</code> - the destination SR in which the VDI should be copied</li></ul><p>and returns a parameter of type <code>Task.id</code>. The API call is intended to be called in an asynchronous fashion - ie., the caller makes the call, receives the task ID back and polls or uses the event mechanism to wait until the task has completed. The task may be cancelled via the <code>Task.cancel</code> API call. The result of the operation is obtained by calling TASK.stat, which returns a record:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>	<span style=color:#66d9ef>type</span> t <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>		id<span style=color:#f92672>:</span> id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		dbg<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		ctime<span style=color:#f92672>:</span> <span style=color:#66d9ef>float</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		state<span style=color:#f92672>:</span> state<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		subtasks<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>string</span> <span style=color:#f92672>*</span> state<span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		debug_info<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>string</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		backtrace<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span></span></span></code></pre></div><p>Where the <code>state</code> field contains the result once the task has completed:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> async_result_t <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Vdi_info</span> <span style=color:#66d9ef>of</span> vdi_info
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Mirror_id</span> <span style=color:#66d9ef>of</span> Mirror.id
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> completion_t <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	duration <span style=color:#f92672>:</span> <span style=color:#66d9ef>float</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	result <span style=color:#f92672>:</span> async_result_t option
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> state <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Pending</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>float</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Completed</span> <span style=color:#66d9ef>of</span> completion_t
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Failed</span> <span style=color:#66d9ef>of</span> Rpc.t</span></span></code></pre></div><p>Once the result has been obtained from the task, the task should be destroyed via the <code>TASK.destroy</code> API call.</p><p>The implementation uses the <code>url</code> parameter to make SMAPIv2 calls to the destination SR. This is used, for example, to invoke a VDI.create call if necessary. The URL contains an authentication token within it (valid for the duration of the XenAPI call that caused this DATA.copy API call).</p><p>The implementation tries to minimize the amount of data copied by looking for related VDIs on the destination SR. See below for more details.</p><h4 id=mirroring-a-vdi>Mirroring a VDI</h4><p><code>DATA.MIRROR.start</code> takes a similar set of parameters to that of copy:</p><ul><li><code>dbg</code> - a debug string</li><li><code>sr</code> - the source SR (a uuid)</li><li><code>vdi</code> - the source VDI (a uuid)</li><li><code>dp</code> - the datapath on which the VDI has been attached</li><li><code>url</code> - a URL on which SMAPIv2 API calls can be made</li><li><code>sr</code> - the destination SR in which the VDI should be copied</li></ul><p>Similar to copy above, this returns a task id. The task &lsquo;completes&rsquo; once the mirror has been set up - that is, at any point afterwards we can detach the disk and the destination disk will be identical to the source. Unlike for copy the operation is ongoing after the API call completes, since new writes need to be mirrored to the destination. Therefore the completion type of the mirror operation is <code>Mirror_id</code> which contains a handle on which further API calls related to the mirror call can be made. For example <a href=https://github.com/xapi-project/xcp-idl/blob/a999ef6191629c8f68377f7c412ee98fc6a39dea/storage/storage_interface.ml#L446 rel=external target=_blank>MIRROR.stat</a> whose signature is:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>MIRROR.stat<span style=color:#f92672>:</span> dbg<span style=color:#f92672>:</span>debug_info <span style=color:#f92672>-&gt;</span> id<span style=color:#f92672>:</span>Mirror.id <span style=color:#f92672>-&gt;</span> Mirror.t</span></span></code></pre></div><p>The return type of this call is a record containing information about the mirror:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> state <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Receiving</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Sending</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Copying</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> t <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	source_vdi <span style=color:#f92672>:</span> vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	dest_vdi <span style=color:#f92672>:</span> vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	state <span style=color:#f92672>:</span> state <span style=color:#66d9ef>list</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	failed <span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p>Note that state is a list since the initial phase of the operation requires both copying and mirroring.</p><p>Additionally the mirror can be cancelled using the <code>MIRROR.stop</code> API call.</p><h4 id=code-walkthrough>Code walkthrough</h4><p>let&rsquo;s go through the implementation of <code>copy</code>:</p><h5 id=datacopy>DATA.copy</h5><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> copy <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;copy sr:%s vdi:%s url:%s dest:%s&#34;</span> sr vdi url dest<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_url <span style=color:#f92672>=</span> Http.Url.of_string url <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Remote</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Client</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> rpc <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> <span style=color:#f92672>~</span>dststr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;dst_smapiv2&#34;</span> remote_url <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Here we are constructing a module <code>Remote</code> on which we can do SMAPIv2 calls directly on the destination.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>try</span></span></span></code></pre></div><p>Wrap the whole function in an exception handler.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#75715e>(* Find the local VDI *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> Local.SR.scan <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> vdi<span style=color:#f92672>)</span> vdis
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Not_found</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Local VDI %s not found&#34;</span> vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>We first find the metadata for our source VDI by doing a local SMAPIv2 call <code>SR.scan</code>. This returns a list of VDI metadata, out of which we extract the VDI we&rsquo;re interested in.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>try</span></span></span></code></pre></div><p>Another exception handler. This looks redundant to me right now.</p><div class="highlight wrap-code"><pre tabindex=0><code>      let similar_vdis = Local.VDI.similar_content ~dbg ~sr ~vdi in
      let similars = List.map (fun vdi -&gt; vdi.content_id) similar_vdis in
      debug &#34;Similar VDIs to %s = [ %s ]&#34; vdi (String.concat &#34;; &#34; (List.map (fun x -&gt; Printf.sprintf &#34;(vdi=%s,content_id=%s)&#34; x.vdi x.content_id) similar_vdis));</code></pre></div><p>Here we look for related VDIs locally using the <code>VDI.similar_content</code> SMAPIv2 API call. This searches for related VDIs and returns an ordered list where the most similar is first in the list. It returns both clones and snapshots, and hence is more general than simply following <code>snapshot_of</code> links.</p><div class="highlight wrap-code"><pre tabindex=0><code>      let remote_vdis = Remote.SR.scan ~dbg ~sr:dest in
      (** We drop cbt_metadata VDIs that do not have any actual data *)
      let remote_vdis = List.filter (fun vdi -&gt; vdi.ty &lt;&gt; &#34;cbt_metadata&#34;) remote_vdis in

      let nearest = List.fold_left
          (fun acc content_id -&gt; match acc with
             | Some x -&gt; acc
             | None -&gt;
               try Some (List.find (fun vdi -&gt; vdi.content_id = content_id &amp;&amp; vdi.virtual_size &lt;= local_vdi.virtual_size) remote_vdis)
               with Not_found -&gt; None) None similars in

      debug &#34;Nearest VDI: content_id=%s vdi=%s&#34;
        (Opt.default &#34;None&#34; (Opt.map (fun x -&gt; x.content_id) nearest))
        (Opt.default &#34;None&#34; (Opt.map (fun x -&gt; x.vdi) nearest));</code></pre></div><p>Here we look for VDIs on the destination with the same <code>content_id</code> as one of the locally similar VDIs. We will use this as a base image and only copy deltas to the destination. This is done by cloning the VDI on the destination and then using <code>sparse_dd</code> to find the deltas from our local disk to our local copy of the content_id disk and streaming these to the destination. Note that we need to ensure the VDI is smaller than the one we want to copy since we can&rsquo;t resize disks downwards in size.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#66d9ef>let</span> remote_base <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> nearest <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> vdi <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Cloning VDI %s&#34;</span> vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> vdi_clone <span style=color:#f92672>=</span> Remote.VDI.clone <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> vdi_clone<span style=color:#f92672>.</span>virtual_size <span style=color:#f92672>&lt;&gt;</span> local_vdi<span style=color:#f92672>.</span>virtual_size <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> new_size <span style=color:#f92672>=</span> Remote.VDI.resize <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vdi_clone<span style=color:#f92672>.</span>vdi <span style=color:#f92672>~</span>new_size<span style=color:#f92672>:</span>local_vdi<span style=color:#f92672>.</span>virtual_size <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            debug <span style=color:#e6db74>&#34;Resize remote VDI %s to %Ld: result %Ld&#34;</span> vdi_clone<span style=color:#f92672>.</span>vdi local_vdi<span style=color:#f92672>.</span>virtual_size new_size<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          vdi_clone
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Creating a blank remote VDI&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          Remote.VDI.create <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:{</span> local_vdi <span style=color:#66d9ef>with</span> sm_config <span style=color:#f92672>=</span> [] <span style=color:#f92672>}</span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>If we&rsquo;ve found a base VDI we clone it and resize it immediately. If there&rsquo;s nothing on the destination already we can use, we just create a new VDI. Note that the calls to create and clone may well fail if the destination host is not the SRmaster. This is <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/storage_migrate.ml#L214-L229 rel=external target=_blank>handled purely in the <code>rpc</code> function</a>:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> rpc <span style=color:#f92672>~</span>srcstr <span style=color:#f92672>~</span>dststr url call <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> XMLRPC_protocol.rpc <span style=color:#f92672>~</span>transport<span style=color:#f92672>:(</span>transport_of_url url<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>~</span>srcstr <span style=color:#f92672>~</span>dststr <span style=color:#f92672>~</span>http<span style=color:#f92672>:(</span>xmlrpc <span style=color:#f92672>~</span>version<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;1.0&#34;</span> <span style=color:#f92672>?</span>auth<span style=color:#f92672>:(</span>Http.Url.auth_of url<span style=color:#f92672>)</span> <span style=color:#f92672>~</span>query<span style=color:#f92672>:(</span>Http.Url.get_query_params url<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>Http.Url.get_uri url<span style=color:#f92672>))</span> call
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> not result<span style=color:#f92672>.</span>Rpc.success <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Got failure: checking for redirect&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Call was: %s&#34;</span> <span style=color:#f92672>(</span>Rpc.string_of_call call<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;result.contents: %s&#34;</span> <span style=color:#f92672>(</span>Jsonrpc.to_string result<span style=color:#f92672>.</span>Rpc.contents<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> Storage_interface.Exception.exnty_of_rpc result<span style=color:#f92672>.</span>Rpc.contents <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> Storage_interface.Exception.<span style=color:#a6e22e>Redirect</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Some</span> ip<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> Http.<span style=color:#a6e22e>Url</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> newurl <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> url <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Http</span> h<span style=color:#f92672>,</span> d<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span><span style=color:#a6e22e>Http</span> <span style=color:#f92672>{</span>h <span style=color:#66d9ef>with</span> host<span style=color:#f92672>=</span>ip<span style=color:#f92672>},</span> d<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          remote_url ip <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Redirecting to ip: %s&#34;</span> ip<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr <span style=color:#f92672>~</span>dststr newurl call <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Successfully redirected. Returning&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      r
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Not a redirect&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      result
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> result</span></span></code></pre></div><p>Back to the copy function:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#66d9ef>let</span> remote_copy <span style=color:#f92672>=</span> copy&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi<span style=color:#f92672>:</span>remote_base<span style=color:#f92672>.</span>vdi <span style=color:#f92672>|&gt;</span> vdi_info <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This calls the actual data copy part. See below for more on that.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#66d9ef>let</span> snapshot <span style=color:#f92672>=</span> Remote.VDI.snapshot <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:</span>remote_copy <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      Remote.VDI.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>remote_copy<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Vdi_info</span> snapshot<span style=color:#f92672>)</span></span></span></code></pre></div><p>Finally we snapshot the remote VDI to ensure we&rsquo;ve got a VDI of type &lsquo;snapshot&rsquo; on the destination, and we delete the non-snapshot VDI.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      error <span style=color:#e6db74>&#34;Caught %s: copying snapshots vdi&#34;</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Internal_error</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Backend_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Backend_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Internal_error</span><span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>))</span></span></span></code></pre></div><p>The exception handler does nothing - so we leak remote VDIs if the exception happens after we&rsquo;ve done our cloning :-(</p><h5 id=datacopy_into>DATA.copy_into</h5><p>Let&rsquo;s now look at the data-copying part. This is common code shared between <code>VDI.copy</code>, <code>VDI.copy_into</code> and <code>MIRROR.start</code> and hence has some duplication of the calls made above.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> copy_into <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  copy&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi</span></span></code></pre></div><p><code>copy_into</code> is a stub and just calls <code>copy'</code></p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> copy&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_url <span style=color:#f92672>=</span> Http.Url.of_string url <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Remote</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Client</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> rpc <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> <span style=color:#f92672>~</span>dststr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;dst_smapiv2&#34;</span> remote_url <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;copy local=%s/%s url=%s remote=%s/%s&#34;</span> sr vdi url dest dest_vdi<span style=color:#f92672>;</span></span></span></code></pre></div><p>This call takes roughly the same parameters as the ``DATA.copy` call above, except it specifies the destination VDI.
Once again we construct a module to do remote SMAPIv2 calls</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* Check the remote SR exists *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> srs <span style=color:#f92672>=</span> Remote.SR.list <span style=color:#f92672>~</span>dbg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> not<span style=color:#f92672>(</span>List.mem dest srs<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>then</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Remote SR %s not found&#34;</span> dest<span style=color:#f92672>);</span></span></span></code></pre></div><p>Sanity check.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> Remote.SR.scan <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> dest_vdi<span style=color:#f92672>)</span> vdis
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Not_found</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Remote VDI %s not found&#34;</span> dest_vdi<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Find the metadata of the destination VDI</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_content_id <span style=color:#f92672>=</span> remote_vdi<span style=color:#f92672>.</span>content_id <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>If we&rsquo;ve got a local VDI with the same content_id as the destination, we only need copy the deltas, so we make a note of the destination content ID here.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* Find the local VDI *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> Local.SR.scan <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> vdi<span style=color:#f92672>)</span> vdis
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Not_found</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Local VDI %s not found&#34;</span> vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;copy local=%s/%s content_id=%s&#34;</span> sr vdi local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;copy remote=%s/%s content_id=%s&#34;</span> dest dest_vdi remote_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span></span></span></code></pre></div><p>Find the source VDI metadata.</p><div class="highlight wrap-code"><pre tabindex=0><code>  if local_vdi.virtual_size &gt; remote_vdi.virtual_size then begin
    (* This should never happen provided the higher-level logic is working properly *)
    error &#34;copy local=%s/%s virtual_size=%Ld &gt; remote=%s/%s virtual_size = %Ld&#34; sr vdi local_vdi.virtual_size dest dest_vdi remote_vdi.virtual_size;
    failwith &#34;local VDI is larger than the remote VDI&#34;;
  end;</code></pre></div><p>Sanity check - the remote VDI can&rsquo;t be smaller than the source.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> on_fail <span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>unit</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>unit</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span> ref <span style=color:#f92672>=</span> ref [] <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>We do some ugly error handling here by keeping a mutable list of operations to perform in the event of a failure.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> base_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>content_id <span style=color:#f92672>=</span> dest_content_id<span style=color:#f92672>)</span> vdis<span style=color:#f92672>).</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;local VDI %s has content_id = %s; we will perform an incremental copy&#34;</span> x dest_content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Some</span> x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;no local VDI has content_id = %s; we will perform a full copy&#34;</span> dest_content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>None</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>See if we can identify a local VDI with the same <code>content_id</code> as the destination. If not, no problem.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> remote_dp <span style=color:#f92672>=</span> Uuid.string_of_uuid <span style=color:#f92672>(</span>Uuid.make_uuid ()<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> base_dp <span style=color:#f92672>=</span> Uuid.string_of_uuid <span style=color:#f92672>(</span>Uuid.make_uuid ()<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> leaf_dp <span style=color:#f92672>=</span> Uuid.string_of_uuid <span style=color:#f92672>(</span>Uuid.make_uuid ()<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Construct some <code>datapaths</code> - named reasons why the VDI is attached - that we will pass to <code>VDI.attach/activate</code>.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dest_vdi_url <span style=color:#f92672>=</span> Http.Url.set_uri remote_url <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;%s/nbd/%s/%s/%s&#34;</span> <span style=color:#f92672>(</span>Http.Url.get_uri remote_url<span style=color:#f92672>)</span> dest dest_vdi remote_dp<span style=color:#f92672>)</span> <span style=color:#f92672>|&gt;</span> Http.Url.to_string <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;copy remote=%s/%s NBD URL = %s&#34;</span> dest dest_vdi dest_vdi_url<span style=color:#f92672>;</span></span></span></code></pre></div><p>Here we are constructing a URI that we use to connect to the destination xapi. The handler for this particular path will verify the credentials and then pass the connection on to tapdisk which will behave as a NBD server. The VDI has to be attached and activated for this to work, unlike the new NBD handler in <code>xapi-nbd</code> that is smarter. The handler for this URI is declared <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/storage_migrate.ml#L858-L884 rel=external target=_blank>in this file</a></p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> id<span style=color:#f92672>=</span>State.copy_id_of <span style=color:#f92672>(</span>sr<span style=color:#f92672>,</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Persisting state for copy (id=%s)&#34;</span> id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    State.add id State.<span style=color:#f92672>(</span><span style=color:#a6e22e>Copy_op</span> Copy_state.<span style=color:#f92672>({</span>
</span></span><span style=display:flex><span>        base_dp<span style=color:#f92672>;</span> leaf_dp<span style=color:#f92672>;</span> remote_dp<span style=color:#f92672>;</span> dest_sr<span style=color:#f92672>=</span>dest<span style=color:#f92672>;</span> copy_vdi<span style=color:#f92672>=</span>remote_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span> remote_url<span style=color:#f92672>=</span>url<span style=color:#f92672>}));</span></span></span></code></pre></div><p>Since we&rsquo;re about to perform a long-running operation that is stateful, we persist the state here so that if xapi is restarted we can cancel the operation and not leak VDI attaches. Normally in xapi code we would be doing VBD.plug operations to persist the state in the xapi db, but this is storage code so we have to use a different mechanism.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;mirror.copy: copy initiated local_vdi:%s dest_vdi:%s&#34;</span> vdi dest_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Pervasiveext.finally <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        debug <span style=color:#e6db74>&#34;activating RW datapath %s on remote=%s/%s&#34;</span> remote_dp dest dest_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        ignore<span style=color:#f92672>(</span>Remote.VDI.attach <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>dest_vdi <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>remote_dp <span style=color:#f92672>~</span>read_write<span style=color:#f92672>:</span>true<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        Remote.VDI.activate <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>remote_dp <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>dest_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        with_activated_disk <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>base_vdi <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>base_dp
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> base_path <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>             with_activated_disk <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:(</span><span style=color:#a6e22e>Some</span> vdi<span style=color:#f92672>)</span> <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>leaf_dp
</span></span><span style=display:flex><span>               <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> src <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                  <span style=color:#66d9ef>let</span> dd <span style=color:#f92672>=</span> Sparse_dd_wrapper.start <span style=color:#f92672>~</span>progress_cb<span style=color:#f92672>:(</span>progress_callback 0<span style=color:#f92672>.</span>05 0<span style=color:#f92672>.</span>9 task<span style=color:#f92672>)</span> <span style=color:#f92672>?</span>base<span style=color:#f92672>:</span>base_path true <span style=color:#f92672>(</span>Opt.unbox src<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                      dest_vdi_url remote_vdi<span style=color:#f92672>.</span>virtual_size <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                  Storage_task.with_cancel task
</span></span><span style=display:flex><span>                    <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> Sparse_dd_wrapper.cancel dd<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>try</span> Sparse_dd_wrapper.wait dd
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>with</span> Sparse_dd_wrapper.<span style=color:#a6e22e>Cancelled</span> <span style=color:#f92672>-&gt;</span> Storage_task.raise_cancelled task<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>               <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>         Remote.DP.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>remote_dp <span style=color:#f92672>~</span>allow_leak<span style=color:#f92672>:</span>false<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>         State.remove_copy id
</span></span><span style=display:flex><span>      <span style=color:#f92672>);</span></span></span></code></pre></div><p>In this chunk of code we attach and activate the disk on the remote SR via the SMAPI, then locally attach and activate both the VDI we&rsquo;re copying and the base image we&rsquo;re copying deltas from (if we&rsquo;ve got one). We then call <code>sparse_dd</code> to copy the data to the remote NBD URL. There is some logic to update progress indicators and to cancel the operation if the SMAPIv2 call <code>TASK.cancel</code> is called.</p><p>Once the operation has terminated (either on success, error or cancellation), we remove the local attach and activations in the <code>with_activated_disk</code> function and the remote attach and activation by destroying the datapath on the remote SR. We then remove the persistent state relating to the copy.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;mirror.copy: copy complete local_vdi:%s dest_vdi:%s&#34;</span> vdi dest_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;setting remote=%s/%s content_id &lt;- %s&#34;</span> dest dest_vdi local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Remote.VDI.set_content_id <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>dest_vdi <span style=color:#f92672>~</span>content_id<span style=color:#f92672>:</span>local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* PR-1255: XXX: this is useful because we don&#39;t have content_ids by default *)</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;setting local=%s/%s content_id &lt;- %s&#34;</span> sr local_vdi<span style=color:#f92672>.</span>vdi local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Local.VDI.set_content_id <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>local_vdi<span style=color:#f92672>.</span>vdi <span style=color:#f92672>~</span>content_id<span style=color:#f92672>:</span>local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Vdi_info</span> remote_vdi<span style=color:#f92672>)</span></span></span></code></pre></div><p>The last thing we do is to set the local and remote content_id. The local set_content_id is there because the content_id of the VDI is constructed from the location if it is unset in the <a href=https://github.com/xapi-project/xen-api/blob/3bf897b3accfc172f365689c3c6927746e059177/ocaml/xapi/storage_access.ml#L69-L72 rel=external target=_blank>storage_access.ml</a> module of xapi (still part of the storage layer)</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    error <span style=color:#e6db74>&#34;Caught %s: performing cleanup actions&#34;</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    perform_cleanup_actions <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> e</span></span></code></pre></div><p>Here we perform the list of cleanup operations. Theoretically. It seems we don&rsquo;t ever actually set this to anything, so this is dead code.</p><h5 id=datamirrorstart>DATA.MIRROR.start</h5><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> start&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;Mirror.start sr:%s vdi:%s url:%s dest:%s&#34;</span> sr vdi url dest<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  SMPERF.debug <span style=color:#e6db74>&#34;mirror.start called sr:%s vdi:%s url:%s dest:%s&#34;</span> sr vdi url dest<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_url <span style=color:#f92672>=</span> Http.Url.of_string url <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Remote</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Client</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> rpc <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> <span style=color:#f92672>~</span>dststr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;dst_smapiv2&#34;</span> remote_url <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Find the local VDI *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> Local.SR.scan <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> vdi<span style=color:#f92672>)</span> vdis
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Not_found</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Local VDI %s not found&#34;</span> vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>As with the previous calls, we make a remote module for SMAPIv2 calls on the destination, and we find local VDI metadata via <code>SR.scan</code></p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> State.mirror_id_of <span style=color:#f92672>(</span>sr<span style=color:#f92672>,</span>local_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Mirror ids are deterministically constructed.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* A list of cleanup actions to perform if the operation should fail. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> on_fail <span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>unit</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>unit</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span> ref <span style=color:#f92672>=</span> ref [] <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This <code>on_fail</code> list is actually used.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> similar_vdis <span style=color:#f92672>=</span> Local.VDI.similar_content <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> similars <span style=color:#f92672>=</span> List.filter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x <span style=color:#f92672>&lt;&gt;</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>(</span>List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vdi <span style=color:#f92672>-&gt;</span> vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>)</span> similar_vdis<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Similar VDIs to %s = [ %s ]&#34;</span> vdi <span style=color:#f92672>(</span>String.concat <span style=color:#e6db74>&#34;; &#34;</span> <span style=color:#f92672>(</span>List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> Printf.sprintf <span style=color:#e6db74>&#34;(vdi=%s,content_id=%s)&#34;</span> x<span style=color:#f92672>.</span>vdi x<span style=color:#f92672>.</span>content_id<span style=color:#f92672>)</span> similar_vdis<span style=color:#f92672>));</span></span></span></code></pre></div><p>As with copy we look locally for similar VDIs. However, rather than use that here we actually pass this information on to the destination SR via the <code>receive_start</code> internal SMAPIv2 call:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result_ty <span style=color:#f92672>=</span> Remote.DATA.MIRROR.receive_start <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:</span>local_vdi <span style=color:#f92672>~</span>id <span style=color:#f92672>~</span>similar<span style=color:#f92672>:</span>similars <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> result_ty <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        Mirror.<span style=color:#a6e22e>Vhd_mirror</span> x <span style=color:#f92672>-&gt;</span> x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This gives the destination SR a chance to say what sort of migration it can support. We only support <code>Vhd_mirror</code> style migrations which require the destination to support the <code>compose</code> SMAPIv2 operation. The type of <code>x</code> is a record:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> mirror_receive_result_vhd_t <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	mirror_vdi <span style=color:#f92672>:</span> vdi_info<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	mirror_datapath <span style=color:#f92672>:</span> dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	copy_diffs_from <span style=color:#f92672>:</span> content_id option<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	copy_diffs_to <span style=color:#f92672>:</span> vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	dummy_vdi <span style=color:#f92672>:</span> vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p>Field descriptions:</p><ul><li><code>mirror_vdi</code> is the VDI to which new writes should be mirrored.</li><li><code>mirror_datapath</code> is the remote datapath on which the VDI has been attached and activated. This is required to construct the remote NBD url</li><li><code>copy_diffs_from</code> represents the source base VDI to be used for the non-mirrored data copy.</li><li><code>copy_diffs_to</code> is the remote VDI to copy those diffs to</li><li><code>dummy_vdi</code> exists to prevent leaf-coalesce on the <code>mirror_vdi</code></li></ul><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#75715e>(* Enable mirroring on the local machine *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mirror_dp <span style=color:#f92672>=</span> result<span style=color:#f92672>.</span>Mirror.mirror_datapath <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> uri <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;/services/SM/nbd/%s/%s/%s&#34;</span> dest result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi mirror_dp<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dest_url <span style=color:#f92672>=</span> Http.Url.set_uri remote_url uri <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> request <span style=color:#f92672>=</span> Http.Request.make <span style=color:#f92672>~</span>query<span style=color:#f92672>:(</span>Http.Url.get_query_params dest_url<span style=color:#f92672>)</span> <span style=color:#f92672>~</span>version<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;1.0&#34;</span> <span style=color:#f92672>~</span>user_agent<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> Http.<span style=color:#a6e22e>Put</span> uri <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> transport <span style=color:#f92672>=</span> Xmlrpc_client.transport_of_url dest_url <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This is where we connect to the NBD server on the destination.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Searching for data path: %s&#34;</span> dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> attach_info <span style=color:#f92672>=</span> Local.DP.attach_info <span style=color:#f92672>~</span>dbg<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;nbd&#34;</span> <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>dp <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Got it!&#34;</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>we need the local <code>attach_info</code> to find the local tapdisk so we can send it the connected NBD socket.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    on_fail <span style=color:#f92672>:=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> Remote.DATA.MIRROR.receive_cancel <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>)</span> <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span></span></span></code></pre></div><p>This should probably be set directly after the call to <code>receive_start</code></p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tapdev <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> tapdisk_of_attach_info attach_info <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> tapdev <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        debug <span style=color:#e6db74>&#34;Got tapdev&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> pid <span style=color:#f92672>=</span> Tapctl.get_tapdisk_pid tapdev <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> path <span style=color:#f92672>=</span> Printf.sprintf <span style=color:#e6db74>&#34;/var/run/blktap-control/nbdclient%d&#34;</span> pid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        with_transport transport <span style=color:#f92672>(</span>with_http request <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>response<span style=color:#f92672>,</span> s<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            debug <span style=color:#e6db74>&#34;Here inside the with_transport&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> control_fd <span style=color:#f92672>=</span> Unix.socket Unix.<span style=color:#a6e22e>PF_UNIX</span> Unix.<span style=color:#a6e22e>SOCK_STREAM</span> 0 <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            finally
</span></span><span style=display:flex><span>              <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                 debug <span style=color:#e6db74>&#34;Connecting to path: %s&#34;</span> path<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                 Unix.connect control_fd <span style=color:#f92672>(</span>Unix.<span style=color:#a6e22e>ADDR_UNIX</span> path<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>let</span> msg <span style=color:#f92672>=</span> dp <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>let</span> len <span style=color:#f92672>=</span> String.length msg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>let</span> written <span style=color:#f92672>=</span> Unixext.send_fd control_fd msg 0 len [] s <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                 debug <span style=color:#e6db74>&#34;Sent fd&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>if</span> written <span style=color:#f92672>&lt;&gt;</span> len <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>                   error <span style=color:#e6db74>&#34;Failed to transfer fd to %s&#34;</span> path<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                   failwith <span style=color:#e6db74>&#34;foo&#34;</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                 Unix.close control_fd<span style=color:#f92672>)));</span>
</span></span><span style=display:flex><span>        tapdev
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        failwith <span style=color:#e6db74>&#34;Not attached&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Here we connect to the remote NBD server, then pass that connected fd to the local tapdisk that is using the disk. This fd is passed with a name that is later used to tell tapdisk to start using it - we use the datapath name for this.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Adding to active local mirrors: id=%s&#34;</span> id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> alm <span style=color:#f92672>=</span> State.Send_state.<span style=color:#f92672>({</span>
</span></span><span style=display:flex><span>        url<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        dest_sr<span style=color:#f92672>=</span>dest<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        remote_dp<span style=color:#f92672>=</span>mirror_dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        local_dp<span style=color:#f92672>=</span>dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        mirror_vdi<span style=color:#f92672>=</span>result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        remote_url<span style=color:#f92672>=</span>url<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        tapdev<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        failed<span style=color:#f92672>=</span>false<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        watchdog<span style=color:#f92672>=</span><span style=color:#a6e22e>None</span><span style=color:#f92672>})</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    State.add id <span style=color:#f92672>(</span>State.<span style=color:#a6e22e>Send_op</span> alm<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Added&#34;</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>As for copy we persist some state to disk to say that we&rsquo;re doing a mirror so we can undo any state changes after a toolstack restart.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;About to snapshot VDI = %s&#34;</span> <span style=color:#f92672>(</span>string_of_vdi_info local_vdi<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span> add_to_sm_config local_vdi <span style=color:#e6db74>&#34;mirror&#34;</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;nbd:&#34;</span> <span style=color:#f92672>^</span> dp<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span> add_to_sm_config local_vdi <span style=color:#e6db74>&#34;base_mirror&#34;</span> id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> snapshot <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>      Local.VDI.snapshot <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:</span>local_vdi
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> Storage_interface.<span style=color:#a6e22e>Backend_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> <span style=color:#f92672>_)</span> <span style=color:#66d9ef>when</span> code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;SR_BACKEND_FAILURE_44&#34;</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.sr_source_space_insufficient<span style=color:#f92672>,</span> <span style=color:#f92672>[</span> sr <span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> e
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Done!&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;mirror.start: snapshot created, mirror initiated vdi:%s snapshot_of:%s&#34;</span>
</span></span><span style=display:flex><span>      snapshot<span style=color:#f92672>.</span>vdi local_vdi<span style=color:#f92672>.</span>vdi <span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    on_fail <span style=color:#f92672>:=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> Local.VDI.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>snapshot<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span></span></span></code></pre></div><p>This bit inserts into <code>sm_config</code> the name of the fd we passed earlier to do mirroring. This is interpreted by the python SM backends and passed on the <code>tap-ctl</code> invocation to unpause the disk. This causes all new writes to be mirrored via NBD to the file descriptor passed earlier.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> inner () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        debug <span style=color:#e6db74>&#34;tapdisk watchdog&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> alm_opt <span style=color:#f92672>=</span> State.find_active_local_mirror id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> alm_opt <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> alm <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> stats <span style=color:#f92672>=</span> Tapctl.stats <span style=color:#f92672>(</span>Tapctl.create ()<span style=color:#f92672>)</span> tapdev <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> stats<span style=color:#f92672>.</span>Tapctl.Stats.nbd_mirror_failed <span style=color:#f92672>=</span> 1 <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            Updates.add <span style=color:#f92672>(</span>Dynamic.<span style=color:#a6e22e>Mirror</span> id<span style=color:#f92672>)</span> updates<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          alm<span style=color:#f92672>.</span>State.Send_state.watchdog <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span>Scheduler.one_shot scheduler <span style=color:#f92672>(</span>Scheduler.<span style=color:#a6e22e>Delta</span> 5<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;tapdisk_watchdog&#34;</span> inner<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> ()
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>in</span> inner ()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>This is the watchdog that runs <code>tap-ctl stats</code> every 5 seconds watching <code>mirror_failed</code> for evidence of a failure in the mirroring code. If it detects one the only thing it does is to notify that the state of the mirroring has changed. This will be picked up by the thread in xapi that is monitoring the state of the mirror. It will then issue a <code>MIRROR.stat</code> call which will return the state of the mirror including the information that it has failed.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    on_fail <span style=color:#f92672>:=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> stop <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>)</span> <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* Copy the snapshot to the remote *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> new_parent <span style=color:#f92672>=</span> Storage_task.with_subtask task <span style=color:#e6db74>&#34;copy&#34;</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        copy&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>snapshot<span style=color:#f92672>.</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.copy_diffs_to<span style=color:#f92672>)</span> <span style=color:#f92672>|&gt;</span> vdi_info <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Local VDI %s == remote VDI %s&#34;</span> snapshot<span style=color:#f92672>.</span>vdi new_parent<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span></span></span></code></pre></div><p>This is where we copy the VDI returned by the snapshot invocation to the remote VDI called <code>copy_diffs_to</code>. We only copy deltas, but we rely on <code>copy'</code> to figure out which disk the deltas should be taken from, which it does via the <code>content_id</code> field.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    Remote.VDI.compose <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi1<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.copy_diffs_to <span style=color:#f92672>~</span>vdi2<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Remote.VDI.remove_from_sm_config <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi <span style=color:#f92672>~</span>key<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;base_mirror&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Local VDI %s now mirrored to remote VDI: %s&#34;</span> local_vdi<span style=color:#f92672>.</span>vdi result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span></span></span></code></pre></div><p>Once the copy has finished we invoke the <code>compose</code> SMAPIv2 call that composes the diffs from the mirror with the base image copied from the snapshot.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Destroying dummy VDI %s on remote&#34;</span> result<span style=color:#f92672>.</span>Mirror.dummy_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Remote.VDI.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.dummy_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Destroying snapshot %s on src&#34;</span> snapshot<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Local.VDI.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>snapshot<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Mirror_id</span> id<span style=color:#f92672>)</span></span></span></code></pre></div><p>we can now destroy the dummy vdi on the remote (which will cause a leaf-coalesce in due course), and we destroy the local snapshot here (which will also cause a leaf-coalesce in due course, providing we don&rsquo;t destroy it first). The return value from the function is the mirror_id that we can use to monitor the state or cancel the mirror.</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Sr_not_attached</span><span style=color:#f92672>(</span>sr_uuid<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    error <span style=color:#e6db74>&#34; Caught exception %s:%s. Performing cleanup.&#34;</span> Api_errors.sr_not_attached sr_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    perform_cleanup_actions <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.sr_not_attached<span style=color:#f92672>,[</span>sr_uuid<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    error <span style=color:#e6db74>&#34;Caught %s: performing cleanup actions&#34;</span> <span style=color:#f92672>(</span>Api_errors.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    perform_cleanup_actions <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> e</span></span></code></pre></div><p>The exception handler just cleans up afterwards.</p><p>This is not the end of the story, since we need to detach the remote datapath being used for mirroring when we detach this end. The hook function is in <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/storage_migrate.ml#L775-L791 rel=external target=_blank>storage_migrate.ml</a>:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> post_detach_hook <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>dp <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> State.<span style=color:#a6e22e>Send_state</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> State.mirror_id_of <span style=color:#f92672>(</span>sr<span style=color:#f92672>,</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  State.find_active_local_mirror id <span style=color:#f92672>|&gt;</span>
</span></span><span style=display:flex><span>  Opt.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> r <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> remote_url <span style=color:#f92672>=</span> Http.Url.of_string r<span style=color:#f92672>.</span>url <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Remote</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Client</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> rpc <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> <span style=color:#f92672>~</span>dststr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;dst_smapiv2&#34;</span> remote_url <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> t <span style=color:#f92672>=</span> Thread.create <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Calling receive_finalize&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          log_and_ignore_exn
</span></span><span style=display:flex><span>            <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> Remote.DATA.MIRROR.receive_finalize <span style=color:#f92672>~</span>dbg<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;Mirror-cleanup&#34;</span> <span style=color:#f92672>~</span>id<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Finished calling receive_finalize&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          State.remove_local_mirror id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Removed active local mirror: %s&#34;</span> id
</span></span><span style=display:flex><span>        <span style=color:#f92672>)</span> () <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      Opt.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> id <span style=color:#f92672>-&gt;</span> Scheduler.cancel scheduler id<span style=color:#f92672>)</span> r<span style=color:#f92672>.</span>watchdog<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Created thread %d to call receive finalize and dp destroy&#34;</span> <span style=color:#f92672>(</span>Thread.id t<span style=color:#f92672>))</span></span></span></code></pre></div><p>This removes the persistent state and calls <code>receive_finalize</code> on the destination. The body of that functions is:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> receive_finalize <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> recv_state <span style=color:#f92672>=</span> State.find_active_receive_mirror id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> State.<span style=color:#a6e22e>Receive_state</span> <span style=color:#66d9ef>in</span> Opt.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> r <span style=color:#f92672>-&gt;</span> Local.DP.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>r<span style=color:#f92672>.</span>leaf_dp <span style=color:#f92672>~</span>allow_leak<span style=color:#f92672>:</span>false<span style=color:#f92672>)</span> recv_state<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  State.remove_receive_mirror id</span></span></code></pre></div><p>which removes the persistent state on the destination and destroys the datapath associated with the mirror.</p><p>Additionally, there is also a pre-deactivate hook. The rationale for this is that we want to detect any failures to write that occur right at the end of the SXM process. So if there is a mirror operation going on, before we deactivate we wait for tapdisk to flush its queue of outstanding requests, then we query whether there has been a mirror failure. The code is just above the detach hook in <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/storage_migrate.ml#L738-L773 rel=external target=_blank>storage_migrate.ml</a>:</p><div class="highlight wrap-code"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> pre_deactivate_hook <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> State.<span style=color:#a6e22e>Send_state</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> State.mirror_id_of <span style=color:#f92672>(</span>sr<span style=color:#f92672>,</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> Mtime_clock.counter () <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> get_delta () <span style=color:#f92672>=</span> Mtime_clock.count start <span style=color:#f92672>|&gt;</span> Mtime.Span.to_s <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  State.find_active_local_mirror id <span style=color:#f92672>|&gt;</span>
</span></span><span style=display:flex><span>  Opt.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> s <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(* We used to pause here and then check the nbd_mirror_failed key. Now, we poll
</span></span></span><span style=display:flex><span><span style=color:#75715e>				   until the number of outstanding requests has gone to zero, then check the
</span></span></span><span style=display:flex><span><span style=color:#75715e>				   status. This avoids confusing the backend (CA-128460) *)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Tapctl</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> ctx <span style=color:#f92672>=</span> create () <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> wait () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> get_delta () <span style=color:#f92672>&gt;</span> reqs_outstanding_timeout <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Timeout</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> st <span style=color:#f92672>=</span> stats ctx s<span style=color:#f92672>.</span>tapdev <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> st<span style=color:#f92672>.</span>Stats.reqs_outstanding <span style=color:#f92672>&gt;</span> 0
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>then</span> <span style=color:#f92672>(</span>Thread.delay 1<span style=color:#f92672>.</span>0<span style=color:#f92672>;</span> wait ()<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span> st
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> st <span style=color:#f92672>=</span> wait () <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        debug <span style=color:#e6db74>&#34;Got final stats after waiting %f seconds&#34;</span> <span style=color:#f92672>(</span>get_delta ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> st<span style=color:#f92672>.</span>Stats.nbd_mirror_failed <span style=color:#f92672>=</span> 1
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>          error <span style=color:#e6db74>&#34;tapdisk reports mirroring failed&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          s<span style=color:#f92672>.</span>failed <span style=color:#f92672>&lt;-</span> true
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#a6e22e>Timeout</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        error <span style=color:#e6db74>&#34;Timeout out after %f seconds waiting for tapdisk to complete all outstanding requests&#34;</span> <span style=color:#f92672>(</span>get_delta ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        s<span style=color:#f92672>.</span>failed <span style=color:#f92672>&lt;-</span> true
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        error <span style=color:#e6db74>&#34;Caught exception while finally checking mirror state: %s&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        s<span style=color:#f92672>.</span>failed <span style=color:#f92672>&lt;-</span> true
</span></span><span style=display:flex><span>    <span style=color:#f92672>)</span></span></span></code></pre></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The server is generic because it does not accept fd passing, and I call those
&ldquo;special&rdquo; nbd server/fd receiver.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=xapi-requests-walk-throughs>XAPI requests walk-throughs</h1><p>Let&rsquo;s detail the handling process of an XML request within XAPI.
The first document uses the migration as an example of such request.</p><ul><li><a href=/new-docs/xapi/walkthroughs/migration_overview/index.html>How the migration request goes through Xen API?</a></li></ul><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Walk-throughs</h1><article class=default><header class=headline></header><h1 id=from-rpc-migration-request-to-xapi-internals>From RPC migration request to xapi internals</h1><h2 id=overview>Overview</h2><p>In this document we will use the <code>VM.pool_migrate</code> request to illustrate
the interaction between various components within the XAPI toolstack during
migration. However this schema can be applied to other requests as well.</p><p>Not all parts of the Xapi toolstack are shown here as not all are involved in
the migration process. For instance you won&rsquo;t see the <em><strong>squeezed</strong></em>
nor <em><strong>mpathalert</strong></em> two daemons that belong to the toolstack but don&rsquo;t
participate in the migration of a VM.</p><h2 id=anatomy-of-a-vm-migration>Anatomy of a VM migration</h2><ul><li>Migration is initiated by a Xapi client that sends <code>VM.pool_migrate</code>, an RPC
XML request.</li><li>The Xen API server handles this request and dispatches it to the server.</li><li>The server is generated using <code>XAPI IDL</code> and requests are wrapped whithin a
context, either to be forwarded to a host or executed locally. Broadly, the
context follows RBAC rules. The executed function is related to the message of
the request (refer to <a href=https://xapi-project.github.io/xen-api/ rel=external target=_blank>XenAPI Reference</a>).</li><li>In the case of the migration you can refer to <em>ocaml/idl/datamodel_vm.ml</em>.</li><li>The server will dispatch the operation to server helpers, executing the
operation synchronously or asynchronously and returning the RPC answer.</li><li><em>Message forwarding</em> decides if operation must be executed by another host
of the pool and then forward the call or if is executed locally.</li><li>When executed locally the high-level migration operation is send to the
<em>Xenopsd daemon</em> by posting a message on a known queue on the <em>message switch</em>.</li><li><em>Xenopsd</em> will get the command and will split it into several <em>atomic</em>
operations that will be run by the <em>xenopsd backend</em>.</li><li><em>Xenopsd</em> with its <em>backend</em> can then access xenstore or execute hypercall to
interact with xen a server the micro operation.</li></ul><h2 id=a-diagram-is-worth-a-thousand-words>A diagram is worth a thousand words</h2><pre class="mermaid align-center">
flowchart TD

    %% First we are starting by a XAPI client that is sending an XML-RPC request
    client((Xapi client)) -. sends RPC XML request .-&gt;
        xapi_server{&#34;`Dispatch RPC
                    **api_server.ml**`&#34;}
    style client stroke:#CAFEEE,stroke-width:4px

    %% XAPI Toolstack internals
    subgraph &#34;Xapi Toolstack (master of the pool)&#34;
        style server stroke:#BAFA00,stroke-width:4px,stroke-dasharray: 5 5

            xapi_server --dispatch call (ie VM.pool_migrate)--&gt; server(&#34;`Auto generated using *IDL*
                    **server.ml**`&#34;)

            server --do_dispatch (ie VM.pool_migrate)--&gt; server_helpers[&#34;`server helpers
            **server_helpers.ml**`&#34;]

            server_helpers -- call management (ie xapi_vm_migrate.ml)--&gt; message_forwarding[&#34;`check where to run the call **message_forwarding.ml**`&#34;]

            message_forwarding -- execute locally --&gt; vm_management[&#34;`VM Mgmt
            like **xapi_vm_migrate.ml**`&#34;]

            vm_management -- Call --&gt; xapi_xenops[&#34;`Transform xenops
            see (**xapi_xenops.ml**)`&#34;]
                xapi_xenops &lt;-- Post following IDL model (see xenops_interface.ml) --&gt; msg_switch


        subgraph &#34;Message Switch Daemon&#34;
            msg_switch[[&#34;Queues&#34;]]
        end

        subgraph &#34;Xenopsd Daemon&#34;
            msg_switch &lt;-- Push/Pop on org.xen.xapi.xenopsd.classic --&gt; xenopsd_server

            xenopsd_server[&#34;`Xenposd *frontend*
            get &amp; split high level opertion into atomics`&#34;]  o-- linked at compile time --o xenopsd_backend
        end
    end

    %% Xenopsd backend is accessing xen and xenstore
    xenopsd_backend[&#34;`Xenopsd *backend*
    Backend XC (libxenctrl)`&#34;] -. access to .-&gt; xen_hypervisor[&#34;Xen hypervisor &amp; xenstore&#34;]
    style xen_hypervisor stroke:#BEEF00,stroke-width:2px

    %% Can send request to the host where call must be executed
    message_forwarding -.forward call to .-&gt; elected_host[&#34;Host where call must be executed&#34;]
    style elected_host stroke:#B0A,stroke-width:4px</pre><script>for(let e of document.querySelectorAll(".inline-type"))e.innerHTML=renderType(e.innerHTML)</script><footer class=footline></footer></article></section></section></div></main></div><script src=/new-docs/js/clipboard.min.js?1762269348 defer></script><script src=/new-docs/js/perfect-scrollbar.min.js?1762269348 defer></script><script src=/new-docs/js/d3/d3-color.min.js?1762269348 defer></script><script src=/new-docs/js/d3/d3-dispatch.min.js?1762269348 defer></script><script src=/new-docs/js/d3/d3-drag.min.js?1762269348 defer></script><script src=/new-docs/js/d3/d3-ease.min.js?1762269348 defer></script><script src=/new-docs/js/d3/d3-interpolate.min.js?1762269348 defer></script><script src=/new-docs/js/d3/d3-selection.min.js?1762269348 defer></script><script src=/new-docs/js/d3/d3-timer.min.js?1762269348 defer></script><script src=/new-docs/js/d3/d3-transition.min.js?1762269348 defer></script><script src=/new-docs/js/d3/d3-zoom.min.js?1762269348 defer></script><script src=/new-docs/js/js-yaml.min.js?1762269348 defer></script><script src=/new-docs/js/mermaid.min.js?1762269348 defer></script><script>window.themeUseMermaid=JSON.parse('{ "fontFamily": "Roboto Flex", "securityLevel": "loose" }')</script><script src=/new-docs/js/theme.js?1762269348 defer></script><script>function apply_image_invert_filter(e){document.querySelectorAll("img").forEach(function(t){if(t.classList.contains("no-invert"))return;t.style="filter: invert("+e+");"})}function darkThemeUsed(){const t=window.getComputedStyle(document.querySelector("body")),n=t.getPropertyValue("background-color");var e=n.match(/\d+/g).map(function(e){return parseInt(e,10)});return e.length===3&&.2126*e[0]+.7152*e[1]+.0722*e[2]<165}const invertToDarkGray=.85;darkThemeUsed()&&apply_image_invert_filter(invertToDarkGray),document.addEventListener("themeVariantLoaded",function(e){apply_image_invert_filter(e.detail.variant.endsWith("dark")?invertToDarkGray:0)})</script></body></html>