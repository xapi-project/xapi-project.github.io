<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.127.0"><meta name=generator content="Relearn 5.20.0+tip"><meta name=description content><title>Xapi :: XAPI Toolstack Developer Documentation</title>
<link href=https://xapi-project.github.io/new-docs/xapi/index.html rel=canonical type=text/html title="Xapi :: XAPI Toolstack Developer Documentation"><link href=/new-docs/xapi/index.xml rel=alternate type=application/rss+xml title="Xapi :: XAPI Toolstack Developer Documentation"><link href=/new-docs/images/favicon.png?1727189830 rel=icon type=image/png><link href=/new-docs/css/fontawesome-all.min.css?1727189834 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/fontawesome-all.min.css?1727189834 rel=stylesheet></noscript><link href=/new-docs/css/nucleus.css?1727189834 rel=stylesheet><link href=/new-docs/css/auto-complete.css?1727189834 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/auto-complete.css?1727189834 rel=stylesheet></noscript><link href=/new-docs/css/perfect-scrollbar.min.css?1727189834 rel=stylesheet><link href=/new-docs/css/fonts.css?1727189834 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/fonts.css?1727189834 rel=stylesheet></noscript><link href=/new-docs/css/theme.css?1727189834 rel=stylesheet><link href=/new-docs/css/theme-auto.css?1727189834 rel=stylesheet id=variant-style><link href=/new-docs/css/variant.css?1727189834 rel=stylesheet><link href=/new-docs/css/print.css?1727189834 rel=stylesheet media=print><link href=/new-docs/css/format-print.css?1727189834 rel=stylesheet><link href=/new-docs/css/ie.css?1727189834 rel=stylesheet><script src=/new-docs/js/url.js?1727189834></script><script src=/new-docs/js/variant.js?1727189834></script><script>window.index_js_url="/new-docs/index.search.js";var baseUriFull,root_url="/",baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copy to clipboard",window.T_Copied_to_clipboard="Copied to clipboard!",window.T_Copy_link_to_clipboard="Copy link to clipboard",window.T_Link_copied_to_clipboard="Copied link to clipboard!",window.T_No_results_found='No results found for "{0}"',window.T_N_results_found='{1} results found for "{0}"',baseUriFull="https://xapi-project.github.io/new-docs/",window.variants&&variants.init(["auto","zen-light","zen-dark","red","blue","green","learn","neon","relearn-light","relearn-bright","relearn-dark"])</script><link rel=stylesheet href=https://xapi-project.github.io/new-docs/css/misc.css></head><body class="mobile-support print" data-url=/new-docs/xapi/index.html><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle class=topbar-link title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/new-docs/index.html><span itemprop=name>XAPI Toolstack Developer Guide</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Xapi</span><meta itemprop=position content="2"></li></ol></div></div></nav><main id=body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=xapi>Xapi</h1><p>Xapi is the <a href=http://github.com/xapi-project target=_blank>xapi-project</a> host and cluster manager.</p><p>Xapi is responsible for:</p><ul><li>providing a stable interface (the XenAPI)</li><li>allowing one client to manage multiple hosts</li><li>hosting the &ldquo;xe&rdquo; CLI</li><li>authenticating users and applying role-based access control</li><li>locking resources (in particular disks)</li><li>allowing storage to be managed through plugins</li><li>planning and coping with host failures (&ldquo;High Availability&rdquo;)</li><li>storing VM and host configuration</li><li>generating alerts</li><li>managing software patching</li></ul><h2 id=principles>Principles</h2><ol><li>The XenAPI interface must remain backwards compatible, allowing older
clients to continue working</li><li>Xapi delegates all Xenstore/libxc/libxl access to Xenopsd, so Xapi could
be run in an unprivileged helper domain</li><li>Xapi delegates the low-level storage manipulation to SM plugins.</li><li>Xapi delegates setting up host networking to xcp-networkd.</li><li>Xapi delegates monitoring performance counters to xcp-rrdd.</li></ol><h2 id=overview>Overview</h2><p>The following diagram shows the internals of Xapi:</p><p><a href=#image-f7cc5741f55f232a69a0221af38bf2eb class=lightbox-link><img src=/new-docs/xapi/xapi.png alt="Internals of xapi" class="figure-image noborder lightbox noshadow" style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=image-f7cc5741f55f232a69a0221af38bf2eb><img src=/new-docs/xapi/xapi.png alt="Internals of xapi" class="lightbox-image noborder lightbox noshadow" loading=lazy></a></p><p>The top of the diagram shows the XenAPI clients: XenCenter, XenOrchestra,
OpenStack and CloudStack using XenAPI and HTTP GET/PUT over ports 80 and 443 to
talk to xapi. These XenAPI (JSON-RPC or XML-RPC over HTTP POST) and HTTP
GET/PUT are always authenticated using either PAM (by default using the local
passwd and group files) or through Active Directory.</p><p>The APIs are classified into categories:</p><ul><li>coordinator-only: these are the majority of current APIs. The coordinator
should be called and relied upon to forward the call to the right place with
the right locks held.</li><li>normally-local: these are performance special cases
such as disk import/export and console connection which are sent directly to
hosts which have the most efficient access to the data.</li><li>emergency: these deal with scenarios where the coordinator is offline</li></ul><p>If the incoming API call should be resent to the coordinator than a XenAPI
<code>HOST_IS_SLAVE</code> error message containing the coordinator&rsquo;s IP is sent to the
client.</p><p>Once past the initial checks, API calls enter the &ldquo;message forwarding&rdquo; layer which</p><ul><li>locks resources (via the <code>current_operations</code> mechanism)</li><li>decides which host should execute the request.</li></ul><p>If the request should run locally then a direct function call is used;
otherwise the message forwarding code makes a synchronous API call to a
specific other host. Note: Xapi currently employs a &ldquo;thread per request&rdquo; model
which causes one full POSIX thread to be created for every request. Even when a
request is forwarded the full thread persists, blocking for the result to
become available.</p><p>If the XenAPI call is a VM lifecycle operation then it is converted into a
Xenopsd API call and forwarded over a Unix domain socket. Xapi and Xenopsd have
similar notions of cancellable asynchronous &ldquo;tasks&rdquo;, so the current Xapi task
(all operations run in the context of a task) is bound to the Xenopsd task, so
cancellation is passed through and progress updates are received.</p><p>If the XenAPI call is a storage operation then the &ldquo;storage access&rdquo; layer</p><ul><li>verifies that the storage objects are in the correct state (SR
attached/detached; VDI attached/activated read-only/read-write)</li><li>invokes the relevant operation in the Storage Manager API (SMAPI) v2
interface;</li><li>depending on the type of SR:<ul><li>uses the SMAPIv2 to SMAPIv1 converter to generate the necessary command-line
to talk to the SMAPIv1 plugin (EXT, NFS, LVM etc) and to execute it</li><li>uses the SMAPIv2 to SMAPIv3 converter daemon xapi-storage-script to
exectute the necessary SMAPIv3 command (GFS2)</li></ul></li><li>persists the state of the storage objects (including the result of a
<code>VDI.attach</code> call) to persistent storage</li></ul><p>Internally the SMAPIv1 plugins use privileged access to the Xapi database to
directly set fields (e.g. VDI.virtual_size) that would be considered read/only
to other clients. The SMAPIv1 plugins also rely on Xapi for</p><ul><li>knowledge of all hosts which may access the storage</li><li>locking of disks within the resource pool</li><li>safely executing code on other hosts via the &ldquo;Xapi plugin&rdquo; mechanism</li></ul><p>The Xapi database contains Host and VM metadata and is shared pool-wide. The
coordinator keeps a copy in memory, and all other nodes remote queries to the
coordinator. The database associates each object with a generation count which
is used to implement the XenAPI <code>event.next</code> and <code>event.from</code> APIs. The
database is routinely asynchronously flushed to disk in XML format. If the
&ldquo;redo-log&rdquo; is enabled then all database writes are made synchronously as deltas
to a shared block device. Without the redo-log, recent updates may be lost if
Xapi is killed before a flush.</p><p>High-Availability refers to planning for host failure, monitoring host liveness
and then following-through on the plans. Xapi defers to an external host
liveness monitor called <code>xhad</code>. When <code>xhad</code> confirms that a host has failed &ndash;
and has been isolated from the storage &ndash; then Xapi will restart any VMs which
have failed and which have been marked as &ldquo;protected&rdquo; by HA. Xapi can also
impose admission control to prevent the pool becoming too overloaded to cope
with <code>n</code> arbitrary host failures.</p><p>The <code>xe</code> CLI is implemented in terms of the XenAPI, but for efficiency the
implementation is linked directly into Xapi. The <code>xe</code> program remotes its
command-line to Xapi, and Xapi sends back a series of simple commands (prompt
for input; print line; fetch file; exit etc).</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Xapi</h1><article class=default><header class=headline></header><h1 id=guides>Guides</h1><p>Helpful guides for xapi developers.</p><ul class="children children-li children-sort-weight"><li><a href=/new-docs/xapi/guides/howtos/index.html>How to add....</a><ul><li><a href=/new-docs/xapi/guides/howtos/add-class/index.html>Adding a Class to the API</a><ul></ul></li><li><a href=/new-docs/xapi/guides/howtos/add-field/index.html>Adding a field to the API</a><ul></ul></li><li><a href=/new-docs/xapi/guides/howtos/add-function/index.html>Adding a function to the API</a><ul></ul></li><li><a href=/new-docs/xapi/guides/howtos/add-api-extension/index.html>Adding a XenAPI extension</a><ul></ul></li></ul></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Guides</h1><article class=default><header class=headline></header><h1 id=how-to-add>How to add....</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of How to add....</h1><article class=default><header class=headline></header><h1 id=adding-a-class-to-the-api>Adding a Class to the API</h1><p>This document describes how to add a new class to the data model that
defines the Xen Server API. It complements two other documents that
describe how to extend an existing class:</p><ul><li><a href=https://xapi-project.github.io/new-docs/xapi/guides/howtos/add-field/>Adding a Field</a></li><li><a href=https://xapi-project.github.io/new-docs/xapi/guides/howtos/add-function/>Adding a Function</a></li></ul><p>As a running example, we will use the addition of a class that is part
of the design for the PVS Direct feature. PVS Direct introduces
proxies that serve VMs with disk images. This class was added via commit
<a href=https://github.com/xenserver/xen-api/commit/78fe558dad19458a89519fe196069317d57eac58 target=_blank>CP-16939</a> to Xen API.</p><h2 id=example-pvs_server>Example: PVS_server</h2><p>In the world of Xen Server, each important concept like a virtual
machine, interface, or users is represented by a class in the data model.
A class defines methods and instance variables. At runtime, all class
instances are held in an in-memory database. For example, part of [PVS
Direct] is a class <code>PVS_server</code>, representing a resource that provides
block-level data for virtual machines. The design document defines it to
have the following important properties:</p><h3 id=fields>Fields</h3><ul><li><p><code>(string set) addresses</code> (RO/constructor) IPv4 addresses of the
server.</p></li><li><p><code>(int) first_port</code> (RO/constructor) First UDP port accepted by the
server.</p></li><li><p><code>(int) last_port</code> (RO/constructor) Last UDP port accepted by the
server.</p></li><li><p><code>(PVS_farm ref) farm</code> (RO/constructor) Link to the farm that this
server is included in. A PVS_server object must always have a valid
farm reference; the PVS_server will be automatically GC’ed by xapi
if the associated PVS_farm object is removed.</p></li><li><p><code>(string) uuid (R0/runtime)</code> Unique identifier/object reference.
Allocated by the server.</p></li></ul><h3 id=methods-or-functions>Methods (or Functions)</h3><ul><li><p><code>(PVS_server ref) introduce (string set addresses, int first_port, int last_port, PVS_farm ref farm)</code> Introduce a new PVS server into
the farm. Allowed at any time, even when proxies are in use. The
proxies will be updated automatically.</p></li><li><p><code>(void) forget (PVS_server ref self)</code> Remove a PVS server from the
farm. Allowed at any time, even when proxies are in use. The
proxies will be updated automatically.</p></li></ul><h3 id=implementation-overview>Implementation Overview</h3><p>The implementation of a class is distributed over several files:</p><ul><li><code>ocaml/idl/datamodel.ml</code> &ndash; central class definition</li><li><code>ocaml/idl/datamodel_types.ml</code> &ndash; definition of releases</li><li><code>ocaml/xapi/cli_frontend.ml</code> &ndash; declaration of CLI operations</li><li><code>ocaml/xapi/cli_operations.ml</code> &ndash; implementation of CLI operations</li><li><code>ocaml/xapi/records.ml</code> &ndash; getters and setters</li><li><code>ocaml/xapi/OMakefile</code> &ndash; refers to <code>xapi_pvs_farm.ml</code></li><li><code>ocaml/xapi/api_server.ml</code> &ndash; refers to <code>xapi_pvs_farm.ml</code></li><li><code>ocaml/xapi/message_forwarding.ml</code></li><li><code>ocaml/xapi/xapi_pvs_farm.ml</code> &ndash; implementation of methods, new file</li></ul><h3 id=data-model>Data Model</h3><p>The data model <code>ocaml/idl/datamodel.ml</code> defines the class. To keep the
name space tidy, most helper functions are grouped into an internal
module:</p><pre><code>(* datamodel.ml *)

let schema_minor_vsn = 103 (* line 21 -- increment this *)
let _pvs_farm = &quot;PVS_farm&quot; (* line 153 *)

module PVS_farm = struct (* line 8658 *)
  let lifecycle = [Prototyped, rel_dundee_plus, &quot;&quot;]

  let introduce = call
    ~name:&quot;introduce&quot;
    ~doc:&quot;Introduce new PVS farm&quot;
    ~result:(Ref _pvs_farm, &quot;the new PVS farm&quot;)
    ~params:
    [ String,&quot;name&quot;,&quot;name of the PVS farm&quot;
    ]
    ~lifecycle
    ~allowed_roles:_R_POOL_OP
    ()

  let forget = call
    ~name:&quot;forget&quot;
    ~doc:&quot;Remove a farm's meta data&quot;
    ~params:
    [ Ref _pvs_farm, &quot;self&quot;, &quot;this PVS farm&quot;
    ]
    ~errs:[
      Api_errors.pvs_farm_contains_running_proxies;
      Api_errors.pvs_farm_contains_servers;
    ]
    ~lifecycle
    ~allowed_roles:_R_POOL_OP
    ()


  let set_name = call
    ~name:&quot;set_name&quot;
    ~doc:&quot;Update the name of the PVS farm&quot;
    ~params:
    [ Ref _pvs_farm, &quot;self&quot;, &quot;this PVS farm&quot;
    ; String, &quot;value&quot;, &quot;name to be used&quot;
    ]
    ~lifecycle
    ~allowed_roles:_R_POOL_OP
    ()

  let add_cache_storage = call
    ~name:&quot;add_cache_storage&quot;
    ~doc:&quot;Add a cache SR for the proxies on the farm&quot;
    ~params:
    [ Ref _pvs_farm, &quot;self&quot;, &quot;this PVS farm&quot;
    ; Ref _sr, &quot;value&quot;, &quot;SR to be used&quot;
    ]
    ~lifecycle
    ~allowed_roles:_R_POOL_OP
    ()

  let remove_cache_storage = call
    ~name:&quot;remove_cache_storage&quot;
    ~doc:&quot;Remove a cache SR for the proxies on the farm&quot;
    ~params:
    [ Ref _pvs_farm, &quot;self&quot;, &quot;this PVS farm&quot;
    ; Ref _sr, &quot;value&quot;, &quot;SR to be removed&quot;
    ]
    ~lifecycle
    ~allowed_roles:_R_POOL_OP
    ()

  let obj =
    let null_str = Some (VString &quot;&quot;) in
    let null_set = Some (VSet []) in
    create_obj (* &lt;---- creates class *)
    ~name: _pvs_farm
    ~descr:&quot;machines serving blocks of data for provisioning VMs&quot;
    ~doccomments:[]
    ~gen_constructor_destructor:false
    ~gen_events:true
    ~in_db:true
    ~lifecycle
    ~persist:PersistEverything
    ~in_oss_since:None
    ~messages_default_allowed_roles:_R_POOL_OP
    ~contents:
    [ uid     _pvs_farm ~lifecycle

    ; field   ~qualifier:StaticRO ~lifecycle
              ~ty:String &quot;name&quot; ~default_value:null_str
              &quot;Name of the PVS farm. Must match name configured in PVS&quot;

    ; field   ~qualifier:DynamicRO ~lifecycle
              ~ty:(Set (Ref _sr)) &quot;cache_storage&quot; ~default_value:null_set
              ~ignore_foreign_key:true
              &quot;The SR used by PVS proxy for the cache&quot;

    ; field   ~qualifier:DynamicRO ~lifecycle
              ~ty:(Set (Ref _pvs_server)) &quot;servers&quot;
              &quot;The set of PVS servers in the farm&quot;


    ; field   ~qualifier:DynamicRO ~lifecycle
              ~ty:(Set (Ref _pvs_proxy)) &quot;proxies&quot;
              &quot;The set of proxies associated with the farm&quot;
    ]
    ~messages:
    [ introduce
    ; forget
    ; set_name
    ; add_cache_storage
    ; remove_cache_storage
    ]
    ()
end
let pvs_farm = PVS_farm.obj
</code></pre><p>The class is defined by a call to <code>create_obj</code> and it defines the
fields and messages (methods) belonging to the class. Each field has a
name, a type, and some meta information. Likewise, each message
(or method) is created by <code>call</code> that describes its parameters.</p><p>The <code>PVS_farm</code> has additional getter and setter methods for accessing
its fields. These are not declared here as part of the messages
but are automatically generated.</p><p>To make sure the new class is actually used, it is important to enter it
into two lists:</p><pre><code>(* datamodel.ml *)
let all_system = (* line 8917 *)
  [
    ...
    vgpu_type;
    pvs_farm;
    ...
  ]

let expose_get_all_messages_for = [ (* line 9097 *)
  ...
  _pvs_farm;
  _pvs_server;
  _pvs_proxy;
</code></pre><p>When a field refers to another object that itself refers back to it,
these two need to be entered into the <code>all_relations</code> list. For example,
<code>_pvs_server</code> refers to a <code>_pvs_farm</code> value via <code>"farm"</code>, which, in
turn, refers to the <code>_pvs_server</code> value via its <code>"servers"</code> field.</p><pre><code>let all_relations =
  [
    (* ... *)
    (_sr, &quot;introduced_by&quot;), (_dr_task, &quot;introduced_SRs&quot;);
    (_pvs_server, &quot;farm&quot;), (_pvs_farm, &quot;servers&quot;);
    (_pvs_proxy,  &quot;farm&quot;), (_pvs_farm, &quot;proxies&quot;);
  ]
</code></pre><h2 id=cli-conventions>CLI Conventions</h2><p>The CLI provides access to objects from the command line. The following
conventions exist for naming fields:</p><ul><li><p>A field in the data model uses an underscore (<code>_</code>) but a hyphen (<code>-</code>)
in the CLI: what is <code>cache_storage</code> in the data model becomes
<code>cache-storage</code> in the CLI.</p></li><li><p>When a field contains a reference or multiple, like <code>proxies</code>, it
becomes <code>proxy-uuids</code> in the CLI because references are always
referred to by their UUID.</p></li></ul><h2 id=cli-getters-and-setters>CLI Getters and Setters</h2><p>All fields can be read from the CLI and some fields can also be set via
the CLI. These getters and setters are mostly generated automatically
and need to be connected to the CLI through a function in
<code>ocaml/xapi/records.ml</code>. Note that field names here use the
naming convention for the CLI:</p><pre><code>(* ocaml/xapi/records.ml *)
let pvs_farm_record rpc session_id pvs_farm =
  let _ref = ref pvs_farm in
  let empty_record =
    ToGet (fun () -&gt; Client.PVS_farm.get_record rpc session_id !_ref) in
  let record = ref empty_record in
  let x () = lzy_get record in
    { setref    = (fun r -&gt; _ref := r ; record := empty_record)
    ; setrefrec = (fun (a,b) -&gt; _ref := a; record := Got b)
    ; record    = x
    ; getref    = (fun () -&gt; !_ref)
    ; fields=
      [ make_field ~name:&quot;uuid&quot;
        ~get:(fun () -&gt; (x ()).API.pVS_farm_uuid) ()
      ; make_field ~name:&quot;name&quot;
        ~get:(fun () -&gt; (x ()).API.pVS_farm_name)
        ~set:(fun name -&gt;
          Client.PVS_farm.set_name rpc session_id !_ref name) ()
      ; make_field ~name:&quot;cache-storage&quot;
        ~get:(fun () -&gt; (x ()).API.pVS_farm_cache_storage
          |&gt; List.map get_uuid_from_ref |&gt; String.concat &quot;; &quot;)
        ~add_to_set:(fun sr_uuid -&gt;
          let sr = Client.SR.get_by_uuid rpc session_id sr_uuid in
          Client.PVS_farm.add_cache_storage rpc session_id !_ref sr)
        ~remove_from_set:(fun sr_uuid -&gt;
          let sr = Client.SR.get_by_uuid rpc session_id sr_uuid in
          Client.PVS_farm.remove_cache_storage rpc session_id !_ref sr)
        ()
      ; make_field ~name:&quot;server-uuids&quot;
        ~get:(fun () -&gt; (x ()).API.pVS_farm_servers
          |&gt; List.map get_uuid_from_ref |&gt; String.concat &quot;; &quot;)
        ~get_set:(fun () -&gt; (x ()).API.pVS_farm_servers
          |&gt; List.map get_uuid_from_ref)
        ()
      ; make_field ~name:&quot;proxy-uuids&quot;
        ~get:(fun () -&gt; (x ()).API.pVS_farm_proxies
          |&gt; List.map get_uuid_from_ref |&gt; String.concat &quot;; &quot;)
        ~get_set:(fun () -&gt; (x ()).API.pVS_farm_proxies
          |&gt; List.map get_uuid_from_ref)
        ()
      ]
    }
</code></pre><h2 id=cli-interface-to-methods>CLI Interface to Methods</h2><p>Methods accessible from the CLI are declared in
<code>ocaml/xapi/cli_frontend.ml</code>. Each declaration refers to the real
implementation of the method, like <code>Cli_operations.PVS_far.introduce</code>:</p><pre><code>(* cli_frontend.ml *)
let rec cmdtable_data : (string*cmd_spec) list =
  (* ... *)
  &quot;pvs-farm-introduce&quot;,
  {
    reqd=[&quot;name&quot;];
    optn=[];
    help=&quot;Introduce new PVS farm&quot;;
    implementation=No_fd Cli_operations.PVS_farm.introduce;
    flags=[];
  };
  &quot;pvs-farm-forget&quot;,
  {
    reqd=[&quot;uuid&quot;];
    optn=[];
    help=&quot;Forget a PVS farm&quot;;
    implementation=No_fd Cli_operations.PVS_farm.forget;
    flags=[];
  };
</code></pre><h2 id=cli-implementation-of-methods>CLI Implementation of Methods</h2><p>Each CLI operation that is not a getter or setter has an implementation
in <code>cli_operations.ml</code> which is implemented in terms of the real
implementation:</p><pre><code>(* cli_operations.ml *)
module PVS_farm = struct
  let introduce printer rpc session_id params =
    let name  = List.assoc &quot;name&quot; params in
    let ref   = Client.PVS_farm.introduce ~rpc ~session_id ~name in
    let uuid  = Client.PVS_farm.get_uuid rpc session_id ref in
    printer (Cli_printer.PList [uuid])

  let forget printer rpc session_id params =
    let uuid  = List.assoc &quot;uuid&quot; params in
    let ref   = Client.PVS_farm.get_by_uuid ~rpc ~session_id ~uuid in
    Client.PVS_farm.forget rpc session_id ref
end
</code></pre><p>Fields that should show up in the CLI interface by default are declared
in the <code>gen_cmds</code> value:</p><pre><code>(* cli_operations.ml *)
let gen_cmds rpc session_id =
  let mk = make_param_funs in
  List.concat
  [ (*...*)
  ; Client.Pool.(mk get_all get_all_records_where
    get_by_uuid pool_record &quot;pool&quot; []
    [&quot;uuid&quot;;&quot;name-label&quot;;&quot;name-description&quot;;&quot;master&quot;
    ;&quot;default-SR&quot;] rpc session_id)
  ; Client.PVS_farm.(mk get_all get_all_records_where
    get_by_uuid pvs_farm_record &quot;pvs-farm&quot; []
    [&quot;uuid&quot;;&quot;name&quot;;&quot;cache-storage&quot;;&quot;server-uuids&quot;] rpc session_id)
</code></pre><h2 id=error-messages>Error messages</h2><p>Error messages used by an implementation are introduced in two files:</p><pre><code>(* ocaml/xapi-consts/api_errors.ml *)
let pvs_farm_contains_running_proxies = &quot;PVS_FARM_CONTAINS_RUNNING_PROXIES&quot;
let pvs_farm_contains_servers = &quot;PVS_FARM_CONTAINS_SERVERS&quot;
let pvs_farm_sr_already_added = &quot;PVS_FARM_SR_ALREADY_ADDED&quot;
let pvs_farm_sr_is_in_use = &quot;PVS_FARM_SR_IS_IN_USE&quot;
let sr_not_in_pvs_farm = &quot;SR_NOT_IN_PVS_FARM&quot;
let pvs_farm_cant_set_name = &quot;PVS_FARM_CANT_SET_NAME&quot;

(* ocaml/idl/datamodel.ml *)
  (* PVS errors *)
  error Api_errors.pvs_farm_contains_running_proxies [&quot;proxies&quot;]
    ~doc:&quot;The PVS farm contains running proxies and cannot be forgotten.&quot; ();

  error Api_errors.pvs_farm_contains_servers [&quot;servers&quot;]
    ~doc:&quot;The PVS farm contains servers and cannot be forgotten.&quot;
    ();

  error Api_errors.pvs_farm_sr_already_added [&quot;farm&quot;; &quot;SR&quot;]
    ~doc:&quot;Trying to add a cache SR that is already associated with the farm&quot;
    ();

  error Api_errors.sr_not_in_pvs_farm [&quot;farm&quot;; &quot;SR&quot;]
    ~doc:&quot;The SR is not associated with the farm.&quot;
    ();

  error Api_errors.pvs_farm_sr_is_in_use [&quot;farm&quot;; &quot;SR&quot;]
    ~doc:&quot;The SR is in use by the farm and cannot be removed.&quot;
    ();

  error Api_errors.pvs_farm_cant_set_name [&quot;farm&quot;]
    ~doc:&quot;The name of the farm can't be set while proxies are active.&quot;
    ()
</code></pre><h2 id=method-implementation>Method Implementation</h2><p>The implementation of methods lives in a module in <code>ocaml/xapi</code>:</p><pre><code>(* ocaml/xapi/api_server.ml *)
  module PVS_farm = Xapi_pvs_farm
</code></pre><p>The file below is typically a new file and needs to be added to
<code>ocaml/xapi/OMakefile</code>.</p><pre><code>(* ocaml/xapi/xapi_pvs_farm.ml *)
module D = Debug.Make(struct let name = &quot;xapi_pvs_farm&quot; end)
module E = Api_errors

let api_error msg xs = raise (E.Server_error (msg, xs))

let introduce ~__context ~name =
  let pvs_farm = Ref.make () in
  let uuid = Uuid.to_string (Uuid.make_uuid ()) in
  Db.PVS_farm.create ~__context
    ~ref:pvs_farm ~uuid ~name ~cache_storage:[];
  pvs_farm

(* ... *)
</code></pre><p>Messages received on a slave host may or may not be executed there. In
the simple case, each methods executes locally:</p><pre><code>(* ocaml/xapi/message_forwarding.ml *)
module PVS_farm = struct
  let introduce ~__context ~name =
    info &quot;PVS_farm.introduce %s&quot; name;
    Local.PVS_farm.introduce ~__context ~name

  let forget ~__context ~self =
    info &quot;PVS_farm.forget&quot;;
    Local.PVS_farm.forget ~__context ~self

  let set_name ~__context ~self ~value =
    info &quot;PVS_farm.set_name %s&quot; value;
    Local.PVS_farm.set_name ~__context ~self ~value

  let add_cache_storage ~__context ~self ~value =
    info &quot;PVS_farm.add_cache_storage&quot;;
    Local.PVS_farm.add_cache_storage ~__context ~self ~value

  let remove_cache_storage ~__context ~self ~value =
    info &quot;PVS_farm.remove_cache_storage&quot;;
    Local.PVS_farm.remove_cache_storage ~__context ~self ~value
end
</code></pre><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=adding-a-field-to-the-api>Adding a field to the API</h1><p>This page describes how to add a field to XenAPI. A field is a parameter of a class that can be used in functions and read from the API.</p><h2 id=bumping-the-database-schema-version>Bumping the database schema version</h2><p>Whenever a field is added to or removed from the API, its schema version needs
to be increased. XAPI needs this fundamental procedure in order to be able to
detect that an automatic database upgrade is necessary or to find out that the
new schema is incompatible with the existing database. If the schema version is
not bumped, XAPI will start failing in unpredictable ways. Note that bumping
the version is not necessary when adding functions, only when adding fields.</p><p>The current version number is kept at the top of the file
<code>ocaml/idl/datamodel_common.ml</code> in the variables <code>schema_major_vsn</code> and
<code>schema_minor_vsn</code>, of which only the latter should be incremented (the major
version only exists for historical reasons). When moving to a new XenServer
release, also update the variable <code>last_release_schema_minor_vsn</code> to the schema
version of the last release. To keep track of the schema versions of recent
XenServer releases, the file contains variables for these, such as
<code>miami_release_schema_minor_vsn</code>. After starting a new version of Xapi on an
existing server, the database is automatically upgraded if the schema version
of the existing database matches the value of <code>last_release_schema_*_vsn</code> in the
new Xapi.</p><p>As an example, the patch below shows how the schema version was bumped when the
new API fields used for ActiveDirectory integration were added:</p><pre><code>--- a/ocaml/idl/datamodel.ml  Tue Nov 11 16:17:48 2008 +0000
+++ b/ocaml/idl/datamodel.ml  Tue Nov 11 15:53:29 2008 +0000
@@ -15,17 +15,20 @@ open Datamodel_types
  open Datamodel_types

  (* IMPORTANT: Please bump schema vsn if you change/add/remove a _field_.
     You do not have to dump vsn if you change/add/remove a message *)

  let schema_major_vsn = 5
 -let schema_minor_vsn = 55
 +let schema_minor_vsn = 56

  (* Historical schema versions just in case this is useful later *)
  let rio_schema_major_vsn = 5
  let rio_schema_minor_vsn = 19

 +let miami_release_schema_major_vsn = 5
 +let miami_release_schema_minor_vsn = 35
 +
  (* the schema vsn of the last release: used to determine whether we can
     upgrade or not.. *)
  let last_release_schema_major_vsn = 5
 -let last_release_schema_minor_vsn = 35
 +let last_release_schema_minor_vsn = 55
</code></pre><h3 id=setting-the-schema-hash>Setting the schema hash</h3><p>In the <code>ocaml/idl/schematest.ml</code> there is the <code>last_known_schema_hash</code> This needs to be updated to be the next hash after the schema version was bumped. Get the new hash by running <code>make test</code> and you will receive the correct hash in the error message.</p><h2 id=adding-the-new-field-to-some-existing-class>Adding the new field to some existing class</h2><h3 id=ocamlidldatamodelml>ocaml/idl/datamodel.ml</h3><p>Add a new &ldquo;field&rdquo; line to the class in the file <code>ocaml/idl/datamodel.ml</code> or <code>ocaml/idl/datamodel_[class].ml</code>. The new field might require
a suitable default value. This default value is used in case the user does not
provide a value for the field.</p><p>A field has a number of parameters:</p><ul><li>The lifecycle parameter, which shows how the field has evolved over time.</li><li>The qualifier parameter, which controls access to the field. The following
values are possible:</li></ul><table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>StaticRO</td><td>Field is set statically at install-time.</td></tr><tr><td>DynamicRO</td><td>Field is computed dynamically at run time.</td></tr><tr><td>RW</td><td>Field is read/write.</td></tr></tbody></table><ul><li>The ty parameter for the type of the field.</li><li>The default_value parameter.</li><li>The name of the field.</li><li>A documentation string.</li></ul><p>Example of a field in the pool class:</p><pre><code>field ~lifecycle:[Published, rel_orlando, &quot;Controls whether HA is enabled&quot;]
      ~qualifier:DynamicRO ~ty:Bool
      ~default_value:(Some (VBool false)) &quot;ha_enabled&quot; &quot;true if HA is enabled on the pool, false otherwise&quot;;
</code></pre><p>See datamodel_types.ml for information about other parameters.</p><h2 id=changing-constructors>Changing Constructors</h2><p>Adding a field would change the constructors for the class – functions
Db.*.create – and therefore, any references to these in the code need to be
updated. In the example, the argument ~ha_enabled:false should be added to any
call to Db.Pool.create.</p><p>Examples of where these calls can be found is in <code>ocaml/tests/common/test_common.ml</code> and <code>ocaml/xapi/xapi_[class].ml</code>.</p><h3 id=cli-records>CLI Records</h3><p>If you want this field to show up in the CLI (which you probably do), you will
also need to modify the Records module, in the file
<code>ocaml/xapi-cli-server/records.ml</code>. Find the record function for the class which
you have modified, add a new entry to the fields list using make_field. This type can be found in the same file.</p><p>The only required parameters are name and get (and unit, of course ).
If your field is a map or set, then you will need to pass in get_{map,set}, and
optionally set_{map,set}, if it is a RW field. The hidden parameter is useful
if you don&rsquo;t want this field to show up in a *_params_list call. As an example,
here is a field that we&rsquo;ve just added to the SM class:</p><pre><code>make_field ~name:&quot;versioned-capabilities&quot;
           ~get:(fun () -&gt; get_from_map (x ()).API.sM_versioned_capabilities)
           ~get_map:(fun () -&gt; (x ()).API.sM_versioned_capabilities)
           ~hidden:true ();
</code></pre><h2 id=testing>Testing</h2><p>The new fields can be tested by copying the newly compiled xapi binary to a
test box. After the new xapi service is started, the file
<em>/var/log/xensource.log</em> in the test box should contain a few lines reporting the
successful upgrade of the metadata schema in the test box:</p><pre><code>[...|xapi] Db has schema major_vsn=5, minor_vsn=57 (current is 5 58) (last is 5 57)
[...|xapi] Database schema version is that of last release: attempting upgrade
[...|sql] attempting to restore database from /var/xapi/state.db
[...|sql] finished parsing xml
[...|sql] writing db as xml to file '/var/xapi/state.db'.
[...|xapi] Database upgrade complete, restarting to use new db
</code></pre><h2 id=making-this-field-accessible-as-a-cli-attribute>Making this field accessible as a CLI attribute</h2><p>XenAPI functions to get and set the value of the new field are generated
automatically. It requires some extra work, however, to enable such operations
in the CLI.</p><p>The CLI has commands such as host-param-list and host-param-get. To make a new
field accessible by these commands, the file <code>xapi-cli-server/records.ml</code> needs to
be edited. For the pool.ha-enabled field, the pool_record function in this file
contains the following (note the convention to replace underscores by hyphens
in the CLI):</p><pre><code>let pool_record rpc session_id pool =
  ...
[
  ...
  make_field ~name:&quot;ha-enabled&quot; ~get:(fun () -&gt; string_of_bool (x ()).API.pool_ha_enabled) ();
  ...
]}
</code></pre><p>NB: the ~get parameter must return a string so include a relevant function to convert the type of the field into a string i.e. <code>string_of_bool</code></p><p>See <code>xapi-cli-server/records.ml</code> for examples of handling field types other than Bool.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=adding-a-function-to-the-api>Adding a function to the API</h1><p>This page describes how to add a function to XenAPI.</p><h2 id=add-message-to-api>Add message to API</h2><p>The file <code>idl/datamodel.ml</code> is a description of the API, from which the
marshalling and handler code is generated.</p><p>In this file, the <code>create_obj</code> function is used to define a class which may
contain fields and support operations (known as &ldquo;messages&rdquo;). For example, the
identifier host is defined using create_obj to encapsulate the operations which
can be performed on a host.</p><p>In order to add a function to the API, we need to add a message to an existing
class. This entails adding a function in <code>idl/datamodel.ml</code> or one of the other datamodel files to describe the new
message and adding it to the class&rsquo;s list of messages. In this example, we are adding to <code>idl/datamodel_host.ml</code>.</p><p>The function to describe the new message will look something like the following:</p><pre><code>let host_price_of = call ~flags:[`Session]
    ~name:&quot;price_of&quot;
    ~in_oss_since:None
    ~lifecycle:[]
    ~params:[(Ref _host, &quot;host&quot;, &quot;The host containing the price information&quot;);
             (String, &quot;item&quot;, &quot;The item whose price is queried&quot;)]
    ~result:(Float, &quot;The price of the item&quot;)
    ~doc:&quot;Returns the price of a named item.&quot;
    ~allowed_roles:_R_POOL_OP
    ()
</code></pre><p>By convention, the name of the function is formed from the name of the class
and the name of the message: host and price_of, in the example. An entry for
host_price_of is added to the messages of the host class:</p><pre><code>let host =
    create_obj ...
        ~messages: [...
                    host_price_of;
                   ]
...
</code></pre><p>The parameters passed to call are all optional (except ~name and ~lifecycle).</p><ul><li><p>The ~flags parameter is used to set conditions for the use of the message.
For example, `Session is used to indicate that the call must be made in the
presence of an existing session.</p></li><li><p>The value of the <code>~lifecycle</code> parameter should be <code>[]</code> in new code, with dune
automatically generating appropriate values (<code>datamodel_lifecycle.ml</code>)</p></li><li><p>The ~params parameter describes a list of the formal parameters of the message.
Each parameter is described by a triple. The first component of the triple is
the type (from type ty in <code>idl/datamodel_types.ml</code>); the second is the name
of the parameter, and the third is a human-readable description of the parameter.
The first triple in the list is conventionally the instance of the class on
which the message will operate. In the example, this is a reference to the host.</p></li><li><p>Similarly, the ~result describes the message&rsquo;s return type, although this is
permitted to merely be a single value rather than a list of values. If no
~result is specified, the default is unit.</p></li><li><p>The ~doc parameter describes what the message is doing.</p></li><li><p>The bool ~hide_from_docs parameter prevents the message from being included in the documentation when generated.</p></li><li><p>The bool ~pool_internal parameter is used to indicate if the message should be callable by external systems or only internal hosts.</p></li><li><p>The ~errs parameter is a list of possible exceptions that the message can raise.</p></li><li><p>The parameter ~lifecycle takes in an array of (Status, version, doc) to indicate the lifecycle of the message type. This takes over from ~in_oss_since which indicated the release that the message type was introduced. NOTE: Leave this parameter empty, it will be populated on build.</p></li><li><p>The ~allowed_roles parameter is used for access control (see below).</p></li></ul><p>Compiling <code>xen-api.(hg|git)</code> will cause the code corresponding to this message
to be generated and output in <code>ocaml/xapi/server.ml</code>. In the example above, a
section handling an incoming call host.price_of appeared in <code>ocaml/xapi/server.ml</code>.
However, after this was generated, the rest of the build failed because this
call expects a price_of function in the Host object.</p><h2 id=update-expose_get_all_messages_for-list>Update expose_get_all_messages_for list</h2><p>If you are adding a new class, do not forget to add your new class _name to
the expose_get_all_messages_for list, at the bottom of datamodel.ml, in
order to have automatically generated get_all and get_all_records functions
attached to it.</p><h2 id=update-the-rbac-field-containing-the-roles-expected-to-use-the-new-api-call>Update the RBAC field containing the roles expected to use the new API call</h2><p>After the RBAC integration, Xapi provides by default a set of static roles
associated to the most common subject tasks.</p><p>The api calls associated with each role are defined by a new <code>~allowed_roles</code>
parameter in each api call, which specifies the list of static roles that
should be able to execute the call. The possible roles for this list is one of
the following names, defined in <code>datamodel.ml</code>:</p><ul><li>role_pool_admin</li><li>role_pool_operator</li><li>role_vm_power_admin</li><li>role_vm_admin</li><li>role_vm_operator</li><li>role_read_only</li></ul><p>So, for instance,</p><pre><code>~allowed_roles:[role_pool_admin,role_pool_operator] (* this is not the recommended usage, see example below *)
</code></pre><p>would be a valid list (though it is not the recommended way of using
allowed_roles, see below), meaning that subjects belonging to either
role_pool_admin or role_pool_operator can execute the api call.</p><p>The RBAC requirements define a policy where the roles in the list above are
supposed to be totally-ordered by the set of api-calls associated with each of
them. That means that any api-call allowed to role_pool_operator should also be
in role_pool_admin; any api-call allowed to role_vm_power_admin should also be
in role_pool_operator and also in role_pool_admin; and so on. Datamodel.ml
provides shortcuts for expressing these totally-ordered set of roles policy
associated with each api-call:</p><ul><li>_R_POOL_ADMIN, equivalent to [role_pool_admin]</li><li>_R_POOL_OP, equivalent to [role_pool_admin,role_pool_operator]</li><li>_R_VM_POWER_ADMIN, equivalent to [role_pool_admin,role_pool_operator,role_vm_power_admin]</li><li>_R_VM_ADMIN, equivalent to [role_pool_admin,role_pool_operator,role_vm_power_admin,role_vm_admin]</li><li>_R_VM_OP, equivalent to [role_pool_admin,role_pool_operator,role_vm_power_admin,role_vm_admin,role_vm_op]</li><li>_R_READ_ONLY, equivalent to [role_pool_admin,role_pool_operator,role_vm_power_admin,role_vm_admin,role_vm_op,role_read_only]</li></ul><p>The <code>~allowed_roles</code> parameter should use one of the shortcuts in the list above,
instead of directly using a list of roles, because the shortcuts above make sure
that the roles in the list are in a total order regarding the api-calls
permission sets. Creating an api-call with e.g.
allowed_roles:[role_pool_admin,role_vm_admin] would be wrong, because that
would mean that a pool_operator cannot execute the api-call that a vm_admin can,
breaking the total-order policy expected in the RBAC 1.0 implementation.
In the future, this requirement might be relaxed.</p><p>So, the example above should instead be used as:</p><pre><code>~allowed_roles:_R_POOL_OP  (* recommended usage via pre-defined totally-ordered role lists *)
</code></pre><p>and so on.</p><h2 id=how-to-determine-the-correct-role-of-a-new-api-call>How to determine the correct role of a new api-call:</h2><ul><li>if only xapi should execute the api-call, ie. it is an internal call: _R_POOL_ADMIN</li><li>if it is related to subject, role, external-authentication: _R_POOL_ADMIN</li><li>if it is related to accessing Dom0 (via console, ssh, whatever): _R_POOL_ADMIN</li><li>if it is related to the pool object: R_POOL_OP</li><li>if it is related to the host object, licenses, backups, physical devices: _R_POOL_OP</li><li>if it is related to managing VM memory, snapshot/checkpoint, migration: _R_VM_POWER_ADMIN</li><li>if it is related to creating, destroying, cloning, importing/exporting VMs: _R_VM_ADMIN</li><li>if it is related to starting, stopping, pausing etc VMs or otherwise accessing/manipulating VMs: _R_VM_OP</li><li>if it is related to being able to login, manipulate own tasks and read values only: _R_READ_ONLY</li></ul><h2 id=update-message-forwarding>Update message forwarding</h2><p>The &ldquo;message forwarding&rdquo; layer describes the policy of whether an incoming API
call should be forwarded to another host (such as another member of the pool)
or processed on the host which receives the call. This policy may be
non-trivial to describe and so cannot be auto-generated from the data model.</p><p>In <code>xapi/message_forwarding.ml</code>, add a function to the relevant module to
describe this policy. In the running example, we add the following function to
the Host module:</p><pre><code>let price_of ~__context ~host ~item =
    info &quot;Host.price_of for item %s&quot; item;
    let local_fn = Local.Host.price_of ~host ~item in
    do_op_on ~local_fn ~__context ~host
      (fun session_id rpc -&gt; Client.Host.price_of ~rpc ~session_id ~host ~item)
</code></pre><p>After the ~__context parameter, the parameters of this new function should
match the parameters we specified for the message. In this case, that is the
host and the item to query the price of.</p><p>The do_op_on function takes a function to execute locally and a function to
execute remotely and performs one of these operations depending on whether the
given host is the local host.</p><p>The local function references Local.Host.price_of, which is a function we will
write in the next step.</p><h2 id=implement-the-function>Implement the function</h2><p>Now we write the function to perform the logic behind the new API call.
For a host-based call, this will reside in <code>xapi/xapi_host.ml</code>. For other
classes, other files with similar names are used.</p><p>We add the following function to <code>xapi/xapi_host.ml</code>:</p><pre><code>let price_of ~__context ~host ~item =
    if item = &quot;fish&quot; then 3.14 else 0.00
</code></pre><p>We also need to add the function to the interface <code>xapi/xapi_host.mli</code>:</p><pre><code>val price_of :
    __context:Context.t -&gt; host:API.ref_host -&gt; item:string -&gt; float
</code></pre><p>Congratulations, you&rsquo;ve added a function to the API!</p><h2 id=add-the-operation-to-the-cli>Add the operation to the CLI</h2><p>Edit <code>xapi-cli-server/cli_frontend.ml</code>. Add a block to the definition of cmdtable_data as
in the following example:</p><pre><code>&quot;host-price-of&quot;,
{
  reqd=[&quot;host-uuid&quot;; &quot;item&quot;];
  optn=[];
  help=&quot;Find out the price of an item on a certain host.&quot;;
  implementation= No_fd Cli_operations.host_price_of;
  flags=[];
};
</code></pre><p>Include here the following:</p><ul><li><p>The names of required (<em>reqd</em>) and optional (<em>optn</em>) parameters.</p></li><li><p>A description to be displayed when calling <em>xe help &lt;cmd></em> in the help field.</p></li><li><p>The <em>implementation</em> should use <em>With_fd</em> if any communication with the
client is necessary (for example, showing the user a warning, sending the
contents of a file, etc.) Otherwise, <em>No_fd</em> can be used as above.</p></li><li><p>The <em>flags</em> field can be used to set special options:</p><ul><li><em>Vm_selectors</em>: adds a &ldquo;vm&rdquo; parameter for the name of a VM (rather than a UUID)</li><li><em>Host_selectors</em>: adds a &ldquo;host&rdquo; parameter for the name of a host (rather than a UUID)</li><li><em>Standard</em>: includes the command in the list of common commands displayed by <em>xe help</em></li><li><em>Neverforward:</em></li><li><em>Hidden:</em></li><li><em>Deprecated of string list:</em></li></ul></li></ul><p>Now we must implement <code>Cli_operations.host_price_of</code>. This is done in
<code>xapi-cli-server/cli_operations.ml</code>. This function typically extracts the parameters and
forwards them to the internal implementation of the function. Other arbitrary
code is permitted. For example:</p><pre><code>let host_price_of printer rpc session_id params =
  let host = Client.Host.get_by_uuid rpc session_id (List.assoc &quot;host-uuid&quot; params) in
  let item = List.assoc &quot;item&quot; params in
  let price = string_of_float (Client.Host.price_of ~rpc ~session_id ~host ~item) in
  printer (Cli_printer.PList [price])
</code></pre><h2 id=tab-completion-in-the-cli>Tab Completion in the CLI</h2><p>The CLI features tab completion for many of its commands&rsquo; parameters.
Tab completion is implemented in the file <code>ocaml/xe-cli/bash-completion</code>, which
is installed on the host as <code>/etc/bash_completion.d/cli</code>, and is done on a
parameter-name rather than on a command-name basis. The main portion of the
bash-completion file is a case statement that contains a section for each of
the parameters that benefit from completion. There is also an entry that
catches all parameter names ending at -uuid, and performs an automatic lookup
of suitable UUIDs. The host-uuid parameter of our new host-price-of command
therefore automatically gains completion capabilities.</p><h2 id=executing-the-cli-operation>Executing the CLI operation</h2><p>Recompile <code>xapi</code> with the changes described above and install it on a test machine.</p><p>Execute the following command to see if the function exists:</p><pre><code>xe help host-price-of
</code></pre><p>Invoke the function itself with the following command:</p><pre><code>xe host-price-of host-uuid=&lt;tab&gt; item=fish
</code></pre><p>and you should find out the price of fish.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=adding-a-xenapi-extension>Adding a XenAPI extension</h1><p>A XenAPI extension is a new RPC which is implemented as a separate executable
(i.e. it is not part of <code>xapi</code>)
but which still benefits from <code>xapi</code> parameter type-checking, multi-language
stub generation, documentation generation, authentication etc.
An extension can be backported to previous versions by simply adding the
implementation, without having to recompile <code>xapi</code> itself.</p><p>A XenAPI extension is in two parts:</p><ol><li>a declaration in the <a href=https://github.com/xapi-project/xen-api/blob/07056d661bbf58b652e1da59d9adf67a778a5626/ocaml/idl/datamodel.ml#L5608 target=_blank>xapi datamodel</a>.
This must use the <code>~forward_to:(Extension "filename")</code> parameter. The filename must be unique, and
should be the same as the XenAPI call name.</li><li>an implementation executable in the dom0 filesystem with path <code>/etc/xapi.d/extensions/filename</code></li></ol><h2 id=to-define-an-extension>To define an extension</h2><p>First write the declaration in the datamodel. The act of specifying the
types and writing the documentation will help clarify the intended meaning
of the call.</p><p>Second create a prototype of your implementation and put an executable file
in <code>/etc/xapi.d/extensions/filename</code>. The calling convention is:</p><ul><li>the file must be executable</li><li><code>xapi</code> will parse the XMLRPC call arguments received over the network and check the <code>session_id</code> is
valid</li><li><code>xapi</code> will execute the named executable</li><li>the XMLRPC call arguments will be sent to the executable on <code>stdin</code> and
<code>stdin</code> will be closed afterwards</li><li>the executable will run and print an XMLRPC response on <code>stdout</code></li><li><code>xapi</code> will read the response and return it to the client.</li></ul><p>See the <a href=https://github.com/xapi-project/xen-api/blob/07056d661bbf58b652e1da59d9adf67a778a5626/scripts/extensions/Test.test target=_blank>basic example</a>.</p><p>Second make a <a href=https://github.com/xapi-project/xen-api/pulls target=_blank>pull request</a>
containing only the datamodel definitions (it is not necessary to include the
prototype too).
This will attract review comments which will help you improve your API further.
Once the pull request is merged, then the API call name and extension are officially
yours and you may use them on any xapi version which supports the extension mechanism.</p><h2 id=packaging-your-extension>Packaging your extension</h2><p>Your extension <code>/etc/xapi.d/extensions/filename</code> (and dependencies) should be
packaged for your target distribution (for XenServer dom0 this would be a CentOS
RPM). Once the package is unpacked on the target machine, the extension should
be immediately callable via the XenAPI, provided the <code>xapi</code> version supports
the extension mechanism. Note the <code>xapi</code> version does not need to know about
the specific extension in advance: it will always look in <code>/etc/xapi.d/extensions/</code> for
all RPC calls whose name it does not recognise.</p><h2 id=limitations>Limitations</h2><p>On type-checking</p><ul><li>if the <code>xapi</code> version is new enough to know about your specific extension:
<code>xapi</code> will type-check the call arguments for you</li><li>if the <code>xapi</code> version is too old to know about your specific extension:
the extension will still be callable but the arguments will not be type-checked.</li></ul><p>On access control</p><ul><li>if the <code>xapi</code> version is new enough to know about your specific extension:
you can declare that a user must have a particular role (e.g. &lsquo;VM admin&rsquo;)</li><li>if the <code>xapi</code> version is too old to know about your specific extension:
the extension will still be callable but the client must have the &lsquo;Pool admin&rsquo; role.</li></ul><p>Since a <code>xapi</code> which knows about your specific extension is stricter than an older
<code>xapi</code>, it&rsquo;s a good idea to develop against the new <code>xapi</code> and then test older
<code>xapi</code> versions later.</p><footer class=footline></footer></article></section></section><article class=default><header class=headline></header><h1 id=database>Database</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Database</h1><article class=default><header class=headline></header><h1 id=metadata-on-lun>Metadata-on-LUN</h1><p>In the present version of XenServer, metadata changes resulting in
writes to the database are not persisted in non-volatile storage. Hence,
in case of failure, up to five minutes’ worth of metadata changes could
be lost. The Metadata-on-LUN feature addresses the issue by
ensuring that all database writes are retained. This will be used to
improve recovery from failure by storing incremental <em>deltas</em> which can
be re-applied to an old version of the database to bring it more
up-to-date. An implication of this is that clients will no longer be
required to perform a ‘pool-sync-database’ to protect critical writes,
because all writes will be implicitly protected.</p><p>This is implemented by saving descriptions of all persistent database
writes to a LUN when HA is active. Upon xapi restart after failure, such
as on master fail-over, these descriptions are read and parsed to
restore the latest version of the database.</p><h1 id=layout-on-block-device>Layout on block device</h1><p>It is useful to store the database on the block device as well as the
deltas, so that it is unambiguous on recovery which version of the
database the deltas apply to.</p><p>The content of the block device will be structured as shown in
the table below. It consists of a header; the rest of the
device is split into two halves.</p><table><thead><tr><th></th><th style=text-align:right>Length (bytes)</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td style=text-align:right>16</td><td>Magic identifier</td></tr><tr><td></td><td style=text-align:right>1</td><td>ASCII NUL</td></tr><tr><td></td><td style=text-align:right>1</td><td>Validity byte</td></tr><tr><td>First half database</td><td style=text-align:right>36</td><td>UUID as ASCII string</td></tr><tr><td></td><td style=text-align:right>16</td><td>Length of database as decimal ASCII</td></tr><tr><td></td><td style=text-align:right><em>(as specified)</em></td><td>Database (binary data)</td></tr><tr><td></td><td style=text-align:right>16</td><td>Generation count as decimal ASCII</td></tr><tr><td></td><td style=text-align:right>36</td><td>UUID as ASCII string</td></tr><tr><td>First half deltas</td><td style=text-align:right>16</td><td>Length of database delta as decimal ASCII</td></tr><tr><td></td><td style=text-align:right><em>(as specified)</em></td><td>Database delta (binary data)</td></tr><tr><td></td><td style=text-align:right>16</td><td>Generation count as decimal ASCII</td></tr><tr><td></td><td style=text-align:right>36</td><td>UUID as ASCII string</td></tr><tr><td>Second half database</td><td style=text-align:right>36</td><td>UUID as ASCII string</td></tr><tr><td></td><td style=text-align:right>16</td><td>Length of database as decimal ASCII</td></tr><tr><td></td><td style=text-align:right><em>(as specified)</em></td><td>Database (binary data)</td></tr><tr><td></td><td style=text-align:right>16</td><td>Generation count as decimal ASCII</td></tr><tr><td></td><td style=text-align:right>36</td><td>UUID as ASCII string</td></tr><tr><td>Second half deltas</td><td style=text-align:right>16</td><td>Length of database delta as decimal ASCII</td></tr><tr><td></td><td style=text-align:right><em>(as specified)</em></td><td>Database delta (binary data)</td></tr><tr><td></td><td style=text-align:right>16</td><td>Generation count as decimal ASCII</td></tr><tr><td></td><td style=text-align:right>36</td><td>UUID as ASCII string</td></tr></tbody></table><p>After the header, one or both halves may be devoid of content. In a half
which contains a database, there may be zero or more deltas (repetitions
of the last three entries in each half).</p><p>The structure of the device is split into two halves to provide
double-buffering. In case of failure during write to one half, the other
half remains intact.</p><p>The magic identifier at the start of the file protect against attempting
to treat a different device as a redo log.</p><p>The validity byte is a single `ascii character indicating the
state of the two halves. It can take the following values:</p><table><thead><tr><th>Byte</th><th>Description</th></tr></thead><tbody><tr><td><code>0</code></td><td>Neither half is valid</td></tr><tr><td><code>1</code></td><td>First half is valid</td></tr><tr><td><code>2</code></td><td>Second half is valid</td></tr></tbody></table><p>The use of lengths preceding data sections permit convenient reading.
The constant repetitions of the UUIDs act as nonces to protect
against reading in invalid data in the case of an incomplete or corrupt
write.</p><h1 id=architecture>Architecture</h1><p>The I/O to and from the block device may involve long delays. For
example, if there is a network problem, or the iSCSI device disappears,
the I/O calls may block indefinitely. It is important to isolate this
from xapi. Hence, I/O with the block device will occur in a separate
process.</p><p>Xapi will communicate with the I/O process via a UNIX domain socket using a
simple text-based protocol described below. The I/O process will use to
ensure that it can always accept xapi’s requests with a guaranteed upper
limit on the delay. Xapi can therefore communicate with the process
using blocking I/O.</p><p>Xapi will interact with the I/O process in a best-effort fashion. If it
cannot communicate with the process, or the process indicates that it
has not carried out the requested command, xapi will continue execution
regardless. Redo-log entries are idempotent (modulo the raising of
exceptions in some cases) so it is of little consequence if a particular
entry cannot be written but others can. If xapi notices that the process
has died, it will attempt to restart it.</p><p>The I/O process keeps track of a pointer for each half indicating the
position at which the next delta will be written in that half.</p><h2 id=protocol>Protocol</h2><p>Upon connection to the control socket, the I/O process will attempt to
connect to the block device. Depending on whether this is successful or
unsuccessful, one of two responses will be sent to the client.</p><ul><li><p><code>connect|ack_</code> if it is successful; or</p></li><li><p><code>connect|nack|&lt;length>|&lt;message></code> if it is unsuccessful, perhaps
because the block device does not exist or cannot be read from. The
<code>&lt;message></code> is a description of the error; the <code>&lt;length></code> of the message
is expressed using 16 digits of decimal ascii.</p></li></ul><p>The former message indicates that the I/O process is ready to receive
commands. The latter message indicates that commands can not be sent to
the I/O process.</p><p>There are three commands which xapi can send to the I/O
process. These are described below, with a high level description of the
operational semantics of the I/O process’ actions, and the corresponding
responses. For ease of parsing, each command is ten bytes in length.</p><h3 id=write-database>Write database</h3><p>Xapi requests that a new database is written to the block device, and
sends its content using the data socket.</p><h5 id=command>Command:</h5><dl><dt>: <code>writedb___|&lt;uuid>|&lt;generation-count>|&lt;length></code></dt><dd>The UUID is expressed as 36 ASCII
characters. The <em>length</em> of the data and the <em>generation-count</em> are
expressed using 16 digits of decimal ASCII.</dd></dl><h5 id=semantics>Semantics:</h5><ol><li>Read the validity byte.</li><li>If one half is valid, we will use the other half. If no halves
are valid, we will use the first half.</li><li>Read the data from the data socket and write it into the
chosen half.</li><li>Set the pointer for the chosen half to point to the position
after the data.</li><li>Set the validity byte to indicate the chosen half is valid.</li></ol><h5 id=response>Response:</h5><dl><dt>: <code>writedb|ack_</code> in case of successful write; or</dt><dd><code>writedb|nack|&lt;length>|&lt;message></code> otherwise.</dd><dd>For error messages, the <em>length</em> of the message is expressed using
16 digits of decimal ascii. In particular, the
error message for timeouts is the string <code>Timeout</code>.</dd></dl><h3 id=write-database-delta>Write database delta</h3><p>Xapi sends a description of a database delta to append to the block
device.</p><h5 id=command-1>Command:</h5><dl><dt>: <code>writedelta|&lt;uuid>|&lt;generation-count>|&lt;length>|&lt;data></code></dt><dd>The UUID is expressed as 36 ASCII
characters. The <em>length</em> of the data and the <em>generation-count</em> are
expressed using 16 digits of decimal ASCII.</dd></dl><h5 id=semantics-1>Semantics:</h5><ol><li>Read the validity byte to establish which half is valid. If
neither half is valid, return with a <code>nack</code>.</li><li>If the half’s pointer is set, seek to that position. Otherwise,
scan through the half and stop at the position after the
last write.</li><li>Write the entry.</li><li>Update the half’s pointer to point to the position after
the entry.</li></ol><h5 id=response-1>Response:</h5><dl><dt>: <code>writedelta|ack_</code> in case of successful append; or</dt><dd><code>writedelta|nack|&lt;length>|&lt;message></code> otherwise.</dd><dd>For error messages, the <em>length</em> of the message is expressed using
16 digits of decimal ASCII. In particular, the
error message for timeouts is the string <code>Timeout</code>.</dd></dl><h3 id=read-log>Read log</h3><p>Xapi requests the contents of the log.</p><h5 id=command-2>Command:</h5><p>: <code>read______</code></p><h5 id=semantics-2>Semantics:</h5><ol><li>Read the validity byte to establish which half is valid. If
neither half is valid, return with an <code>end</code>.</li><li>Attempt to read the database from the current half.</li><li>If this is successful, continue in that half reading entries up
to the position of the half’s pointer. If the pointer is not
set, read until a record of length zero is found or the end of
the half is reached. Otherwise—if the attempt to the read the
database was not successful—switch to using the other half and
try again from step 2.</li><li>Finally output an <code>end</code>.</li></ol><h5 id=response-2>Response:</h5><dl><dt>: <code>read|nack_|&lt;length>|&lt;message></code> in case of error; or</dt><dd><code>read|db___|&lt;generation-count>|&lt;length>|&lt;data></code> for a database record, then a
sequence of zero or more</dd><dd><code>read|delta|&lt;generation-count>|&lt;length>|&lt;data></code> for each delta record, then</dd><dd><code>read|end__</code></dd><dd>For each record, and for error messages, the <em>length</em> of the data or
message is expressed using 16 digits of decimal ascii. In particular, the
error message for timeouts is the string <code>Timeout</code>.</dd></dl><h3 id=re-initialise-log>Re-initialise log</h3><p>Xapi requests that the block device is re-initialised with a fresh
redo-log.</p><h5 id=command-3>Command:</h5><p>: <code>empty_____</code>\</p><h5 id=semantics-3>Semantics:</h5><p>: 1. Set the validity byte to indicate that neither half is valid.</p><h5 id=response-3>Response:</h5><dl><dt>: <code>empty|ack_</code> in case of successful re-initialisation; or</dt><dt><code>empty|nack|&lt;length>|&lt;message></code> otherwise.</dt><dd>For error messages, the <em>length</em> of the message is expressed using
16 digits of decimal ASCII. In particular, the
error message for timeouts is the string <code>Timeout</code>.</dd></dl><h1 id=impact-on-xapi-performance>Impact on xapi performance</h1><p>The implementation of the feature causes a slow-down in xapi of around
6% in the general case. However, if the LUN becomes inaccessible this
can cause a slow-down of up to 25% in the worst case.</p><p>The figure below shows the result of testing four configurations,
counting the number of database writes effected through a command-line
‘xe pool-param-set’ call.</p><ul><li><p>The first and second configurations are xapi <em>without</em> the
Metadata-on-LUN feature, with HA disabled and
enabled respectively.</p></li><li><p>The third configuration shows xapi <em>with</em> the
Metadata-on-LUN feature using a healthy LUN to which
all database writes can be successfully flushed.</p></li><li><p>The fourth configuration shows xapi <em>with</em> the
Metadata-on-LUN feature using an inaccessible LUN for
which all database writes fail.</p></li></ul><p><a href=#image-a59031294d2bde67173556dcdf3c9b70 class=lightbox-link><img src=/new-docs/xapi/database/redo-log/performance.svg alt="Impact of feature on xapi database-writing performance. (Green points
represent individual samples; red bars are the arithmetic means of
samples.)" class="figure-image noborder lightbox noshadow" style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=image-a59031294d2bde67173556dcdf3c9b70><img src=/new-docs/xapi/database/redo-log/performance.svg alt="Impact of feature on xapi database-writing performance. (Green points
represent individual samples; red bars are the arithmetic means of
samples.)" class="lightbox-image noborder lightbox noshadow" loading=lazy></a></p><h1 id=testing-strategy>Testing strategy</h1><p>The section above shows how xapi performance is affected by this feature. The
sections below describe the dev-testing which has already been undertaken, and
propose how this feature will impact on regression testing.</p><h2 id=dev-testing-performed>Dev-testing performed</h2><p>A variety of informal tests have been performed as part of the
development process:</p><dl><dt>Enable HA.</dt><dd><p>Confirm LUN starts being used to persist database writes.</p></dd><dt>Enable HA, disable HA.</dt><dd><p>Confirm LUN stops being used.</p></dd><dt>Enable HA, kill xapi on master, restart xapi on master.</dt><dd><p>Confirm that last database write before kill is successfully
restored on restart.</p></dd><dt>Repeatedly enable and disable HA.</dt><dd><p>Confirm that no file descriptors are leaked (verified by counting
the number of descriptors in /proc/<em>pid</em>/fd/).</p></dd><dt>Enable HA, reboot the master.</dt><dd><p>Due to HA, a slave becomes the master (or this can be forced using
‘xe pool-emergency-transition-to-master’). Confirm that the new
master starts is able to restore the database from the LUN from the
point the old master left off, and begins to write new changes to
the LUN.</p></dd><dt>Enable HA, disable the iSCSI volume.</dt><dd><p>Confirm that xapi continues to make progress, although database
writes are not persisted.</p></dd><dt>Enable HA, disable and enable the iSCSI volume.</dt><dd><p>Confirm that xapi begins to use the LUN when the iSCSI volume is
re-enabled and subsequent writes are persisted.</p></dd></dl><p>These tests have been undertaken using an iSCSI target VM and a real
iSCSI volume on lannik. In these scenarios, disabling the iSCSI volume
consists of stopping the VM and unmapping the LUN, respectively.</p><h2 id=proposed-new-regression-test>Proposed new regression test</h2><p>A new regression test is proposed to confirm that all database writes
are persisted across failure.</p><p>There are three types of database modification to test: row creation,
field-write and row deletion. Although these three kinds of write could
be tested in separate tests, the means of setting up the pre-conditions
for a field-write and a row deletion require a row creation, so it is
convenient to test them all in a single test.</p><ol><li><p>Start a pool containing three hosts.</p></li><li><p>Issue a CLI command on the master to create a row in the
database, e.g.</p><p><code>xe network-create name-label=a</code>.</p></li><li><p>Forcefully power-cycle the master.</p></li><li><p>On fail-over, issue a CLI command on the new master to check that
the row creation persisted:</p><p><code>xe network-list name-label=a</code>,</p><p>confirming that the returned string is non-empty.</p></li><li><p>Issue a CLI command on the master to modify a field in the new row
in the database:</p><p><code>xe network-param-set uuid=&lt;uuid> name-description=abcd</code>,</p><p>where <code>&lt;uuid></code> is the UUID returned from step 2.</p></li><li><p>Forcefully power-cycle the master.</p></li><li><p>On fail-over, issue a CLI command on the new master to check that
the field-write persisted:</p><p><code>xe network-param-get uuid=&lt;uuid> param-name=name-description</code>,</p><p>where <code>&lt;uuid></code> is the UUID returned from step 2. The returned string
should contain</p><p><code>abcd</code>.</p></li><li><p>Issue a CLI command on the master to delete the row from the
database:</p><p><code>xe network-destroy uuid=&lt;uuid></code>,</p><p>where <code>&lt;uuid></code> is the UUID returned from step 2.</p></li><li><p>Forcefully power-cycle the master.</p></li><li><p>On fail-over, issue a CLI command on the new master to check that
the row does not exist:</p><p><code>xe network-list name-label=a</code>,</p><p>confirming that the returned string is empty.</p></li></ol><h2 id=impact-on-existing-regression-tests>Impact on existing regression tests</h2><p>The Metadata-on-LUN feature should mean that there is no
need to perform an ‘xe pool-sync-database’ operation in existing HA
regression tests to ensure that database state persists on xapi failure.</p><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=host-memory-accounting>Host memory accounting</h1><p>Memory is used for many things:</p><ul><li>the hypervisor code: this is the Xen executable itself</li><li>the hypervisor heap: this is needed for per-domain structures and per-vCPU
structures</li><li>the crash kernel: this is needed to collect information after a host crash</li><li>domain RAM: this is the memory the VM believes it has</li><li>shadow memory: for HVM guests running on hosts without hardware assisted
paging (HAP) Xen uses shadow to optimise page table updates. For all guests
shadow is used during live migration for tracking the memory transfer.</li><li>video RAM for the virtual graphics card</li></ul><p>Some of these are constants (e.g. hypervisor code) while some depend on the VM
configuration (e.g. domain RAM). Xapi calls the constants &ldquo;host overhead&rdquo; and
the variables due to VM configuration as &ldquo;VM overhead&rdquo;. There is no low-level
API to query this information, therefore xapi will sample the host overheads
at system boot time and model the per-VM overheads.</p><h2 id=host-overhead>Host overhead</h2><p>The host overhead is not managed by xapi, instead it is sampled. After the host
boots and before any VMs start, xapi asks Xen how much memory the host has in
total, and how much memory is currently free. Xapi subtracts the free from the
total and stores this as the host overhead.</p><h2 id=vm-overhead>VM overhead</h2><p>The inputs to the model are</p><ul><li><code>VM.memory_static_max</code>: the maximum amount of RAM the domain will be able to use</li><li><code>VM.HVM_shadow_multiplier</code>: allows the shadow memory to be increased</li><li><code>VM.VCPUs_max</code>: the maximum number of vCPUs the domain will be able to use</li></ul><p>First the shadow memory is calculated, in MiB</p><p><a href=#image-7135620513a6833d0624db7516c2541d class=lightbox-link><img src=/new-docs/xapi/memory/shadow.svg alt="Shadow memory in MiB" class="figure-image noborder lightbox noshadow" style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=image-7135620513a6833d0624db7516c2541d><img src=/new-docs/xapi/memory/shadow.svg alt="Shadow memory in MiB" class="lightbox-image noborder lightbox noshadow" loading=lazy></a></p><p>Second the VM overhead is calculated, in MiB</p><p><a href=#image-e4dedb0ea21263df3220a46b6d4626d3 class=lightbox-link><img src=/new-docs/xapi/memory/overhead.svg alt="Memory overhead in MiB" class="figure-image noborder lightbox noshadow" style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=image-e4dedb0ea21263df3220a46b6d4626d3><img src=/new-docs/xapi/memory/overhead.svg alt="Memory overhead in MiB" class="lightbox-image noborder lightbox noshadow" loading=lazy></a></p><h2 id=memory-required-to-start-a-vm>Memory required to start a VM</h2><p>If ballooning is disabled, the memory required to start a VM is the same as the VM
overhead above.</p><p>If ballooning is enabled then the memory calculation above is modified to use the
<code>VM.memory_dynamic_max</code> rather than the <code>VM.memory_static_max</code>.</p><h2 id=memory-required-to-migrate-a-vm>Memory required to migrate a VM</h2><p>If ballooning is disabled, the memory required to receive a migrating VM is the same
as the VM overhead above.</p><p>If ballooning is enabled, then the VM will first be ballooned down to <code>VM.memory_dynamic_min</code>
and then it will be migrated across. If the VM fails to balloon all the way down, then
correspondingly more memory will be required on the receiving side.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xapi-requests-walk-throughs>XAPI requests walk-throughs</h1><p>Let&rsquo;s detail the handling process of an XML request within XAPI.
The first document uses the migration as an example of such request.</p><ul><li><a href=/new-docs/xapi/walkthroughs/migration_overview.md>How the migration request goes through Xen API?</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of XAPI requests walk-throughs</h1><article class=default><header class=headline></header><h1 id=from-rpc-migration-request-to-xapi-internals>From RPC migration request to xapi internals</h1><h2 id=overview>Overview</h2><p>In this document we will use the <code>VM.pool_migrate</code> request to illustrate
the interaction between various components within the XAPI toolstack during
migration. However this schema can be applied to other requests as well.</p><p>Not all parts of the Xapi toolstack are shown here as not all are involved in
the migration process. For instance you won&rsquo;t see the <em><strong>squeezed</strong></em>
nor <em><strong>mpathalert</strong></em> two daemons that belong to the toolstack but don&rsquo;t
participate in the migration of a VM.</p><h2 id=anatomy-of-a-vm-migration>Anatomy of a VM migration</h2><ul><li>Migration is initiated by a Xapi client that sends <code>VM.pool_migrate</code>, an RPC
XML request.</li><li>The Xen API server handles this request and dispatches it to the server.</li><li>The server is generated using <code>XAPI IDL</code> and requests are wrapped whithin a
context, either to be forwarded to a host or executed locally. Broadly, the
context follows RBAC rules. The executed function is related to the message of
the request (refer to <a href=https://xapi-project.github.io/xen-api/ target=_blank>XenAPI Reference</a>).</li><li>In the case of the migration you can refer to <em>ocaml/idl/datamodel_vm.ml</em>.</li><li>The server will dispatch the operation to server helpers, executing the
operation synchronously or asynchronously and returning the RPC answer.</li><li><em>Message forwarding</em> decides if operation must be executed by another host
of the pool and then forward the call or if is executed locally.</li><li>When executed locally the high-level migration operation is send to the
<em>Xenopsd daemon</em> by posting a message on a known queue on the <em>message switch</em>.</li><li><em>Xenopsd</em> will get the command and will split it into several <em>atomic</em>
operations that will be run by the <em>xenopsd backend</em>.</li><li><em>Xenopsd</em> with its <em>backend</em> can then access xenstore or execute hypercall to
interact with xen a server the micro operation.</li></ul><h2 id=a-diagram-is-worth-a-thousand-words>A diagram is worth a thousand words</h2><div class="mermaid align-center">flowchart TD
%% First we are starting by a XAPI client that is sending an XML-RPC request
client((Xapi client)) -. sends RPC XML request .->
xapi_server{"`Dispatch RPC
**api_server.ml**`"}
style client stroke:#CAFEEE,stroke-width:4px
%% XAPI Toolstack internals
subgraph "Xapi Toolstack (master of the pool)"
style server stroke:#BAFA00,stroke-width:4px,stroke-dasharray: 5 5
xapi_server --dispatch call (ie VM.pool_migrate)--> server("`Auto generated using *IDL*
**server.ml**`")
server --do_dispatch (ie VM.pool_migrate)--> server_helpers["`server helpers
**server_helpers.ml**`"]
server_helpers -- call management (ie xapi_vm_migrate.ml)--> message_forwarding["`check where to run the call **message_forwarding.ml**`"]
message_forwarding -- execute locally --> vm_management["`VM Mgmt
like **xapi_vm_migrate.ml**`"]
vm_management -- Call --> xapi_xenops["`Transform xenops
see (**xapi_xenops.ml**)`"]
xapi_xenops &lt;-- Post following IDL model (see xenops_interface.ml) --> msg_switch
subgraph "Message Switch Daemon"
msg_switch[["Queues"]]
end
subgraph "Xenopsd Daemon"
msg_switch &lt;-- Push/Pop on org.xen.xapi.xenopsd.classic --> xenopsd_server
xenopsd_server["`Xenposd *frontend*
get & split high level opertion into atomics`"] o-- linked at compile time --o xenopsd_backend
end
end
%% Xenopsd backend is accessing xen and xenstore
xenopsd_backend["`Xenopsd *backend*
Backend XC (libxenctrl)`"] -. access to .-> xen_hypervisor["Xen hypervisor & xenstore"]
style xen_hypervisor stroke:#BEEF00,stroke-width:2px
%% Can send request to the host where call must be executed
message_forwarding -.forward call to .-> elected_host["Host where call must be executed"]
style elected_host stroke:#B0A,stroke-width:4px</div><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=xapis-storage-layers>XAPI's Storage Layers</h1><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>The links in this page point to the source files of xapi
<a href=https://github.com/xapi-project/xen-api/tree/v1.127.0 target=_blank>v1.127.0</a>, and xcp-idl
<a href=https://github.com/xapi-project/xcp-idl/tree/v1.62.0 target=_blank>v1.62.0</a>, not to the
latest source code.</p><p>In the beginning of 2023, significant changes have been made in the layering.
In particular, the wrapper code from <code>storage_impl.ml</code> has been pushed down the
stack, below the mux, such that it only covers the SMAPIv1 backend and not
SMAPIv3. Also, all of the code (from xcp-idl etc) is now present in this repo
(xen-api).</p></div></div><p>Xapi directly communicates only with the SMAPIv2 layer. There are no
plugins directly implementing the SMAPIv2 interface, but the plugins in
other layers are accessed through it:</p><div class="mermaid align-center">graph TD
A[xapi] --> B[SMAPIv2 interface]
B --> C[SMAPIv2 &lt;-> SMAPIv1 translation: storage_access.ml]
B --> D[SMAPIv2 &lt;-> SMAPIv3 translation: xapi-storage-script]
C --> E[SMAPIv1 plugins]
D --> F[SMAPIv3 plugins]</div><h2 id=smapiv1>SMAPIv1</h2><p>These are the files related to SMAPIv1 in <code>xen-api/ocaml/xapi/</code>:</p><ul><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/sm.ml target=_blank>sm.ml</a>:
OCaml &ldquo;bindings&rdquo; for the SMAPIv1 Python &ldquo;drivers&rdquo; (SM)</li><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/sm_exec.ml target=_blank>sm_exec.ml</a>:
support for implementing the above &ldquo;bindings&rdquo;. The
parameters are converted to XML-RPC, passed to the relevant python
script (&ldquo;driver&rdquo;), and then the standard output of the program is
parsed as an XML-RPC response (we use
<code>xen-api-libs-transitional/http-svr/xMLRPC.ml</code> for parsing XML-RPC).
When adding new functionality, we can modify <code>type call</code> to add parameters,
but when we don&rsquo;t add any common ones, we should just pass the new
parameters in the args record.</li><li><code>smint.ml</code>: Contains types, exceptions, &mldr; for the SMAPIv1 OCaml
interface</li></ul><h2 id=smapiv2>SMAPIv2</h2><p>These are the files related to SMAPIv2, which need to be modified to
implement new calls:</p><ul><li><a href=https://github.com/xapi-project/xcp-idl/blob/v1.62.0/storage/storage_interface.ml target=_blank>xcp-idl/storage/storage_interface.ml</a>:
Contains the SMAPIv2 interface</li><li><a href=https://github.com/xapi-project/xcp-idl/blob/v1.62.0/storage/storage_skeleton.ml target=_blank>xcp-idl/storage/storage_skeleton.ml</a>:
A stub SMAPIv2 storage server implementation that matches the
SMAPIv2 storage server interface (this is verified by
<a href=https://github.com/xapi-project/xcp-idl/blob/v1.62.0/storage/storage_skeleton_test.ml target=_blank>storage_skeleton_test.ml</a>),
each of its function just raise a <code>Storage_interface.Unimplemented</code>
error. This skeleton is used to automatically fill the unimplemented
methods of the below storage servers to satisfy the interface.</li><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml target=_blank>xen-api/ocaml/xapi/storage_access.ml</a>:
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml#L104 target=_blank>module SMAPIv1</a>:
a SMAPIv2 server that does SMAPIv2 -> SMAPIv1 translation.
It passes the XML-RPC requests as the first command-line argument to the
corresponding Python script, which returns an XML-RPC response on standard
output.</li><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_impl.ml target=_blank>xen-api/ocaml/xapi/storage_impl.ml</a>:
The
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_impl.ml#L302 target=_blank>Wrapper</a>
module wraps a SMAPIv2 server (Server_impl) and takes care of
locking and datapaths (in case of multiple connections (=datapaths)
from VMs to the same VDI, it will use the superstate computed by the
<a href=https://github.com/xapi-project/xcp-idl/blob/v1.62.0/storage/vdi_automaton.ml target=_blank>Vdi_automaton</a>
in xcp-idl). It also implements some functionality, like the <code>DP</code>
module, that is not implemented in lower layers.</li><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_mux.ml target=_blank>xen-api/ocaml/xapi/storage_mux.ml</a>:
A SMAPIv2 server, which multiplexes between other servers. A
different SMAPIv2 server can be registered for each SR. Then it
forwards the calls for each SR to the &ldquo;storage plugin&rdquo; registered
for that SR.</li></ul><h3 id=how-smapiv2-works>How SMAPIv2 works:</h3><p>We use <a href=https://github.com/xapi-project/message-switch target=_blank>message-switch</a> under the hood for RPC communication between
<a href=https://github.com/xapi-project/xcp-idl target=_blank>xcp-idl</a> components. The
main <code>Storage_mux.Server</code> (basically <code>Storage_impl.Wrapper(Mux)</code>) is
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml#L1279 target=_blank>registered to
listen</a>
on the &ldquo;<code>org.xen.xapi.storage</code>&rdquo; queue <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/xapi.ml#L801 target=_blank>during xapi&rsquo;s
startup</a>,
and this is the main entry point for incoming SMAPIv2 function calls.
<code>Storage_mux</code> does not really multiplex between different plugins right
now: <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/xapi.ml#L799 target=_blank>earlier during xapi&rsquo;s
startup</a>,
the same SMAPIv1 storage server module <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml#L934 target=_blank>is
registered</a>
on the various &ldquo;<code>org.xen.xapi.storage.&lt;sr type></code>&rdquo; queues for each
supported SR type. (This will change with SMAPIv3, which is accessed via
a SMAPIv2 plugin outside of xapi that translates between SMAPIv2 and
SMAPIv3.) Then, in
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml#L1531 target=_blank>Storage_access.create_sr</a>,
which is called
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/xapi_sr.ml#L326 target=_blank>during SR.create</a>,
and also
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/xapi_pbd.ml#L121 target=_blank>during PBD.plug</a>,
the relevant &ldquo;<code>org.xen.xapi.storage.&lt;sr type></code>&rdquo; queue needed for that
PBD is <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml#L1107 target=_blank>registered with Storage_mux in
Storage_access.bind</a>
for the SR of that PBD.<br>So basically what happens is that xapi registers itself as a SMAPIv2
server, and forwards incoming function calls to itself through
<code>message-switch</code>, using its <code>Storage_mux</code> module. These calls are
forwarded to xapi&rsquo;s <code>SMAPIv1</code> module doing SMAPIv2 -> SMAPIv1
translation.</p><h4 id=registration-of-the-various-storage-servers>Registration of the various storage servers</h4><div class="mermaid align-center">sequenceDiagram
participant q as message-switch
participant v1 as Storage_access.SMAPIv1
participant svr as Storage_mux.Server
Note over q, svr: xapi startup, "Starting SMAPIv1 proxies"
q ->> v1:org.xen.xapi.storage.sr_type_1
q ->> v1:org.xen.xapi.storage.sr_type_2
q ->> v1:org.xen.xapi.storage.sr_type_3
Note over q, svr: xapi startup, "Starting SM service"
q ->> svr:org.xen.xapi.storage
Note over q, svr: SR.create, PBD.plug
svr ->> q:org.xapi.storage.sr_type_2</div><h4 id=what-happens-when-a-smapiv2-function-is-called>What happens when a SMAPIv2 &ldquo;function&rdquo; is called</h4><div class="mermaid align-center">graph TD
call[SMAPIv2 call] --VDI.attach2--> org.xen.xapi.storage
subgraph message-switch
org.xen.xapi.storage
org.xen.xapi.storage.SR_type_x
end
org.xen.xapi.storage --VDI.attach2--> Storage_impl.Wrapper
subgraph xapi
subgraph Storage_mux.server
Storage_impl.Wrapper --> Storage_mux.mux
end
Storage_access.SMAPIv1
end
Storage_mux.mux --VDI.attach2--> org.xen.xapi.storage.SR_type_x
org.xen.xapi.storage.SR_type_x --VDI.attach2--> Storage_access.SMAPIv1
subgraph SMAPIv1
driver_x[SMAPIv1 driver for SR_type_x]
end
Storage_access.SMAPIv1 --vdi_attach--> driver_x</div><h3 id=interface-changes-backward-compatibility--sxm>Interface Changes, Backward Compatibility, & SXM</h3><p>During SXM, xapi calls SMAPIv2 functions on a remote xapi. Therefore it
is important to keep all those SMAPIv2 functions backward-compatible
that we call remotely (e.g. Remote.VDI.attach), otherwise SXM from an
older to a newer xapi will break.</p><h3 id=functionality-implemented-in-smapiv2-layers>Functionality implemented in SMAPIv2 layers</h3><p>The layer between SMAPIv2 and SMAPIv1 is much fatter than the one between
SMAPIv2 and SMAPIv3. The latter does not do much, apart from simple
translation. However, the former has large portions of code in its intermediate
layers, in addition to the basic SMAPIv2 &lt;-> SMAPIv1 translation in
<code>storage_access.ml</code>.</p><p>These are the three files in xapi that implement the SMAPIv2 storage interface,
from higher to lower level:</p><ul><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_impl.ml target=_blank>xen-api/ocaml/xapi/storage_impl.ml</a>:</li><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_mux.ml target=_blank>xen-api/ocaml/xapi/storage_mux.ml</a>:</li><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml target=_blank>xen-api/ocaml/xapi/storage_access.ml</a>:</li></ul><p>Functionality implemented by higher layers is not implemented by the layers below it.</p><h4 id=extra-functionality-in-storage_implml>Extra functionality in <code>storage_impl.ml</code></h4><p>In addition to its usual functions, <code>Storage_impl.Wrapper</code> also implements the
<code>UPDATES</code> and <code>TASK</code> SMAPIv2 APIs, without calling the wrapped module.</p><p>These are backed by the <code>Updates</code>, <code>Task_server</code>, and <code>Scheduler</code> modules from
xcp-idl, instantiated in xapi&rsquo;s <code>Storage_task</code> module. Migration code in
<code>Storage_mux</code> will interact with these to update task progress. There is also
an event loop in xapi that keeps calling <code>UPDATES.get</code> to keep the tasks in
xapi&rsquo;s database in sync with the storage manager&rsquo;s tasks.</p><p><code>Storage_impl.Wrapper</code> also implements the legacy <code>VDI.attach</code> call by simply
calling the newer <code>VDI.attach2</code> call in the same module. In general, this is a
good place to implement a compatibility layer for deprecated functionality
removed from other layers, because this is the first module that intercepts a
SMAPIv2 call.</p><h4 id=extra-functionality-in-storage_muxml>Extra functionality in <code>storage_mux.ml</code></h4><p><code>Storage_mux</code> implements storage motion (SXM): it implements the <code>DATA</code> and
<code>DATA.MIRROR</code> modules. Migration code will use the <code>Storage_task</code> module to run
the operations and update the task&rsquo;s progress.</p><p>It also implements the <code>Policy</code> module from the SMAPIv2 interface.</p><h2 id=smapiv3>SMAPIv3</h2><p><a href=https://xapi-project.github.io/xapi-storage/ target=_blank>SMAPIv3</a> has a slightly
different interface from SMAPIv2.The
<a href=https://github.com/xapi-project/xapi-storage-script target=_blank>xapi-storage-script</a>
daemon is a SMAPIv2 plugin separate from xapi that is doing the SMAPIv2
↔ SMAPIv3 translation. It keeps the plugins registered with xcp-idl
(their message-switch queues) up to date as their files appear or
disappear from the relevant directory.</p><h3 id=smapiv3-interface>SMAPIv3 Interface</h3><p>The SMAPIv3 interface is defined using an OCaml-based IDL from the
<a href=https://github.com/mirage/ocaml-rpc target=_blank>ocaml-rpc</a> library, and is in this
repo: <a href=https://github.com/xapi-project/xapi-storage target=_blank>https://github.com/xapi-project/xapi-storage</a></p><p>From this interface we generate</p><ul><li>OCaml RPC client bindings used in
<a href=https://github.com/xapi-project/xapi-storage-script target=_blank>xapi-storage-script</a></li><li>The <a href=https://xapi-project.github.io/xapi-storage target=_blank>SMAPIv3 API
reference</a></li><li>Python bindings, used by the SM scripts that implement the SMAPIv3
interface.<ul><li>These bindings are built by running &ldquo;<code>make</code>&rdquo; in the root
<a href=https://github.com/xapi-project/xapi-storage target=_blank>xapi-storage</a>,
and appear in the<code> _build/default/python/xapi/storage/api/v5</code>
directory.</li><li>On a XenServer host, they are stored in the
<code>/usr/lib/python3.6/site-packages/xapi/storage/api/v5/</code>
directory</li></ul></li></ul><h3 id=smapiv3-plugins>SMAPIv3 Plugins</h3><p>For <a href=https://xapi-project.github.io/xapi-storage/ target=_blank>SMAPIv3</a> we have
volume plugins to manipulate SRs and volumes (=VDIs) in them, and
datapath plugins for connecting to the volumes. Volume plugins tell us
which datapath plugins we can use with each volume, and what to pass to
the plugin. Both volume and datapath plugins implement some common
functionality: the SMAPIv3 <a href=https://xapi-project.github.io/xapi-storage/#plugin target=_blank>plugin
interface</a>.</p><h3 id=how-smapiv3-works>How SMAPIv3 works:</h3><p>The <code>xapi-storage-script</code> daemon detects volume and datapath plugins
stored in subdirectories of the
<code>/usr/libexec/xapi-storage-script/volume/</code> and
<code>/usr/libexec/xapi-storage-script/datapath/</code> directories, respectively.
When it finds a new datapath plugin, it adds the plugin to a lookup table and
uses it the next time that datapath is required. When it finds a new volume
plugin, it binds a new <a href=https://github.com/xapi-project/message-switch target=_blank>message-switch</a> queue named after the plugin&rsquo;s
subdirectory to a new server instance that uses these volume scripts.</p><p>To invoke a SMAPIv3 method, it executes a program named
<code>&lt;Interface name>.&lt;function name></code> in the plugin&rsquo;s directory, for
example
<code>/usr/libexec/xapi-storage-script/volume/org.xen.xapi.storage.gfs2/SR.ls</code>.
The inputs to each script can be passed as command-line arguments and
are type-checked using the generated Python bindings, and so are the
outputs. The URIs of the SRs that xapi-storage-script knows about are
stored in the <code>/var/run/nonpersistent/xapi-storage-script/state.db</code>
file, these URIs can be used on the command line when an sr argument is
expected.<code></code></p><h4 id=registration-of-the-various-smapiv3-plugins>Registration of the various SMAPIv3 plugins</h4><div class="mermaid align-center">sequenceDiagram
participant q as message-switch
participant v1 as (Storage_access.SMAPIv1)
participant svr as Storage_mux.Server
participant vol_dir as /../volume/
participant dp_dir as /../datapath/
participant script as xapi-storage-script
Note over script, vol_dir: xapi-storage-script startup
script ->> vol_dir: new subdir org.xen.xapi.storage.sr_type_4
q ->> script: org.xen.xapi.storage.sr_type_4
script ->> dp_dir: new subdir sr_type_4_dp
Note over q, svr: xapi startup, "Starting SMAPIv1 proxies"
q -->> v1:org.xen.xapi.storage.sr_type_1
q -->> v1:org.xen.xapi.storage.sr_type_2
q -->> v1:org.xen.xapi.storage.sr_type_3
Note over q, svr: xapi startup, "Starting SM service"
q ->> svr:org.xen.xapi.storage
Note over q, svr: SR.create, PBD.plug
svr ->> q:org.xapi.storage.sr_type_4</div><h4 id=what-happens-when-a-smapiv3-function-is-called>What happens when a SMAPIv3 &ldquo;function&rdquo; is called</h4><div class="mermaid align-center">graph TD
call[SMAPIv2 call] --VDI.attach2--> org.xen.xapi.storage
subgraph message-switch
org.xen.xapi.storage
org.xen.xapi.storage.SR_type_x
end
org.xen.xapi.storage --VDI.attach2--> Storage_impl.Wrapper
subgraph xapi
subgraph Storage_mux.server
Storage_impl.Wrapper --> Storage_mux.mux
end
Storage_access.SMAPIv1
end
Storage_mux.mux --VDI.attach2--> org.xen.xapi.storage.SR_type_x
org.xen.xapi.storage.SR_type_x -."VDI.attach2".-> Storage_access.SMAPIv1
subgraph SMAPIv1
driver_x[SMAPIv1 driver for SR_type_x]
end
Storage_access.SMAPIv1 -.vdi_attach.-> driver_x
subgraph SMAPIv3
xapi-storage-script --Datapath.attach--> v3_dp_plugin_x
subgraph SMAPIv3 plugins
v3_vol_plugin_x[volume plugin for SR_type_x]
v3_dp_plugin_x[datapath plugin for SR_type_x]
end
end
org.xen.xapi.storage.SR_type_x --VDI.attach2-->xapi-storage-script</div><h2 id=error-reporting>Error reporting</h2><p>In our SMAPIv1 OCaml &ldquo;bindings&rdquo; in xapi
(<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/sm_exec.ml target=_blank>xen-api/ocaml/xapi/sm_exec.ml</a>),
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/sm_exec.ml#L199 target=_blank>when we inspect the error codes returned from a call to
SM</a>,
we translate some of the SMAPIv1/SM error codes to XenAPI errors, and
for others, we just <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/sm_exec.ml#L214 target=_blank>construct an error
code</a>
of the form <code>SR_BACKEND_FAILURE_&lt;SM error number></code>.</p><p>The file
<a href=https://github.com/xapi-project/xcp-idl/blob/v1.62.0/storage/storage_interface.ml#L362 target=_blank>xcp-idl/storage/storage_interface.ml</a>
defines a number of SMAPIv2 errors, ultimately all errors from the various
SMAPIv2 storage servers in xapi will be returned as one of these. Most of the
errors aren&rsquo;t converted into a specific exception in <code>Storage_interface</code>, but
are simply wrapped with <code>Storage_interface.Backend_error</code>.</p><p>The
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml#L29 target=_blank>Storage_access.transform_storage_exn</a>
function is used by the client code in xapi to translate the SMAPIv2
errors into XenAPI errors again, this unwraps the errors wrapped with
<code>Storage_interface.Backend_error</code>.</p><h2 id=message-forwarding>Message Forwarding</h2><p>In the message forwarding layer, first we check the validity of VDI
operations using <code>mark_vdi</code> and <code>mark_sr</code>. These first check that the
operation is valid operations,
using <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/xapi_vdi.ml#L57 target=_blank>Xapi_vdi.check_operation_error</a>,
for <code>mark_vdi</code>, which also inspects the current operations of the VDI,
and then, if the operation is valid, it is added to the VDI&rsquo;s current
operations, and update_allowed_operations is called. Then we forward
the VDI operation to a suitable host that has a PBD plugged for the
VDI&rsquo;s SR.</p><h3 id=checking-that-the-sr-is-attached>Checking that the SR is attached</h3><p>For the VDI operations, we check at two different places whether the SR
is attached: first, at the Xapi level, <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/xapi_vdi.ml#L98 target=_blank>in
Xapi_vdi.check_operation_error</a>,
for the resize operation, and then, at the SMAPIv1 level, in
<code>Sm.assert_pbd_is_plugged</code>. <code>Sm.assert_pbd_is_plugged</code> performs the
same checks, plus it checks that the PBD is attached to the localhost,
unlike Xapi_vdi.check_operation_error. This behaviour is correct,
because <code>Xapi_vdi.check_operation_error</code> is called from the message
forwarding layer, which forwards the call to a host that has the SR
attached.</p><h2 id=vdi-identifiers-and-storage-motion>VDI Identifiers and Storage Motion</h2><ul><li>VDI &ldquo;location&rdquo;: this is the VDI identifier used by the SM backend.
It is usually the UUID of the VDI, but for ISO SRs it is the name of
the ISO.</li><li>VDI &ldquo;content_id&rdquo;: this is used for storage motion, to reduce the
amount of data copied. When we copy over a VDI, the content_id will
initially be the same. However, when we attach a VDI as read-write,
and then detach it, then we will blank its content_id (set it to a
random UUID), because we may have written to it, so the content
could be different. .</li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of XAPI's Storage Layers</h1><article class=default><header class=headline></header><h1 id=storage-migration>Storage migration</h1><h2 id=overview>Overview</h2><div class="mermaid align-left">sequenceDiagram
participant local_tapdisk as local tapdisk
participant local_smapiv2 as local SMAPIv2
participant xapi
participant remote_xapi as remote xapi
participant remote_smapiv2 as remote SMAPIv2 (might redirect)
participant remote_tapdisk as remote tapdisk
Note over xapi: Sort VDIs increasingly by size and then age
loop VM's & snapshots' VDIs & suspend images
xapi->>remote_xapi: plug dest SR to dest host and pool master
alt VDI is not mirrored
Note over xapi: We don't mirror RO VDIs & VDIs of snapshots
xapi->>local_smapiv2: DATA.copy remote_sm_url
activate local_smapiv2
local_smapiv2-->>local_smapiv2: SR.scan
local_smapiv2-->>local_smapiv2: VDI.similar_content
local_smapiv2-->>remote_smapiv2: SR.scan
Note over local_smapiv2: Find nearest smaller remote VDI remote_base, if any
alt remote_base
local_smapiv2-->>remote_smapiv2: VDI.clone
local_smapiv2-->>remote_smapiv2: VDI.resize
else no remote_base
local_smapiv2-->>remote_smapiv2: VDI.create
end
Note over local_smapiv2: call copy'
activate local_smapiv2
local_smapiv2-->>remote_smapiv2: SR.list
local_smapiv2-->>remote_smapiv2: SR.scan
Note over local_smapiv2: create new datapaths remote_dp, base_dp, leaf_dp
Note over local_smapiv2: find local base_vdi with same content_id as dest, if any
local_smapiv2-->>remote_smapiv2: VDI.attach2 remote_dp dest
local_smapiv2-->>remote_smapiv2: VDI.activate remote_dp dest
opt base_vdi
local_smapiv2-->>local_smapiv2: VDI.attach2 base_dp base_vdi
local_smapiv2-->>local_smapiv2: VDI.activate base_dp base_vdi
end
local_smapiv2-->>local_smapiv2: VDI.attach2 leaf_dp vdi
local_smapiv2-->>local_smapiv2: VDI.activate leaf_dp vdi
local_smapiv2-->>remote_xapi: sparse_dd base_vdi vdi dest [NBD URI for dest & remote_dp]
Note over remote_xapi: HTTP handler verifies credentials
remote_xapi-->>remote_tapdisk: then passes connection to tapdisk's NBD server
local_smapiv2-->>local_smapiv2: VDI.deactivate leaf_dp vdi
local_smapiv2-->>local_smapiv2: VDI.detach leaf_dp vdi
opt base_vdi
local_smapiv2-->>local_smapiv2: VDI.deactivate base_dp base_vdi
local_smapiv2-->>local_smapiv2: VDI.detach base_dp base_vdi
end
local_smapiv2-->>remote_smapiv2: DP.destroy remote_dp
deactivate local_smapiv2
local_smapiv2-->>remote_smapiv2: VDI.snapshot remote_copy
local_smapiv2-->>remote_smapiv2: VDI.destroy remote_copy
local_smapiv2->>xapi: task(snapshot)
deactivate local_smapiv2
else VDI is mirrored
Note over xapi: We mirror RW VDIs of the VM
Note over xapi: create new datapath dp
xapi->>local_smapiv2: VDI.attach2 dp
xapi->>local_smapiv2: VDI.activate dp
xapi->>local_smapiv2: DATA.MIRROR.start dp remote_sm_url
activate local_smapiv2
Note over local_smapiv2: copy disk data & mirror local writes
local_smapiv2-->>local_smapiv2: SR.scan
local_smapiv2-->>local_smapiv2: VDI.similar_content
local_smapiv2-->>remote_smapiv2: DATA.MIRROR.receive_start similars
activate remote_smapiv2
remote_smapiv2-->>local_smapiv2: mirror_vdi,mirror_dp,copy_diffs_from,copy_diffs_to,dummy_vdi
deactivate remote_smapiv2
local_smapiv2-->>local_smapiv2: DP.attach_info dp
local_smapiv2-->>remote_xapi: connect to [NBD URI for mirror_vdi & mirror_dp]
Note over remote_xapi: HTTP handler verifies credentials
remote_xapi-->>remote_tapdisk: then passes connection to tapdisk's NBD server
local_smapiv2-->>local_tapdisk: pass socket & dp to tapdisk of dp
local_smapiv2-->>local_smapiv2: VDI.snapshot local_vdi [mirror:dp]
local_smapiv2-->>local_tapdisk: [Python] unpause disk, pass dp
local_tapdisk-->>remote_tapdisk: mirror new writes via NBD to socket
Note over local_smapiv2: call copy' snapshot copy_diffs_to
local_smapiv2-->>remote_smapiv2: VDI.compose copy_diffs_to mirror_vdi
local_smapiv2-->>remote_smapiv2: VDI.remove_from_sm_config mirror_vdi base_mirror
local_smapiv2-->>remote_smapiv2: VDI.destroy dummy_vdi
local_smapiv2-->>local_smapiv2: VDI.destroy snapshot
local_smapiv2->>xapi: task(mirror ID)
deactivate local_smapiv2
xapi->>local_smapiv2: DATA.MIRROR.stat
activate local_smapiv2
local_smapiv2->>xapi: dest_vdi
deactivate local_smapiv2
end
loop until task finished
xapi->>local_smapiv2: UPDATES.get
xapi->>local_smapiv2: TASK.stat
end
xapi->>local_smapiv2: TASK.stat
xapi->>local_smapiv2: TASK.destroy
end
opt for snapshot VDIs
xapi->>local_smapiv2: SR.update_snapshot_info_src remote_sm_url
activate local_smapiv2
local_smapiv2-->>remote_smapiv2: SR.update_snapshot_info_dest
deactivate local_smapiv2
end
Note over xapi: ...
Note over xapi: reserve resources for the new VM in dest host
loop all VDIs
opt VDI is mirrored
xapi->>local_smapiv2: DP.destroy dp
end
end
opt post_detach_hook
opt active local mirror
local_smapiv2-->>remote_smapiv2: DATA.MIRROR.receive_finalize [mirror ID]
Note over remote_smapiv2: destroy mirror dp
end
end
Note over xapi: memory image migration by xenopsd
Note over xapi: destroy the VM record</div><h3 id=receiving-sxm>Receiving SXM</h3><p>These are the remote calls in the above diagram sent from the remote host to
the receiving end of storage motion:</p><ul><li>Remote SMAPIv2 -> local SMAPIv2 RPC calls:<ul><li><code>SR.list</code></li><li><code>SR.scan</code></li><li><code>SR.update_snapshot_info_dest</code></li><li><code>VDI.attach2</code></li><li><code>VDI.activate</code></li><li><code>VDI.snapshot</code></li><li><code>VDI.destroy</code></li><li>For copying:<ul><li>For copying from base:<ul><li><code>VDI.clone</code></li><li><code>VDI.resize</code></li></ul></li><li>For copying without base:<ul><li><code>VDI.create</code></li></ul></li></ul></li><li>For mirroring:<ul><li><code>DATA.MIRROR.receive_start</code></li><li><code>VDI.compose</code></li><li><code>VDI.remove_from_sm_config</code></li><li><code>DATA.MIRROR.receive_finalize</code></li></ul></li></ul></li><li>HTTP requests to xapi:<ul><li>Connecting to NBD URI via xapi&rsquo;s HTTP handler</li></ul></li></ul><hr><p>This is how xapi coordinates storage migration. We&rsquo;ll do it as a code walkthrough through the two layers: xapi and storage-in-xapi (SMAPIv2).</p><h2 id=xapi-code>Xapi code</h2><p>The entry point is in <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/xapi_vm_migrate.ml#L786 target=_blank>xapi_vm_migration.ml</a></p><p>The function takes several arguments:</p><ul><li>a vm reference (<code>vm</code>)</li><li>a dictionary of <code>(string * string)</code> key-value pairs about the destination (<code>dest)</code>. This is the result of a previous call to the destination pool, <code>Host.migrate_receive</code></li><li><code>live</code>, a boolean of whether we should live-migrate or suspend-resume,</li><li><code>vdi_map</code>, a mapping of VDI references to destination SR references,</li><li><code>vif_map</code>, a mapping of VIF references to destination network references,</li><li><code>vgpu_map</code>, similar for VGPUs</li><li><code>options</code>, another dictionary of options</li></ul><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> migrate_send&#39;  <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>live <span style=color:#f92672>~</span>vdi_map <span style=color:#f92672>~</span>vif_map <span style=color:#f92672>~</span>vgpu_map <span style=color:#f92672>~</span>options <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  SMPERF.debug <span style=color:#e6db74>&#34;vm.migrate_send called vm:%s&#34;</span> <span style=color:#f92672>(</span>Db.VM.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Xapi_xenops</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> localhost <span style=color:#f92672>=</span> Helpers.get_localhost <span style=color:#f92672>~__</span>context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote <span style=color:#f92672>=</span> remote_of_dest dest <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Copy mode means we don&#39;t destroy the VM on the source host. We also don&#39;t
</span></span></span><span style=display:flex><span><span style=color:#75715e>     	   copy over the RRDs/messages *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> copy <span style=color:#f92672>=</span> <span style=color:#66d9ef>try</span> bool_of_string <span style=color:#f92672>(</span>List.assoc <span style=color:#e6db74>&#34;copy&#34;</span> options<span style=color:#f92672>)</span> <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> false <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>It begins by getting the local host reference, deciding whether we&rsquo;re copying or moving, and converting the input <code>dest</code> parameter from an untyped string association list to a typed record, <code>remote</code>, which is declared further up the file:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> remote <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  rpc <span style=color:#f92672>:</span> Rpc.call <span style=color:#f92672>-&gt;</span> Rpc.response<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  session <span style=color:#f92672>:</span> API.ref_session<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  sm_url <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  xenops_url <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  master_url <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  remote_ip <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span> <span style=color:#75715e>(* IP address *)</span>
</span></span><span style=display:flex><span>  remote_master_ip <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span> <span style=color:#75715e>(* IP address *)</span>
</span></span><span style=display:flex><span>  dest_host <span style=color:#f92672>:</span> API.ref_host<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p>this contains:</p><ul><li>A function, <code>rpc</code>, for calling XenAPI RPCs on the destination</li><li>A <code>session</code> valid on the destination</li><li>A <code>sm_url</code> on which SMAPIv2 APIs can be called on the destination</li><li>A <code>master_url</code> on which XenAPI commands can be called (not currently used)</li><li>The IP address, <code>remote_ip</code>, of the destination host</li><li>The IP address, <code>remote_master_ip</code>, of the master of the destination pool</li></ul><p>Next, we determine which VDIs to copy:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* The first thing to do is to create mirrors of all the disks on the remote.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     We look through the VM&#39;s VBDs and all of those of the snapshots. We then
</span></span></span><span style=display:flex><span><span style=color:#75715e>     compile a list of all of the associated VDIs, whether we mirror them or not
</span></span></span><span style=display:flex><span><span style=color:#75715e>     (mirroring means we believe the VDI to be active and new writes should be
</span></span></span><span style=display:flex><span><span style=color:#75715e>     mirrored to the destination - otherwise we just copy it)
</span></span></span><span style=display:flex><span><span style=color:#75715e>     We look at the VDIs of the VM, the VDIs of all of the snapshots, and any
</span></span></span><span style=display:flex><span><span style=color:#75715e>     suspend-image VDIs. *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vm_uuid <span style=color:#f92672>=</span> Db.VM.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vbds <span style=color:#f92672>=</span> Db.VM.get_VBDs <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vifs <span style=color:#f92672>=</span> Db.VM.get_VIFs <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> snapshots <span style=color:#f92672>=</span> Db.VM.get_snapshots <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vm_and_snapshots <span style=color:#f92672>=</span> vm <span style=color:#f92672>::</span> snapshots <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> snapshots_vbds <span style=color:#f92672>=</span> List.flatten <span style=color:#f92672>(</span>List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span> Db.VM.get_VBDs <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>)</span> snapshots<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> snapshot_vifs <span style=color:#f92672>=</span> List.flatten <span style=color:#f92672>(</span>List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span> Db.VM.get_VIFs <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>)</span> snapshots<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>we now decide whether we&rsquo;re intra-pool or not, and if we&rsquo;re intra-pool whether we&rsquo;re migrating onto the same host (localhost migrate). Intra-pool is decided by trying to do a lookup of our current host uuid on the destination pool.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> is_intra_pool <span style=color:#f92672>=</span> <span style=color:#66d9ef>try</span> ignore<span style=color:#f92672>(</span>Db.Host.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>);</span> true <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> false <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> is_same_host <span style=color:#f92672>=</span> is_intra_pool <span style=color:#f92672>&amp;&amp;</span> remote<span style=color:#f92672>.</span>dest_host <span style=color:#f92672>==</span> localhost <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> copy <span style=color:#f92672>&amp;&amp;</span> is_intra_pool <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.operation_not_allowed<span style=color:#f92672>,</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;Copy mode is disallowed on intra pool storage migration, try efficient alternatives e.g. VM.copy/clone.&#34;</span><span style=color:#f92672>]));</span></span></span></code></pre></div><p>Having got all of the VBDs of the VM, we now need to find the associated VDIs, filtering out empty CDs, and decide whether we&rsquo;re going to copy them or mirror them - read-only VDIs can be copied but RW VDIs must be mirrored.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vms_vdis <span style=color:#f92672>=</span> List.filter_map <span style=color:#f92672>(</span>vdi_filter <span style=color:#f92672>__</span>context true<span style=color:#f92672>)</span> vbds <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>where <code>vdi_filter</code> is defined earler:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* We ignore empty or CD VBDs - nothing to do there. Possible redundancy here:
</span></span></span><span style=display:flex><span><span style=color:#75715e>   I don&#39;t think any VBDs other than CD VBDs can be &#39;empty&#39; *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> vdi_filter <span style=color:#f92672>__</span>context allow_mirror vbd <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> Db.VBD.get_empty <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#f92672>||</span> Db.VBD.get_type <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#f92672>=</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>CD</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>then</span> <span style=color:#a6e22e>None</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> do_mirror <span style=color:#f92672>=</span> allow_mirror <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>(</span>Db.VBD.get_mode <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#f92672>=</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>RW</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vm <span style=color:#f92672>=</span> Db.VBD.get_VM <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vdi <span style=color:#f92672>=</span> Db.VBD.get_VDI <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span>get_vdi_mirror <span style=color:#f92672>__</span>context vm vdi do_mirror<span style=color:#f92672>)</span></span></span></code></pre></div><p>This in turn calls <code>get_vdi_mirror</code> which gathers together some important info:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> get_vdi_mirror <span style=color:#f92672>__</span>context vm vdi do_mirror <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> snapshot_of <span style=color:#f92672>=</span> Db.VDI.get_snapshot_of <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> size <span style=color:#f92672>=</span> Db.VDI.get_virtual_size <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> xenops_locator <span style=color:#f92672>=</span> Xapi_xenops.xenops_vdi_locator <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> location <span style=color:#f92672>=</span> Db.VDI.get_location <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dp <span style=color:#f92672>=</span> Storage_access.presentative_datapath_of_vbd <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> sr <span style=color:#f92672>=</span> Db.SR.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:(</span>Db.VDI.get_SR <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>{</span>vdi<span style=color:#f92672>;</span> dp<span style=color:#f92672>;</span> location<span style=color:#f92672>;</span> sr<span style=color:#f92672>;</span> xenops_locator<span style=color:#f92672>;</span> size<span style=color:#f92672>;</span> snapshot_of<span style=color:#f92672>;</span> do_mirror<span style=color:#f92672>}</span></span></span></code></pre></div><p>The record is helpfully commented above:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> vdi_mirror <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  vdi <span style=color:#f92672>:</span> <span style=color:#f92672>[</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>VDI</span> <span style=color:#f92672>]</span> API.Ref.t<span style=color:#f92672>;</span>           <span style=color:#75715e>(* The API reference of the local VDI *)</span>
</span></span><span style=display:flex><span>  dp <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>                        <span style=color:#75715e>(* The datapath the VDI will be using if the VM is running *)</span>
</span></span><span style=display:flex><span>  location <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>                  <span style=color:#75715e>(* The location of the VDI in the current SR *)</span>
</span></span><span style=display:flex><span>  sr <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>                        <span style=color:#75715e>(* The VDI&#39;s current SR uuid *)</span>
</span></span><span style=display:flex><span>  xenops_locator <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>            <span style=color:#75715e>(* The &#39;locator&#39; xenops uses to refer to the VDI on the current host *)</span>
</span></span><span style=display:flex><span>  size <span style=color:#f92672>:</span> Int64.t<span style=color:#f92672>;</span>                     <span style=color:#75715e>(* Size of the VDI *)</span>
</span></span><span style=display:flex><span>  snapshot_of <span style=color:#f92672>:</span> <span style=color:#f92672>[</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>VDI</span> <span style=color:#f92672>]</span> API.Ref.t<span style=color:#f92672>;</span>   <span style=color:#75715e>(* API&#39;s snapshot_of reference *)</span>
</span></span><span style=display:flex><span>  do_mirror <span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span><span style=color:#f92672>;</span>                   <span style=color:#75715e>(* Whether we should mirror or just copy the VDI *)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p><code>xenops_locator</code> is <code>&lt;sr uuid>/&lt;vdi uuid></code>, and <code>dp</code> is <code>vbd/&lt;domid>/&lt;device></code> if the VM is running and <code>vbd/&lt;vm_uuid>/&lt;vdi_uuid></code> if not.</p><p>So now we have a list of these records for all VDIs attached to the VM. For these we check explicitly that they&rsquo;re all defined in the <code>vdi_map</code>, the mapping of VDI references to their destination SR references.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  check_vdi_map <span style=color:#f92672>~__</span>context vms_vdis vdi_map<span style=color:#f92672>;</span></span></span></code></pre></div><p>We then figure out the VIF map:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span> <span style=color:#66d9ef>let</span> vif_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> is_intra_pool <span style=color:#66d9ef>then</span> vif_map
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> infer_vif_map <span style=color:#f92672>~__</span>context <span style=color:#f92672>(</span>vifs <span style=color:#f92672>@</span> snapshot_vifs<span style=color:#f92672>)</span> vif_map
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>More sanity checks: We can&rsquo;t do a storage migration if any of the VDIs is a reset-on-boot one - since the state will be lost on the destination when it&rsquo;s attached:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* Block SXM when VM has a VDI with on_boot=reset *)</span>
</span></span><span style=display:flex><span>  List.<span style=color:#f92672>(</span>iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vconf <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> vdi <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>Db.VDI.get_on_boot <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#f92672>==`</span>reset<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.vdi_on_boot_mode_incompatible_with_operation<span style=color:#f92672>,</span> <span style=color:#f92672>[</span>Ref.string_of vdi<span style=color:#f92672>])))</span> vms_vdis<span style=color:#f92672>)</span> <span style=color:#f92672>;</span></span></span></code></pre></div><p>We now consider all of the VDIs associated with the snapshots. As for the VM&rsquo;s VBDs above, we end up with a <code>vdi_mirror</code> list. Note we pass <code>false</code> to the <code>allow_mirror</code> parameter of the <code>get_vdi_mirror</code> function as none of these snapshot VDIs will ever require mirrorring.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> snapshots_vdis <span style=color:#f92672>=</span> List.filter_map <span style=color:#f92672>(</span>vdi_filter <span style=color:#f92672>__</span>context false<span style=color:#f92672>)</span></span></span></code></pre></div><p>Finally we get all of the suspend-image VDIs from all snapshots as well as the actual VM, since it might be suspended itself:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>snapshots_vbds <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> suspends_vdis <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    List.fold_left
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> acc vm <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span> Db.VM.get_power_state <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#f92672>=</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>Suspended</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>let</span> vdi <span style=color:#f92672>=</span> Db.VM.get_suspend_VDI <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>let</span> sr <span style=color:#f92672>=</span> Db.VDI.get_SR <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>if</span> is_intra_pool <span style=color:#f92672>&amp;&amp;</span> Helpers.host_has_pbd_for_sr <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>host<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>dest_host <span style=color:#f92672>~</span>sr
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>then</span> acc
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>else</span> <span style=color:#f92672>(</span>get_vdi_mirror <span style=color:#f92672>__</span>context vm vdi false<span style=color:#f92672>)::</span> acc
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>else</span> acc<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      [] vm_and_snapshots <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Sanity check that we can see all of the suspend-image VDIs on this host:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span> <span style=color:#75715e>(* Double check that all of the suspend VDIs are all visible on the source *)</span>
</span></span><span style=display:flex><span>  List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vdi_mirror <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> sr <span style=color:#f92672>=</span> Db.VDI.get_SR <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi_mirror<span style=color:#f92672>.</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not <span style=color:#f92672>(</span>Helpers.host_has_pbd_for_sr <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>host<span style=color:#f92672>:</span>localhost <span style=color:#f92672>~</span>sr<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span> <span style=color:#f92672>(</span>Api_errors.suspend_image_not_accessible<span style=color:#f92672>,</span> <span style=color:#f92672>[</span> Ref.string_of vdi_mirror<span style=color:#f92672>.</span>vdi <span style=color:#f92672>])))</span> suspends_vdis<span style=color:#f92672>;</span></span></span></code></pre></div><p>Next is a fairly complex piece that determines the destination SR for all of these VDIs. We don&rsquo;t require API uses to decide destinations for all of the VDIs on snapshots and hence we have to make some decisions here:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_pool <span style=color:#f92672>=</span> List.hd <span style=color:#f92672>(</span>XenAPI.Pool.get_all remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> default_sr_ref <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    XenAPI.Pool.get_default_SR remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_pool <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> suspend_sr_ref <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pool_suspend_SR <span style=color:#f92672>=</span> XenAPI.Pool.get_suspend_image_SR remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_pool
</span></span><span style=display:flex><span>    <span style=color:#f92672>and</span> host_suspend_SR <span style=color:#f92672>=</span> XenAPI.Host.get_suspend_image_sr remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session remote<span style=color:#f92672>.</span>dest_host <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pool_suspend_SR <span style=color:#f92672>&lt;&gt;</span> Ref.null <span style=color:#66d9ef>then</span> pool_suspend_SR <span style=color:#66d9ef>else</span> host_suspend_SR <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Resolve placement of unspecified VDIs here - unspecified VDIs that
</span></span></span><span style=display:flex><span><span style=color:#75715e>            are &#39;snapshot_of&#39; a specified VDI go to the same place. suspend VDIs
</span></span></span><span style=display:flex><span><span style=color:#75715e>            that are unspecified go to the suspend_sr_ref defined above *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> extra_vdis <span style=color:#f92672>=</span> suspends_vdis <span style=color:#f92672>@</span> snapshots_vdis <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> extra_vdi_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    List.map
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vconf <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>let</span> dest_sr_ref <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>let</span> is_mapped <span style=color:#f92672>=</span> List.mem_assoc vconf<span style=color:#f92672>.</span>vdi vdi_map
</span></span><span style=display:flex><span>           <span style=color:#f92672>and</span> snapshot_of_is_mapped <span style=color:#f92672>=</span> List.mem_assoc vconf<span style=color:#f92672>.</span>snapshot_of vdi_map
</span></span><span style=display:flex><span>           <span style=color:#f92672>and</span> is_suspend_vdi <span style=color:#f92672>=</span> List.mem vconf suspends_vdis
</span></span><span style=display:flex><span>           <span style=color:#f92672>and</span> remote_has_suspend_sr <span style=color:#f92672>=</span> suspend_sr_ref <span style=color:#f92672>&lt;&gt;</span> Ref.null
</span></span><span style=display:flex><span>           <span style=color:#f92672>and</span> remote_has_default_sr <span style=color:#f92672>=</span> default_sr_ref <span style=color:#f92672>&lt;&gt;</span> Ref.null <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>let</span> log_prefix <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>             Printf.sprintf <span style=color:#e6db74>&#34;Resolving VDI-&gt;SR map for VDI %s:&#34;</span> <span style=color:#f92672>(</span>Db.VDI.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>if</span> is_mapped <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s VDI has been specified in the map&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             List.assoc vconf<span style=color:#f92672>.</span>vdi vdi_map
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> snapshot_of_is_mapped <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s Snapshot VDI has entry in map for it&#39;s snapshot_of link&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             List.assoc vconf<span style=color:#f92672>.</span>snapshot_of vdi_map
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> is_suspend_vdi <span style=color:#f92672>&amp;&amp;</span> remote_has_suspend_sr <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s Mapping suspend VDI to remote suspend SR&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             suspend_sr_ref
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> is_suspend_vdi <span style=color:#f92672>&amp;&amp;</span> remote_has_default_sr <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s Remote suspend SR not set, mapping suspend VDI to remote default SR&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             default_sr_ref
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> remote_has_default_sr <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s Mapping unspecified VDI to remote default SR&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             default_sr_ref
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             error <span style=color:#e6db74>&#34;%s VDI not in VDI-&gt;SR map and no remote default SR is set&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.vdi_not_in_map<span style=color:#f92672>,</span> <span style=color:#f92672>[</span> Ref.string_of vconf<span style=color:#f92672>.</span>vdi <span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>         <span style=color:#f92672>(</span>vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>,</span> dest_sr_ref<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>      extra_vdis <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>At the end of this we&rsquo;ve got all of the VDIs that need to be copied and destinations for all of them:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdi_map <span style=color:#f92672>=</span> vdi_map <span style=color:#f92672>@</span> extra_vdi_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> all_vdis <span style=color:#f92672>=</span> vms_vdis <span style=color:#f92672>@</span> extra_vdis <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* The vdi_map should be complete at this point - it should include all the
</span></span></span><span style=display:flex><span><span style=color:#75715e>     VDIs in the all_vdis list. *)</span></span></span></code></pre></div><p>Now we gather some final information together:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  assert_no_cbt_enabled_vdi_migrated <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vdi_map<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dbg <span style=color:#f92672>=</span> Context.string_of_task <span style=color:#f92672>__</span>context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Xapi_xenops_queue</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> queue_name <span style=color:#f92672>=</span> queue_of_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>XenopsAPI</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>val</span> make_client queue_name <span style=color:#f92672>:</span> <span style=color:#a6e22e>XENOPS</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_vdis <span style=color:#f92672>=</span> ref [] <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> ha_always_run_reset <span style=color:#f92672>=</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> Db.VM.get_ha_always_run <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> cd_vbds <span style=color:#f92672>=</span> find_cds_to_eject <span style=color:#f92672>__</span>context vdi_map vbds <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  eject_cds <span style=color:#f92672>__</span>context cd_vbds<span style=color:#f92672>;</span></span></span></code></pre></div><p>check there&rsquo;s no CBT (we can&rsquo;t currently migrate the CBT metadata), make our client to talk to Xenopsd, make a mutable list of remote VDIs (which I think is redundant right now), decide whether we need to do anything for HA (we disable HA protection for this VM on the destination until it&rsquo;s fully migrated) and eject any CDs from the VM.</p><p>Up until now this has mostly been gathering info (aside from the ejecting CDs bit), but now we&rsquo;ll start to do some actions, so we begin a <code>try-catch</code> block:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>try</span></span></span></code></pre></div><p>but we&rsquo;ve still got a bit of thinking to do: we sort the VDIs to copy based on age/size:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#75715e>(* Sort VDIs by size in principle and then age secondly. This gives better
</span></span></span><span style=display:flex><span><span style=color:#75715e>       chances that similar but smaller VDIs would arrive comparatively
</span></span></span><span style=display:flex><span><span style=color:#75715e>       earlier, which can serve as base for incremental copying the larger
</span></span></span><span style=display:flex><span><span style=color:#75715e>       ones. *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> compare_fun v1 v2 <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> Int64.compare v1<span style=color:#f92672>.</span>size v2<span style=color:#f92672>.</span>size <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> r <span style=color:#f92672>=</span> 0 <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> t1 <span style=color:#f92672>=</span> Date.to_unix_time <span style=color:#f92672>(</span>Db.VDI.get_snapshot_time <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>v1<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> t2 <span style=color:#f92672>=</span> Date.to_unix_time <span style=color:#f92672>(</span>Db.VDI.get_snapshot_time <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>v2<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        compare t1 t2
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> r <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> all_vdis <span style=color:#f92672>=</span> all_vdis <span style=color:#f92672>|&gt;</span> List.sort compare_fun <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> total_size <span style=color:#f92672>=</span> List.fold_left <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> acc vconf <span style=color:#f92672>-&gt;</span> Int64.add acc vconf<span style=color:#f92672>.</span>size<span style=color:#f92672>)</span> 0L all_vdis <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> so_far <span style=color:#f92672>=</span> ref 0L <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>OK, let&rsquo;s copy/mirror:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    with_many <span style=color:#f92672>(</span>vdi_copy_fun <span style=color:#f92672>__</span>context dbg vdi_map remote is_intra_pool remote_vdis so_far total_size copy<span style=color:#f92672>)</span> all_vdis <span style=color:#f92672>@@</span> <span style=color:#66d9ef>fun</span> all_map <span style=color:#f92672>-&gt;</span></span></span></code></pre></div><p>The copy functions are written such that they take continuations. This it to make the error handling simpler - each individual component function can perform its setup and execute the continuation. In the event of an exception coming from the continuation it can then unroll its bit of state and rethrow the exception for the next layer to handle.</p><p><code>with_many</code> is a simple helper function for nesting invocations of functions that take continuations. It has the delightful type:</p><div class="wrap-code highlight"><pre tabindex=0><code>(&#39;a -&gt; (&#39;b -&gt; &#39;c) -&gt; &#39;c) -&gt; &#39;a list -&gt; (&#39;b list -&gt; &#39;c) -&gt; &#39;c</code></pre></div><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* Helper function to apply a &#39;with_x&#39; function to a list *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> with_many withfn many fn <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> inner l acc <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> l <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> [] <span style=color:#f92672>-&gt;</span> fn acc
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> x<span style=color:#f92672>::</span>xs <span style=color:#f92672>-&gt;</span> withfn x <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> y <span style=color:#f92672>-&gt;</span> inner xs <span style=color:#f92672>(</span>y<span style=color:#f92672>::</span>acc<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span> inner many []</span></span></code></pre></div><p>As an example of its operation, imagine our withfn is as follows:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> withfn x c <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  Printf.printf <span style=color:#e6db74>&#34;Starting withfn: x=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> x<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    c <span style=color:#f92672>(</span>string_of_int x<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    Printf.printf <span style=color:#e6db74>&#34;Handling exception for x=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> x<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> e<span style=color:#f92672>;;</span></span></span></code></pre></div><p>applying this gives the output:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>utop <span style=color:#f92672>#</span> with_many withfn <span style=color:#f92672>[</span>1<span style=color:#f92672>;</span>2<span style=color:#f92672>;</span>3<span style=color:#f92672>;</span>4<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>String.concat <span style=color:#e6db74>&#34;,&#34;</span><span style=color:#f92672>);;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>1
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>2
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>3
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>4
</span></span><span style=display:flex><span><span style=color:#f92672>-</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;4,3,2,1&#34;</span></span></span></code></pre></div><p>whereas raising an exception in the continutation results in the following:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>utop <span style=color:#f92672>#</span> with_many with_fn <span style=color:#f92672>[</span>1<span style=color:#f92672>;</span>2<span style=color:#f92672>;</span>3<span style=color:#f92672>;</span>4<span style=color:#f92672>]</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#e6db74>&#34;error&#34;</span><span style=color:#f92672>);;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>1
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>2
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>3
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>4
</span></span><span style=display:flex><span><span style=color:#a6e22e>Handling</span> <span style=color:#66d9ef>exception</span> <span style=color:#66d9ef>for</span> x<span style=color:#f92672>=</span>4
</span></span><span style=display:flex><span><span style=color:#a6e22e>Handling</span> <span style=color:#66d9ef>exception</span> <span style=color:#66d9ef>for</span> x<span style=color:#f92672>=</span>3
</span></span><span style=display:flex><span><span style=color:#a6e22e>Handling</span> <span style=color:#66d9ef>exception</span> <span style=color:#66d9ef>for</span> x<span style=color:#f92672>=</span>2
</span></span><span style=display:flex><span><span style=color:#a6e22e>Handling</span> <span style=color:#66d9ef>exception</span> <span style=color:#66d9ef>for</span> x<span style=color:#f92672>=</span>1
</span></span><span style=display:flex><span><span style=color:#a6e22e>Exception</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Failure</span> <span style=color:#e6db74>&#34;error&#34;</span><span style=color:#f92672>.</span></span></span></code></pre></div><p>All the real action is in <code>vdi_copy_fun</code>, which copies or mirrors a single VDI:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> vdi_copy_fun <span style=color:#f92672>__</span>context dbg vdi_map remote is_intra_pool remote_vdis so_far total_size copy vconf continuation <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Storage_access</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_sr_ref <span style=color:#f92672>=</span> List.assoc vconf<span style=color:#f92672>.</span>vdi vdi_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_sr_uuid <span style=color:#f92672>=</span> XenAPI.SR.get_uuid remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_sr_ref <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Plug the destination shared SR into destination host and pool master if unplugged.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     Plug the local SR into destination host only if unplugged *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_pool <span style=color:#f92672>=</span> List.hd <span style=color:#f92672>(</span>XenAPI.Pool.get_all remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> master_host <span style=color:#f92672>=</span> XenAPI.Pool.get_master remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_pool <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pbds <span style=color:#f92672>=</span> XenAPI.SR.get_PBDs remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_sr_ref <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pbd_host_pair <span style=color:#f92672>=</span> List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> pbd <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span>pbd<span style=color:#f92672>,</span> XenAPI.PBD.get_host remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session pbd<span style=color:#f92672>))</span> pbds <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> hosts_to_be_attached <span style=color:#f92672>=</span> <span style=color:#f92672>[</span>master_host<span style=color:#f92672>;</span> remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>]</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pbds_to_be_plugged <span style=color:#f92672>=</span> List.filter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(_,</span> host<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span>List.mem host hosts_to_be_attached<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>(</span>XenAPI.Host.get_enabled remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session host<span style=color:#f92672>))</span> pbd_host_pair <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>pbd<span style=color:#f92672>,</span> <span style=color:#f92672>_)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not <span style=color:#f92672>(</span>XenAPI.PBD.get_currently_attached remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session pbd<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        XenAPI.PBD.plug remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session pbd<span style=color:#f92672>)</span> pbds_to_be_plugged<span style=color:#f92672>;</span></span></span></code></pre></div><p>It begins by attempting to ensure the SRs we require are definitely attached on the destination host and on the destination pool master.</p><p>There&rsquo;s now a little logic to support the case where we have cross-pool SRs and the VDI is already visible to the destination pool. Since this is outside our normal support envelope there is a key in xapi_globs that has to be set (via xapi.conf) to enable this:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> dest_vdi_exists_on_sr vdi_uuid sr_ref retry <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> dest_vdi_ref <span style=color:#f92672>=</span> XenAPI.VDI.get_by_uuid remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session vdi_uuid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> dest_vdi_sr_ref <span style=color:#f92672>=</span> XenAPI.VDI.get_SR remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_vdi_ref <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> dest_vdi_sr_ref <span style=color:#f92672>=</span> sr_ref <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        true
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        false
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> retry <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>          XenAPI.SR.scan remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session sr_ref<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          dest_vdi_exists_on_sr vdi_uuid sr_ref false
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        false
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* CP-4498 added an unsupported mode to use cross-pool shared SRs - the initial
</span></span></span><span style=display:flex><span><span style=color:#75715e>     use case is for a shared raw iSCSI SR (same uuid, same VDI uuid) *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdi_uuid <span style=color:#f92672>=</span> Db.VDI.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> mirror <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>Xapi_globs.relax_xsm_sr_check <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>dest_sr_uuid <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>sr<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(* Check if the VDI uuid already exists in the target SR *)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>dest_vdi_exists_on_sr vdi_uuid dest_sr_ref true<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            false
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            failwith <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;SR UUID matches on destination but VDI does not exist&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        true
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span>not is_intra_pool<span style=color:#f92672>)</span> <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>dest_sr_uuid <span style=color:#f92672>&lt;&gt;</span> vconf<span style=color:#f92672>.</span>sr<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>The check also covers the case where we&rsquo;re doing an intra-pool migration and not copying all of the disks, in which case we don&rsquo;t need to do anything for that disk.</p><p>We now have a wrapper function that creates a new datapath and passes it to a continuation function. On error it handles the destruction of the datapath:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> with_new_dp cont <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dp <span style=color:#f92672>=</span> Printf.sprintf <span style=color:#f92672>(</span><span style=color:#66d9ef>if</span> vconf<span style=color:#f92672>.</span>do_mirror <span style=color:#66d9ef>then</span> <span style=color:#e6db74>&#34;mirror_%s&#34;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;copy_%s&#34;</span><span style=color:#f92672>)</span> vconf<span style=color:#f92672>.</span>dp <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> cont dp
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>try</span> SMAPI.DP.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>allow_leak<span style=color:#f92672>:</span>false <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> info <span style=color:#e6db74>&#34;Failed to cleanup datapath: %s&#34;</span> dp<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> e <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>and now a helper that, given a remote VDI uuid, looks up the reference on the remote host and gives it to a continuation function. On failure of the continuation it will destroy the remote VDI:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> with_remote_vdi remote_vdi cont <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Executing remote scan to ensure VDI is known to xapi&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    XenAPI.SR.scan remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_sr_ref<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> query <span style=color:#f92672>=</span> Printf.sprintf <span style=color:#e6db74>&#34;(field </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>location</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>=</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>%s</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>) and (field </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>SR</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>=</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>%s</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>)&#34;</span> remote_vdi <span style=color:#f92672>(</span>Ref.string_of dest_sr_ref<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> XenAPI.VDI.get_all_records_where remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session query <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> remote_vdi_ref <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> vdis <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> [] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.vdi_location_missing<span style=color:#f92672>,</span> <span style=color:#f92672>[</span>Ref.string_of dest_sr_ref<span style=color:#f92672>;</span> remote_vdi<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> h <span style=color:#f92672>::</span> [] <span style=color:#f92672>-&gt;</span> debug <span style=color:#e6db74>&#34;Found remote vdi reference: %s&#34;</span> <span style=color:#f92672>(</span>Ref.string_of <span style=color:#f92672>(</span>fst h<span style=color:#f92672>));</span> fst h
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.location_not_unique<span style=color:#f92672>,</span> <span style=color:#f92672>[</span>Ref.string_of dest_sr_ref<span style=color:#f92672>;</span> remote_vdi<span style=color:#f92672>]))</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> cont remote_vdi_ref
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>try</span> XenAPI.VDI.destroy remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session remote_vdi_ref <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> error <span style=color:#e6db74>&#34;Failed to destroy remote VDI&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> e <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>another helper to gather together info about a mirrored VDI:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> get_mirror_record <span style=color:#f92672>?</span>new_dp remote_vdi remote_vdi_reference <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span> mr_dp <span style=color:#f92672>=</span> new_dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_mirrored <span style=color:#f92672>=</span> mirror<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_local_sr <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>sr<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_local_vdi <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>location<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_remote_sr <span style=color:#f92672>=</span> dest_sr_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_remote_vdi <span style=color:#f92672>=</span> remote_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_local_xenops_locator <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>xenops_locator<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_remote_xenops_locator <span style=color:#f92672>=</span> Xapi_xenops.xenops_vdi_locator_of_strings dest_sr_uuid remote_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_local_vdi_reference <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_remote_vdi_reference <span style=color:#f92672>=</span> remote_vdi_reference <span style=color:#f92672>}</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>and finally the really important function:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> mirror_to_remote new_dp <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> task <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not vconf<span style=color:#f92672>.</span>do_mirror <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        SMAPI.DATA.copy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>location <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>new_dp <span style=color:#f92672>~</span>url<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>sm_url <span style=color:#f92672>~</span>dest<span style=color:#f92672>:</span>dest_sr_uuid
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(* Though we have no intention of &#34;write&#34;, here we use the same mode as the
</span></span></span><span style=display:flex><span><span style=color:#75715e>           associated VBD on a mirrored VDIs (i.e. always RW). This avoids problem
</span></span></span><span style=display:flex><span><span style=color:#75715e>           when we need to start/stop the VM along the migration. *)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> read_write <span style=color:#f92672>=</span> true <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(* DP set up is only essential for MIRROR.start/stop due to their open ended pattern.
</span></span></span><span style=display:flex><span><span style=color:#75715e>           It&#39;s not necessary for copy which will take care of that itself. *)</span>
</span></span><span style=display:flex><span>        ignore<span style=color:#f92672>(</span>SMAPI.VDI.attach <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>new_dp <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>location <span style=color:#f92672>~</span>read_write<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        SMAPI.VDI.activate <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>new_dp <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>location<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        ignore<span style=color:#f92672>(</span>Storage_access.register_mirror <span style=color:#f92672>__</span>context vconf<span style=color:#f92672>.</span>location<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        SMAPI.DATA.MIRROR.start <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>location <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>new_dp <span style=color:#f92672>~</span>url<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>sm_url <span style=color:#f92672>~</span>dest<span style=color:#f92672>:</span>dest_sr_uuid
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mapfn x <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> total <span style=color:#f92672>=</span> Int64.to_float total_size <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> done_ <span style=color:#f92672>=</span> Int64.to_float <span style=color:#f92672>!</span>so_far <span style=color:#f92672>/.</span> total <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> remaining <span style=color:#f92672>=</span> Int64.to_float vconf<span style=color:#f92672>.</span>size <span style=color:#f92672>/.</span> total <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      done_ <span style=color:#f92672>+.</span> x <span style=color:#f92672>*.</span> remaining <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Storage_access</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> task_result <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      task <span style=color:#f92672>|&gt;</span> register_task <span style=color:#f92672>__</span>context
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> add_to_progress_map mapfn
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> wait_for_task dbg
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> remove_from_progress_map
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> unregister_task <span style=color:#f92672>__</span>context
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> success_task dbg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mirror_id<span style=color:#f92672>,</span> remote_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not vconf<span style=color:#f92672>.</span>do_mirror <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> vdi <span style=color:#f92672>=</span> task_result <span style=color:#f92672>|&gt;</span> vdi_of_task dbg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        remote_vdis <span style=color:#f92672>:=</span> vdi<span style=color:#f92672>.</span>vdi <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>remote_vdis<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>None</span><span style=color:#f92672>,</span> vdi<span style=color:#f92672>.</span>vdi
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> mirrorid <span style=color:#f92672>=</span> task_result <span style=color:#f92672>|&gt;</span> mirror_of_task dbg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> m <span style=color:#f92672>=</span> SMAPI.DATA.MIRROR.stat <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>:</span>mirrorid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Some</span> mirrorid<span style=color:#f92672>,</span> m<span style=color:#f92672>.</span>Mirror.dest_vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    so_far <span style=color:#f92672>:=</span> Int64.add <span style=color:#f92672>!</span>so_far vconf<span style=color:#f92672>.</span>size<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Local VDI %s %s to %s&#34;</span> vconf<span style=color:#f92672>.</span>location <span style=color:#f92672>(</span><span style=color:#66d9ef>if</span> vconf<span style=color:#f92672>.</span>do_mirror <span style=color:#66d9ef>then</span> <span style=color:#e6db74>&#34;mirrored&#34;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;copied&#34;</span><span style=color:#f92672>)</span> remote_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    mirror_id<span style=color:#f92672>,</span> remote_vdi <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This is the bit that actually starts the mirroring or copying. Before the call to mirror we call <code>VDI.attach</code> and <code>VDI.activate</code> locally to ensure that if the VM is shutdown then the detach/deactivate there doesn&rsquo;t kill the mirroring process.</p><p>Note the parameters to the SMAPI call are <code>sr</code> and <code>vdi</code>, locating the local VDI and SM backend, <code>new_dp</code>, the datapath we&rsquo;re using for the mirroring, <code>url</code>, which is the remote url on which SMAPI calls work, and <code>dest</code>, the destination SR uuid. These are also the arguments to <code>copy</code> above too.</p><p>There&rsquo;s a little function to calculate the overall progress of the task, and the function waits until the completion of the task before it continues. The function <code>success_task</code> will raise an exception if the task failed. For <code>DATA.mirror</code>, completion implies both that the disk data has been copied to the destination and that all local writes are being mirrored to the destination. Hence more cleanup must be done on cancellation. In contrast, if the <code>DATA.copy</code> path had been taken then the operation at this point has completely finished.</p><p>The result of this function is an optional mirror id and the remote VDI uuid.</p><p>Next, there is a <code>post_mirror</code> function:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> post_mirror mirror_id mirror_record <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> continuation mirror_record <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>match</span> mirror_id <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> mid <span style=color:#f92672>-&gt;</span> ignore<span style=color:#f92672>(</span>Storage_access.unregister_mirror mid<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> mirror <span style=color:#f92672>&amp;&amp;</span> not <span style=color:#f92672>(</span>Xapi_fist.storage_motion_keep_vdi () <span style=color:#f92672>||</span> copy<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        Helpers.call_api_functions <span style=color:#f92672>~__</span>context <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> rpc session_id <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            XenAPI.VDI.destroy rpc session_id vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      result
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> mirror_failed <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> mirror_id <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> mid <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          ignore<span style=color:#f92672>(</span>Storage_access.unregister_mirror mid<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> m <span style=color:#f92672>=</span> SMAPI.DATA.MIRROR.stat <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>:</span>mid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span><span style=color:#66d9ef>try</span> SMAPI.DATA.MIRROR.stop <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>:</span>mid <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          m<span style=color:#f92672>.</span>Mirror.failed
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> false <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> mirror_failed <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.mirror_failed<span style=color:#f92672>,[</span>Ref.string_of vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>raise</span> e <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This is poorly named - it is post mirror <em>and</em> copy. The aim of this function is to destroy the source VDIs on successful completion of the continuation function, which will have migrated the VM to the destination. In its exception handler it will stop the mirroring, but before doing so it will check to see if the mirroring process it was looking after has itself failed, and raise <code>mirror_failed</code> if so. This is because a failed mirror can result in a range of actual errors, and we decide here that the failed mirror was probably the root cause.</p><p>These functions are assembled together at the end of the <code>vdi_copy_fun</code> function:</p><div class="wrap-code highlight"><pre tabindex=0><code>   if mirror then
    with_new_dp (fun new_dp -&gt;
        let mirror_id, remote_vdi = mirror_to_remote new_dp in
        with_remote_vdi remote_vdi (fun remote_vdi_ref -&gt;
            let mirror_record = get_mirror_record ~new_dp remote_vdi remote_vdi_ref in
            post_mirror mirror_id mirror_record))
  else
    let mirror_record = get_mirror_record vconf.location (XenAPI.VDI.get_by_uuid remote.rpc remote.session vdi_uuid) in
    continuation mirror_record</code></pre></div><p>again, <code>mirror</code> here is poorly named, and means mirror <em>or</em> copy.</p><p>Once all of the disks have been mirrored or copied, we jump back to the body of <code>migrate_send</code>. We split apart the mirror records according to the source of the VDI:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#66d9ef>let</span> was_from vmap <span style=color:#f92672>=</span> List.exists <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vconf <span style=color:#f92672>-&gt;</span> vconf<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> vmap<span style=color:#f92672>.</span>mr_local_vdi_reference<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> suspends_map<span style=color:#f92672>,</span> snapshots_map<span style=color:#f92672>,</span> vdi_map <span style=color:#f92672>=</span> List.fold_left <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>suspends<span style=color:#f92672>,</span> snapshots<span style=color:#f92672>,</span> vdis<span style=color:#f92672>)</span> vmap <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> was_from vmap suspends_vdis <span style=color:#66d9ef>then</span>  vmap <span style=color:#f92672>::</span> suspends<span style=color:#f92672>,</span> snapshots<span style=color:#f92672>,</span> vdis
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> was_from vmap snapshots_vdis <span style=color:#66d9ef>then</span> suspends<span style=color:#f92672>,</span> vmap <span style=color:#f92672>::</span> snapshots<span style=color:#f92672>,</span> vdis
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span> suspends<span style=color:#f92672>,</span> snapshots<span style=color:#f92672>,</span> vmap <span style=color:#f92672>::</span> vdis
</span></span><span style=display:flex><span>        <span style=color:#f92672>)</span> <span style=color:#f92672>(</span>[]<span style=color:#f92672>,</span>[]<span style=color:#f92672>,</span>[]<span style=color:#f92672>)</span> all_map <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>then we reassemble all_map from this, for some reason:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> all_map <span style=color:#f92672>=</span> List.concat <span style=color:#f92672>[</span>suspends_map<span style=color:#f92672>;</span> snapshots_map<span style=color:#f92672>;</span> vdi_map<span style=color:#f92672>]</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Now we need to update the snapshot-of links:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>     <span style=color:#75715e>(* All the disks and snapshots have been created in the remote SR(s),
</span></span></span><span style=display:flex><span><span style=color:#75715e>       * so update the snapshot links if there are any snapshots. *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> snapshots_map <span style=color:#f92672>&lt;&gt;</span> [] <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        update_snapshot_info <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>url<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>sm_url <span style=color:#f92672>~</span>vdi_map <span style=color:#f92672>~</span>snapshots_map<span style=color:#f92672>;</span></span></span></code></pre></div><p>I&rsquo;m not entirely sure why this is done in this layer as opposed to in the storage layer.</p><p>A little housekeeping:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>     <span style=color:#66d9ef>let</span> xenops_vdi_map <span style=color:#f92672>=</span> List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> mirror_record <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span>mirror_record<span style=color:#f92672>.</span>mr_local_xenops_locator<span style=color:#f92672>,</span> mirror_record<span style=color:#f92672>.</span>mr_remote_xenops_locator<span style=color:#f92672>))</span> all_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* Wait for delay fist to disappear *)</span>
</span></span><span style=display:flex><span>      wait_for_fist <span style=color:#f92672>__</span>context Xapi_fist.pause_storage_migrate <span style=color:#e6db74>&#34;pause_storage_migrate&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span></span></span></code></pre></div><p>the <code>fist</code> thing here simply allows tests to put in a delay at this specific point.</p><p>We also check the task to see if we&rsquo;ve been cancelled and raise an exception if so.</p><p>The VM metadata is now imported into the remote pool, with all the XenAPI level objects remapped:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> new_vm <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_intra_pool
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>then</span> vm
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(* Make sure HA replaning cycle won&#39;t occur right during the import process or immediately after *)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> ha_always_run_reset <span style=color:#66d9ef>then</span> XenAPI.Pool.ha_prevent_restarts_for <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>seconds<span style=color:#f92672>:(</span>Int64.of_float <span style=color:#f92672>!</span>Xapi_globs.ha_monitor_interval<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(* Move the xapi VM metadata to the remote pool. *)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> vms <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vdi_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>              List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> mirror_record <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    local_vdi_reference <span style=color:#f92672>=</span> mirror_record<span style=color:#f92672>.</span>mr_local_vdi_reference<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    remote_vdi_reference <span style=color:#f92672>=</span> <span style=color:#a6e22e>Some</span> mirror_record<span style=color:#f92672>.</span>mr_remote_vdi_reference<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>                all_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vif_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>              List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>vif<span style=color:#f92672>,</span> network<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    local_vif_reference <span style=color:#f92672>=</span> vif<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    remote_network_reference <span style=color:#f92672>=</span> network<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>                vif_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vgpu_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>              List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>vgpu<span style=color:#f92672>,</span> gpu_group<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    local_vgpu_reference <span style=color:#f92672>=</span> vgpu<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    remote_gpu_group_reference <span style=color:#f92672>=</span> gpu_group<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>                vgpu_map
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            inter_pool_metadata_transfer <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>remote <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>vdi_map
</span></span><span style=display:flex><span>              <span style=color:#f92672>~</span>vif_map <span style=color:#f92672>~</span>vgpu_map <span style=color:#f92672>~</span>dry_run<span style=color:#f92672>:</span>false <span style=color:#f92672>~</span>live<span style=color:#f92672>:</span>true <span style=color:#f92672>~</span>copy
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> vm <span style=color:#f92672>=</span> List.hd vms <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> ha_always_run_reset <span style=color:#66d9ef>then</span> XenAPI.VM.set_ha_always_run <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#f92672>~</span><span style=color:#66d9ef>value</span><span style=color:#f92672>:</span>false <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(* Reserve resources for the new VM on the destination pool&#39;s host *)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span> XenAPI.Host.allocate_resources_for_vm remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session remote<span style=color:#f92672>.</span>dest_host vm true <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          vm <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>More waiting for fist points:</p><div class="wrap-code highlight"><pre tabindex=0><code>     wait_for_fist __context Xapi_fist.pause_storage_migrate2 &#34;pause_storage_migrate2&#34;;

      (* Attach networks on remote *)
      XenAPI.Network.attach_for_vm ~rpc:remote.rpc ~session_id:remote.session ~host:remote.dest_host ~vm:new_vm;</code></pre></div><p>also make sure all the networks are plugged for the VM on the destination.
Next we create the xenopsd-level vif map, equivalent to the vdi_map above:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* Create the vif-map for xenops, linking VIF devices to bridge names on the remote *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> xenops_vif_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> vifs <span style=color:#f92672>=</span> XenAPI.VM.get_VIFs <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>new_vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vif <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vifr <span style=color:#f92672>=</span> XenAPI.VIF.get_record <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vif <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> bridge <span style=color:#f92672>=</span> Xenops_interface.Network.<span style=color:#a6e22e>Local</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>(</span>XenAPI.Network.get_bridge <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vifr<span style=color:#f92672>.</span>API.vIF_network<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            vifr<span style=color:#f92672>.</span>API.vIF_device<span style=color:#f92672>,</span> bridge
</span></span><span style=display:flex><span>          <span style=color:#f92672>)</span> vifs
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Now we destroy any extra mirror datapaths we set up previously:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>     <span style=color:#75715e>(* Destroy the local datapaths - this allows the VDIs to properly detach, invoking the migrate_finalize calls *)</span>
</span></span><span style=display:flex><span>      List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> mirror_record <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> mirror_record<span style=color:#f92672>.</span>mr_mirrored
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>match</span> mirror_record<span style=color:#f92672>.</span>mr_dp <span style=color:#66d9ef>with</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> dp <span style=color:#f92672>-&gt;</span>  SMAPI.DP.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>allow_leak<span style=color:#f92672>:</span>false <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> ()<span style=color:#f92672>)</span> all_map<span style=color:#f92672>;</span></span></span></code></pre></div><p>More housekeeping:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;vm.migrate_send: migration initiated vm:%s&#34;</span> vm_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* In case when we do SXM on the same host (mostly likely a VDI
</span></span></span><span style=display:flex><span><span style=color:#75715e>         migration), the VM&#39;s metadata in xenopsd will be in-place updated
</span></span></span><span style=display:flex><span><span style=color:#75715e>         as soon as the domain migration starts. For these case, there
</span></span></span><span style=display:flex><span><span style=color:#75715e>         will be no (clean) way back from this point. So we disable task
</span></span></span><span style=display:flex><span><span style=color:#75715e>         cancellation for them here.
</span></span></span><span style=display:flex><span><span style=color:#75715e>       *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> is_same_host <span style=color:#66d9ef>then</span> <span style=color:#f92672>(</span>TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span> TaskHelper.set_not_cancellable <span style=color:#f92672>~__</span>context<span style=color:#f92672>);</span></span></span></code></pre></div><p>Finally we get to the memory-image part of the migration:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#75715e>(* It&#39;s acceptable for the VM not to exist at this point; shutdown commutes with storage migrate *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>          Xapi_xenops.Events_from_xenopsd.with_suppressed queue_name dbg vm_uuid
</span></span><span style=display:flex><span>            <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>let</span> xenops_vgpu_map <span style=color:#f92672>=</span> <span style=color:#75715e>(* can raise VGPU_mapping *)</span>
</span></span><span style=display:flex><span>                 infer_vgpu_map <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>remote new_vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>               migrate_with_retry
</span></span><span style=display:flex><span>                 <span style=color:#f92672>~__</span>context queue_name dbg vm_uuid xenops_vdi_map
</span></span><span style=display:flex><span>                 xenops_vif_map xenops_vgpu_map remote<span style=color:#f92672>.</span>xenops_url<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>               Xapi_xenops.Xenopsd_metadata.delete <span style=color:#f92672>~__</span>context vm_uuid<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> Xenops_interface.<span style=color:#a6e22e>Does_not_exist</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;VM&#34;</span><span style=color:#f92672>,_)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> Xenops_interface.<span style=color:#a6e22e>Does_not_exist</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;extra&#34;</span><span style=color:#f92672>,_)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          info <span style=color:#e6db74>&#34;%s: VM %s stopped being live during migration&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;vm_migrate_send&#34;</span> vm_uuid
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>VGPU_mapping</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          info <span style=color:#e6db74>&#34;%s: VM %s - can&#39;t infer vGPU map: %s&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;vm_migrate_send&#34;</span> vm_uuid msg<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>raise</span> Api_errors.
</span></span><span style=display:flex><span>                  <span style=color:#f92672>(</span><span style=color:#a6e22e>Server_error</span>
</span></span><span style=display:flex><span>                     <span style=color:#f92672>(</span>vm_migrate_failed<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                      <span style=color:#f92672>([</span> vm_uuid
</span></span><span style=display:flex><span>                       <span style=color:#f92672>;</span> Helpers.get_localhost_uuid ()
</span></span><span style=display:flex><span>                       <span style=color:#f92672>;</span> Db.Host.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>dest_host
</span></span><span style=display:flex><span>                       <span style=color:#f92672>;</span> <span style=color:#e6db74>&#34;The VM changed its power state during migration&#34;</span>
</span></span><span style=display:flex><span>                       <span style=color:#f92672>])))</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Migration complete&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      SMPERF.debug <span style=color:#e6db74>&#34;vm.migrate_send: migration complete vm:%s&#34;</span> vm_uuid<span style=color:#f92672>;</span></span></span></code></pre></div><p>Now we tidy up after ourselves:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#75715e>(* So far the main body of migration is completed, and the rests are
</span></span></span><span style=display:flex><span><span style=color:#75715e>         updates, config or cleanup on the source and destination. There will
</span></span></span><span style=display:flex><span><span style=color:#75715e>         be no (clean) way back from this point, due to these destructive
</span></span></span><span style=display:flex><span><span style=color:#75715e>         changes, so we don&#39;t want user intervention e.g. task cancellation.
</span></span></span><span style=display:flex><span><span style=color:#75715e>       *)</span>
</span></span><span style=display:flex><span>      TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      TaskHelper.set_not_cancellable <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      XenAPI.VM.pool_migrate_complete remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session new_vm remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      detach_local_network_for_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>destination<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      Xapi_xenops.refresh_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm<span style=color:#f92672>;</span></span></span></code></pre></div><p>the function <code>pool_migrate_complete</code> is called on the destination host, and consists of a few things that ordinarily would be set up during VM.start or the like:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> pool_migrate_complete <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>host <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> Db.VM.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;VM.pool_migrate_complete %s&#34;</span> id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dbg <span style=color:#f92672>=</span> Context.string_of_task <span style=color:#f92672>__</span>context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> queue_name <span style=color:#f92672>=</span> Xapi_xenops_queue.queue_of_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> Xapi_xenops.vm_exists_in_xenopsd queue_name dbg id <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    Cpuid_helpers.update_cpu_flags <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>host<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Xapi_xenops.set_resident_on <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Xapi_xenops.add_caches id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Xapi_xenops.refresh_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Monitor_dbcalls_cache.clear_cache_for_vm <span style=color:#f92672>~</span>vm_uuid<span style=color:#f92672>:</span>id
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span></span></span></code></pre></div><p>More tidying up, remapping some remaining VBDs and clearing state on the sender:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#75715e>(* Those disks that were attached at the point the migration happened will have been
</span></span></span><span style=display:flex><span><span style=color:#75715e>         remapped by the Events_from_xenopsd logic. We need to remap any other disks at
</span></span></span><span style=display:flex><span><span style=color:#75715e>         this point here *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> is_intra_pool
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        List.iter
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vm&#39; <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>             intra_pool_vdi_remap <span style=color:#f92672>~__</span>context vm&#39; all_map<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             intra_pool_fix_suspend_sr <span style=color:#f92672>~__</span>context remote<span style=color:#f92672>.</span>dest_host vm&#39;<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          vm_and_snapshots<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* If it&#39;s an inter-pool migrate, the VBDs will still be &#39;currently-attached=true&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>         because we supressed the events coming from xenopsd. Destroy them, so that the
</span></span></span><span style=display:flex><span><span style=color:#75715e>         VDIs can be destroyed *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> not copy
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>then</span> List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vbd <span style=color:#f92672>-&gt;</span> Db.VBD.destroy <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>vbds <span style=color:#f92672>@</span> snapshots_vbds<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      new_vm
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>The remark about the <code>Events_from_xenopsd</code> is that we have a thread watching for events that are emitted by xenopsd, and we resynchronise xapi&rsquo;s state according to xenopsd&rsquo;s state for several fields for which xenopsd is considered the canonical source of truth. One of these is the exact VDI the VBD is associated with.</p><p>The suspend_SR field of the VM is set to the source&rsquo;s value, so we reset that.</p><p>Now we move the RRDs:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>if</span> not copy <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      Rrdd_proxy.migrate_rrd <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>remote_address<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>remote_ip <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:(</span>Ref.string_of remote<span style=color:#f92672>.</span>session<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>vm_uuid<span style=color:#f92672>:</span>vm_uuid <span style=color:#f92672>~</span>host_uuid<span style=color:#f92672>:(</span>Ref.string_of remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>)</span> ()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>This can be done for intra- and inter- pool migrates in the same way, simplifying the logic.</p><p>However, for messages and blobs we have to only migrate them for inter-pool migrations:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>   <span style=color:#66d9ef>if</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> not copy <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* Replicate HA runtime flag if necessary *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> ha_always_run_reset <span style=color:#66d9ef>then</span> XenAPI.VM.set_ha_always_run <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>new_vm <span style=color:#f92672>~</span><span style=color:#66d9ef>value</span><span style=color:#f92672>:</span>true<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* Send non-database metadata *)</span>
</span></span><span style=display:flex><span>      Xapi_message.send_messages <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>cls<span style=color:#f92672>:`</span><span style=color:#a6e22e>VM</span> <span style=color:#f92672>~</span>obj_uuid<span style=color:#f92672>:</span>vm_uuid
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>remote_address<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>remote_master_ip<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      Xapi_blob.migrate_push <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>remote_address<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>remote_master_ip <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>old_vm<span style=color:#f92672>:</span>vm <span style=color:#f92672>~</span>new_vm <span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* Signal the remote pool that we&#39;re done *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>Lastly, we destroy the VM record on the source:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    Helpers.call_api_functions <span style=color:#f92672>~__</span>context <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> rpc session_id <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> not copy <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>          info <span style=color:#e6db74>&#34;Destroying VM ref=%s uuid=%s&#34;</span> <span style=color:#f92672>(</span>Ref.string_of vm<span style=color:#f92672>)</span> vm_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          Xapi_vm_lifecycle.force_state_reset <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#f92672>~</span><span style=color:#66d9ef>value</span><span style=color:#f92672>:`</span><span style=color:#a6e22e>Halted</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span> Db.VM.destroy <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>)</span> vm_and_snapshots
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;vm.migrate_send exiting vm:%s&#34;</span> vm_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    new_vm</span></span></code></pre></div><p>The exception handler still has to clean some state, but mostly things are handled in the CPS functions declared above:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    error <span style=color:#e6db74>&#34;Caught %s: cleaning up&#34;</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* We do our best to tidy up the state left behind *)</span>
</span></span><span style=display:flex><span>    Events_from_xenopsd.with_suppressed queue_name dbg vm_uuid <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> <span style=color:#f92672>_,</span> state <span style=color:#f92672>=</span> XenopsAPI.VM.stat dbg vm_uuid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> Xenops_interface.<span style=color:#f92672>(</span>state<span style=color:#f92672>.</span>Vm.power_state <span style=color:#f92672>=</span> <span style=color:#a6e22e>Suspended</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            debug <span style=color:#e6db74>&#34;xenops: %s: shutting down suspended VM&#34;</span> vm_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            Xapi_xenops.shutdown <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#a6e22e>None</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> Db.is_valid_ref <span style=color:#f92672>__</span>context vm <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span> Db.VM.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>)</span> vm_and_snapshots
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vm_ref <span style=color:#f92672>=</span> XenAPI.VM.get_by_uuid remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session self <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            info <span style=color:#e6db74>&#34;Destroying stale VM uuid=%s on destination host&#34;</span> self<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            XenAPI.VM.destroy remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session vm_ref
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span> error <span style=color:#e6db74>&#34;Caught %s while destroying VM uuid=%s on destination host&#34;</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>)</span> self<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> task <span style=color:#f92672>=</span> Context.get_task_id <span style=color:#f92672>__</span>context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> oc <span style=color:#f92672>=</span> Db.Task.get_other_config <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>task <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> List.mem_assoc <span style=color:#e6db74>&#34;mirror_failed&#34;</span> oc <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> failed_vdi <span style=color:#f92672>=</span> List.assoc <span style=color:#e6db74>&#34;mirror_failed&#34;</span> oc <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> vconf <span style=color:#f92672>=</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vconf <span style=color:#f92672>-&gt;</span> vconf<span style=color:#f92672>.</span>location<span style=color:#f92672>=</span>failed_vdi<span style=color:#f92672>)</span> vms_vdis <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Mirror failed for VDI: %s&#34;</span> failed_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.mirror_failed<span style=color:#f92672>,[</span>Ref.string_of vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>begin</span> <span style=color:#66d9ef>match</span> e <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> Storage_interface.<span style=color:#a6e22e>Backend_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> Storage_interface.<span style=color:#a6e22e>Unimplemented</span><span style=color:#f92672>(</span>code<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.unimplemented_in_sm_backend<span style=color:#f92672>,</span> <span style=color:#f92672>[</span>code<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> Xenops_interface.<span style=color:#a6e22e>Cancelled</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> TaskHelper.raise_cancelled <span style=color:#f92672>~__</span>context
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> e
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span></span></span></code></pre></div><p>Failures during the migration can result in the VM being in a suspended state. There&rsquo;s no point leaving it like this since there&rsquo;s nothing that can be done to resume it, so we force shut it down.</p><p>We also try to remove the VM record from the destination if we managed to send it there.</p><p>Finally we check for mirror failure in the task - this is set by the events thread watching for events from the storage layer, in <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_access.ml#L1169-L1207 target=_blank>storage_access.ml</a></p><h2 id=storage-code>Storage code</h2><p>The part of the code that is conceptually in the storage layer, but physically in xapi, is located in
<a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml target=_blank>storage_migrate.ml</a>. There are logically a few separate parts to this file:</p><ul><li>A <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L34-L204 target=_blank>stateful module</a> for persisting state across xapi restarts.</li><li>Some general <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L206-L281 target=_blank>helper functions</a></li><li>Some quite specific <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L206-L281 target=_blank>helper</a> <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L738-L791 target=_blank>functions</a> related to actions to be taken on deactivate/detach</li><li>An <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L793-L818 target=_blank>NBD handler</a></li><li>The implementations of the SMAPIv2 <a href=https://github.com/xapi-project/xcp-idl/blob/master/storage/storage_interface.ml#L430-L460 target=_blank>mirroring APIs</a></li></ul><p>Let&rsquo;s start by considering the way the storage APIs are intended to be used.</p><h3 id=copying-a-vdi>Copying a VDI</h3><p><code>DATA.copy</code> takes several parameters:</p><ul><li><code>dbg</code> - a debug string</li><li><code>sr</code> - the source SR (a uuid)</li><li><code>vdi</code> - the source VDI (a uuid)</li><li><code>dp</code> - <strong>unused</strong></li><li><code>url</code> - a URL on which SMAPIv2 API calls can be made</li><li><code>sr</code> - the destination SR in which the VDI should be copied</li></ul><p>and returns a parameter of type <code>Task.id</code>. The API call is intended to be called in an asynchronous fashion - ie., the caller makes the call, receives the task ID back and polls or uses the event mechanism to wait until the task has completed. The task may be cancelled via the <code>Task.cancel</code> API call. The result of the operation is obtained by calling TASK.stat, which returns a record:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>	<span style=color:#66d9ef>type</span> t <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>		id<span style=color:#f92672>:</span> id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		dbg<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		ctime<span style=color:#f92672>:</span> <span style=color:#66d9ef>float</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		state<span style=color:#f92672>:</span> state<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		subtasks<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>string</span> <span style=color:#f92672>*</span> state<span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		debug_info<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>string</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		backtrace<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span></span></span></code></pre></div><p>Where the <code>state</code> field contains the result once the task has completed:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> async_result_t <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Vdi_info</span> <span style=color:#66d9ef>of</span> vdi_info
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Mirror_id</span> <span style=color:#66d9ef>of</span> Mirror.id
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> completion_t <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	duration <span style=color:#f92672>:</span> <span style=color:#66d9ef>float</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	result <span style=color:#f92672>:</span> async_result_t option
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> state <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Pending</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>float</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Completed</span> <span style=color:#66d9ef>of</span> completion_t
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Failed</span> <span style=color:#66d9ef>of</span> Rpc.t</span></span></code></pre></div><p>Once the result has been obtained from the task, the task should be destroyed via the <code>TASK.destroy</code> API call.</p><p>The implementation uses the <code>url</code> parameter to make SMAPIv2 calls to the destination SR. This is used, for example, to invoke a VDI.create call if necessary. The URL contains an authentication token within it (valid for the duration of the XenAPI call that caused this DATA.copy API call).</p><p>The implementation tries to minimize the amount of data copied by looking for related VDIs on the destination SR. See below for more details.</p><h3 id=mirroring-a-vdi>Mirroring a VDI</h3><p><code>DATA.MIRROR.start</code> takes a similar set of parameters to that of copy:</p><ul><li><code>dbg</code> - a debug string</li><li><code>sr</code> - the source SR (a uuid)</li><li><code>vdi</code> - the source VDI (a uuid)</li><li><code>dp</code> - the datapath on which the VDI has been attached</li><li><code>url</code> - a URL on which SMAPIv2 API calls can be made</li><li><code>sr</code> - the destination SR in which the VDI should be copied</li></ul><p>Similar to copy above, this returns a task id. The task &lsquo;completes&rsquo; once the mirror has been set up - that is, at any point afterwards we can detach the disk and the destination disk will be identical to the source. Unlike for copy the operation is ongoing after the API call completes, since new writes need to be mirrored to the destination. Therefore the completion type of the mirror operation is <code>Mirror_id</code> which contains a handle on which further API calls related to the mirror call can be made. For example <a href=https://github.com/xapi-project/xcp-idl/blob/a999ef6191629c8f68377f7c412ee98fc6a39dea/storage/storage_interface.ml#L446 target=_blank>MIRROR.stat</a> whose signature is:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>MIRROR.stat<span style=color:#f92672>:</span> dbg<span style=color:#f92672>:</span>debug_info <span style=color:#f92672>-&gt;</span> id<span style=color:#f92672>:</span>Mirror.id <span style=color:#f92672>-&gt;</span> Mirror.t</span></span></code></pre></div><p>The return type of this call is a record containing information about the mirror:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> state <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Receiving</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Sending</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Copying</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> t <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	source_vdi <span style=color:#f92672>:</span> vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	dest_vdi <span style=color:#f92672>:</span> vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	state <span style=color:#f92672>:</span> state <span style=color:#66d9ef>list</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	failed <span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p>Note that state is a list since the initial phase of the operation requires both copying and mirroring.</p><p>Additionally the mirror can be cancelled using the <code>MIRROR.stop</code> API call.</p><h3 id=code-walkthrough>Code walkthrough</h3><p>let&rsquo;s go through the implementation of <code>copy</code>:</p><h4 id=datacopy>DATA.copy</h4><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> copy <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;copy sr:%s vdi:%s url:%s dest:%s&#34;</span> sr vdi url dest<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_url <span style=color:#f92672>=</span> Http.Url.of_string url <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Remote</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Client</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> rpc <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> <span style=color:#f92672>~</span>dststr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;dst_smapiv2&#34;</span> remote_url <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Here we are constructing a module <code>Remote</code> on which we can do SMAPIv2 calls directly on the destination.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>try</span></span></span></code></pre></div><p>Wrap the whole function in an exception handler.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#75715e>(* Find the local VDI *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> Local.SR.scan <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> vdi<span style=color:#f92672>)</span> vdis
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Not_found</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Local VDI %s not found&#34;</span> vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>We first find the metadata for our source VDI by doing a local SMAPIv2 call <code>SR.scan</code>. This returns a list of VDI metadata, out of which we extract the VDI we&rsquo;re interested in.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>try</span></span></span></code></pre></div><p>Another exception handler. This looks redundant to me right now.</p><div class="wrap-code highlight"><pre tabindex=0><code>      let similar_vdis = Local.VDI.similar_content ~dbg ~sr ~vdi in
      let similars = List.map (fun vdi -&gt; vdi.content_id) similar_vdis in
      debug &#34;Similar VDIs to %s = [ %s ]&#34; vdi (String.concat &#34;; &#34; (List.map (fun x -&gt; Printf.sprintf &#34;(vdi=%s,content_id=%s)&#34; x.vdi x.content_id) similar_vdis));</code></pre></div><p>Here we look for related VDIs locally using the <code>VDI.similar_content</code> SMAPIv2 API call. This searches for related VDIs and returns an ordered list where the most similar is first in the list. It returns both clones and snapshots, and hence is more general than simply following <code>snapshot_of</code> links.</p><div class="wrap-code highlight"><pre tabindex=0><code>      let remote_vdis = Remote.SR.scan ~dbg ~sr:dest in
      (** We drop cbt_metadata VDIs that do not have any actual data *)
      let remote_vdis = List.filter (fun vdi -&gt; vdi.ty &lt;&gt; &#34;cbt_metadata&#34;) remote_vdis in

      let nearest = List.fold_left
          (fun acc content_id -&gt; match acc with
             | Some x -&gt; acc
             | None -&gt;
               try Some (List.find (fun vdi -&gt; vdi.content_id = content_id &amp;&amp; vdi.virtual_size &lt;= local_vdi.virtual_size) remote_vdis)
               with Not_found -&gt; None) None similars in

      debug &#34;Nearest VDI: content_id=%s vdi=%s&#34;
        (Opt.default &#34;None&#34; (Opt.map (fun x -&gt; x.content_id) nearest))
        (Opt.default &#34;None&#34; (Opt.map (fun x -&gt; x.vdi) nearest));</code></pre></div><p>Here we look for VDIs on the destination with the same <code>content_id</code> as one of the locally similar VDIs. We will use this as a base image and only copy deltas to the destination. This is done by cloning the VDI on the destination and then using <code>sparse_dd</code> to find the deltas from our local disk to our local copy of the content_id disk and streaming these to the destination. Note that we need to ensure the VDI is smaller than the one we want to copy since we can&rsquo;t resize disks downwards in size.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#66d9ef>let</span> remote_base <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> nearest <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> vdi <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Cloning VDI %s&#34;</span> vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> vdi_clone <span style=color:#f92672>=</span> Remote.VDI.clone <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> vdi_clone<span style=color:#f92672>.</span>virtual_size <span style=color:#f92672>&lt;&gt;</span> local_vdi<span style=color:#f92672>.</span>virtual_size <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> new_size <span style=color:#f92672>=</span> Remote.VDI.resize <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vdi_clone<span style=color:#f92672>.</span>vdi <span style=color:#f92672>~</span>new_size<span style=color:#f92672>:</span>local_vdi<span style=color:#f92672>.</span>virtual_size <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            debug <span style=color:#e6db74>&#34;Resize remote VDI %s to %Ld: result %Ld&#34;</span> vdi_clone<span style=color:#f92672>.</span>vdi local_vdi<span style=color:#f92672>.</span>virtual_size new_size<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          vdi_clone
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Creating a blank remote VDI&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          Remote.VDI.create <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:{</span> local_vdi <span style=color:#66d9ef>with</span> sm_config <span style=color:#f92672>=</span> [] <span style=color:#f92672>}</span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>If we&rsquo;ve found a base VDI we clone it and resize it immediately. If there&rsquo;s nothing on the destination already we can use, we just create a new VDI. Note that the calls to create and clone may well fail if the destination host is not the SRmaster. This is <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/storage_migrate.ml#L214-L229 target=_blank>handled purely in the <code>rpc</code> function</a>:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> rpc <span style=color:#f92672>~</span>srcstr <span style=color:#f92672>~</span>dststr url call <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> XMLRPC_protocol.rpc <span style=color:#f92672>~</span>transport<span style=color:#f92672>:(</span>transport_of_url url<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>~</span>srcstr <span style=color:#f92672>~</span>dststr <span style=color:#f92672>~</span>http<span style=color:#f92672>:(</span>xmlrpc <span style=color:#f92672>~</span>version<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;1.0&#34;</span> <span style=color:#f92672>?</span>auth<span style=color:#f92672>:(</span>Http.Url.auth_of url<span style=color:#f92672>)</span> <span style=color:#f92672>~</span>query<span style=color:#f92672>:(</span>Http.Url.get_query_params url<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>Http.Url.get_uri url<span style=color:#f92672>))</span> call
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> not result<span style=color:#f92672>.</span>Rpc.success <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Got failure: checking for redirect&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Call was: %s&#34;</span> <span style=color:#f92672>(</span>Rpc.string_of_call call<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;result.contents: %s&#34;</span> <span style=color:#f92672>(</span>Jsonrpc.to_string result<span style=color:#f92672>.</span>Rpc.contents<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> Storage_interface.Exception.exnty_of_rpc result<span style=color:#f92672>.</span>Rpc.contents <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> Storage_interface.Exception.<span style=color:#a6e22e>Redirect</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Some</span> ip<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> Http.<span style=color:#a6e22e>Url</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> newurl <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> url <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Http</span> h<span style=color:#f92672>,</span> d<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span><span style=color:#a6e22e>Http</span> <span style=color:#f92672>{</span>h <span style=color:#66d9ef>with</span> host<span style=color:#f92672>=</span>ip<span style=color:#f92672>},</span> d<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          remote_url ip <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Redirecting to ip: %s&#34;</span> ip<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr <span style=color:#f92672>~</span>dststr newurl call <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Successfully redirected. Returning&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      r
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Not a redirect&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      result
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> result</span></span></code></pre></div><p>Back to the copy function:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#66d9ef>let</span> remote_copy <span style=color:#f92672>=</span> copy&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi<span style=color:#f92672>:</span>remote_base<span style=color:#f92672>.</span>vdi <span style=color:#f92672>|&gt;</span> vdi_info <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This calls the actual data copy part. See below for more on that.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#66d9ef>let</span> snapshot <span style=color:#f92672>=</span> Remote.VDI.snapshot <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:</span>remote_copy <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      Remote.VDI.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>remote_copy<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Vdi_info</span> snapshot<span style=color:#f92672>)</span></span></span></code></pre></div><p>Finally we snapshot the remote VDI to ensure we&rsquo;ve got a VDI of type &lsquo;snapshot&rsquo; on the destination, and we delete the non-snapshot VDI.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      error <span style=color:#e6db74>&#34;Caught %s: copying snapshots vdi&#34;</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Internal_error</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Backend_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Backend_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Internal_error</span><span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>))</span></span></span></code></pre></div><p>The exception handler does nothing - so we leak remote VDIs if the exception happens after we&rsquo;ve done our cloning :-(</p><h4 id=datacopy_into>DATA.copy_into</h4><p>Let&rsquo;s now look at the data-copying part. This is common code shared between <code>VDI.copy</code>, <code>VDI.copy_into</code> and <code>MIRROR.start</code> and hence has some duplication of the calls made above.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> copy_into <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  copy&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi</span></span></code></pre></div><p><code>copy_into</code> is a stub and just calls <code>copy'</code></p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> copy&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_url <span style=color:#f92672>=</span> Http.Url.of_string url <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Remote</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Client</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> rpc <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> <span style=color:#f92672>~</span>dststr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;dst_smapiv2&#34;</span> remote_url <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;copy local=%s/%s url=%s remote=%s/%s&#34;</span> sr vdi url dest dest_vdi<span style=color:#f92672>;</span></span></span></code></pre></div><p>This call takes roughly the same parameters as the ``DATA.copy` call above, except it specifies the destination VDI.
Once again we construct a module to do remote SMAPIv2 calls</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* Check the remote SR exists *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> srs <span style=color:#f92672>=</span> Remote.SR.list <span style=color:#f92672>~</span>dbg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> not<span style=color:#f92672>(</span>List.mem dest srs<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>then</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Remote SR %s not found&#34;</span> dest<span style=color:#f92672>);</span></span></span></code></pre></div><p>Sanity check.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> Remote.SR.scan <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> dest_vdi<span style=color:#f92672>)</span> vdis
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Not_found</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Remote VDI %s not found&#34;</span> dest_vdi<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Find the metadata of the destination VDI</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_content_id <span style=color:#f92672>=</span> remote_vdi<span style=color:#f92672>.</span>content_id <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>If we&rsquo;ve got a local VDI with the same content_id as the destination, we only need copy the deltas, so we make a note of the destination content ID here.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* Find the local VDI *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> Local.SR.scan <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> vdi<span style=color:#f92672>)</span> vdis
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Not_found</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Local VDI %s not found&#34;</span> vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;copy local=%s/%s content_id=%s&#34;</span> sr vdi local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;copy remote=%s/%s content_id=%s&#34;</span> dest dest_vdi remote_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span></span></span></code></pre></div><p>Find the source VDI metadata.</p><div class="wrap-code highlight"><pre tabindex=0><code>  if local_vdi.virtual_size &gt; remote_vdi.virtual_size then begin
    (* This should never happen provided the higher-level logic is working properly *)
    error &#34;copy local=%s/%s virtual_size=%Ld &gt; remote=%s/%s virtual_size = %Ld&#34; sr vdi local_vdi.virtual_size dest dest_vdi remote_vdi.virtual_size;
    failwith &#34;local VDI is larger than the remote VDI&#34;;
  end;</code></pre></div><p>Sanity check - the remote VDI can&rsquo;t be smaller than the source.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> on_fail <span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>unit</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>unit</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span> ref <span style=color:#f92672>=</span> ref [] <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>We do some ugly error handling here by keeping a mutable list of operations to perform in the event of a failure.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> base_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>content_id <span style=color:#f92672>=</span> dest_content_id<span style=color:#f92672>)</span> vdis<span style=color:#f92672>).</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;local VDI %s has content_id = %s; we will perform an incremental copy&#34;</span> x dest_content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Some</span> x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;no local VDI has content_id = %s; we will perform a full copy&#34;</span> dest_content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>None</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>See if we can identify a local VDI with the same <code>content_id</code> as the destination. If not, no problem.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> remote_dp <span style=color:#f92672>=</span> Uuid.string_of_uuid <span style=color:#f92672>(</span>Uuid.make_uuid ()<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> base_dp <span style=color:#f92672>=</span> Uuid.string_of_uuid <span style=color:#f92672>(</span>Uuid.make_uuid ()<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> leaf_dp <span style=color:#f92672>=</span> Uuid.string_of_uuid <span style=color:#f92672>(</span>Uuid.make_uuid ()<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Construct some <code>datapaths</code> - named reasons why the VDI is attached - that we will pass to <code>VDI.attach/activate</code>.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dest_vdi_url <span style=color:#f92672>=</span> Http.Url.set_uri remote_url <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;%s/nbd/%s/%s/%s&#34;</span> <span style=color:#f92672>(</span>Http.Url.get_uri remote_url<span style=color:#f92672>)</span> dest dest_vdi remote_dp<span style=color:#f92672>)</span> <span style=color:#f92672>|&gt;</span> Http.Url.to_string <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;copy remote=%s/%s NBD URL = %s&#34;</span> dest dest_vdi dest_vdi_url<span style=color:#f92672>;</span></span></span></code></pre></div><p>Here we are constructing a URI that we use to connect to the destination xapi. The handler for this particular path will verify the credentials and then pass the connection on to tapdisk which will behave as a NBD server. The VDI has to be attached and activated for this to work, unlike the new NBD handler in <code>xapi-nbd</code> that is smarter. The handler for this URI is declared <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/storage_migrate.ml#L858-L884 target=_blank>in this file</a></p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> id<span style=color:#f92672>=</span>State.copy_id_of <span style=color:#f92672>(</span>sr<span style=color:#f92672>,</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Persisting state for copy (id=%s)&#34;</span> id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    State.add id State.<span style=color:#f92672>(</span><span style=color:#a6e22e>Copy_op</span> Copy_state.<span style=color:#f92672>({</span>
</span></span><span style=display:flex><span>        base_dp<span style=color:#f92672>;</span> leaf_dp<span style=color:#f92672>;</span> remote_dp<span style=color:#f92672>;</span> dest_sr<span style=color:#f92672>=</span>dest<span style=color:#f92672>;</span> copy_vdi<span style=color:#f92672>=</span>remote_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span> remote_url<span style=color:#f92672>=</span>url<span style=color:#f92672>}));</span></span></span></code></pre></div><p>Since we&rsquo;re about to perform a long-running operation that is stateful, we persist the state here so that if xapi is restarted we can cancel the operation and not leak VDI attaches. Normally in xapi code we would be doing VBD.plug operations to persist the state in the xapi db, but this is storage code so we have to use a different mechanism.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;mirror.copy: copy initiated local_vdi:%s dest_vdi:%s&#34;</span> vdi dest_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Pervasiveext.finally <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        debug <span style=color:#e6db74>&#34;activating RW datapath %s on remote=%s/%s&#34;</span> remote_dp dest dest_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        ignore<span style=color:#f92672>(</span>Remote.VDI.attach <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>dest_vdi <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>remote_dp <span style=color:#f92672>~</span>read_write<span style=color:#f92672>:</span>true<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        Remote.VDI.activate <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>remote_dp <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>dest_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        with_activated_disk <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>base_vdi <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>base_dp
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> base_path <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>             with_activated_disk <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:(</span><span style=color:#a6e22e>Some</span> vdi<span style=color:#f92672>)</span> <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>leaf_dp
</span></span><span style=display:flex><span>               <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> src <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                  <span style=color:#66d9ef>let</span> dd <span style=color:#f92672>=</span> Sparse_dd_wrapper.start <span style=color:#f92672>~</span>progress_cb<span style=color:#f92672>:(</span>progress_callback 0<span style=color:#f92672>.</span>05 0<span style=color:#f92672>.</span>9 task<span style=color:#f92672>)</span> <span style=color:#f92672>?</span>base<span style=color:#f92672>:</span>base_path true <span style=color:#f92672>(</span>Opt.unbox src<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                      dest_vdi_url remote_vdi<span style=color:#f92672>.</span>virtual_size <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                  Storage_task.with_cancel task
</span></span><span style=display:flex><span>                    <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> Sparse_dd_wrapper.cancel dd<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>try</span> Sparse_dd_wrapper.wait dd
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>with</span> Sparse_dd_wrapper.<span style=color:#a6e22e>Cancelled</span> <span style=color:#f92672>-&gt;</span> Storage_task.raise_cancelled task<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>               <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>         Remote.DP.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>remote_dp <span style=color:#f92672>~</span>allow_leak<span style=color:#f92672>:</span>false<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>         State.remove_copy id
</span></span><span style=display:flex><span>      <span style=color:#f92672>);</span></span></span></code></pre></div><p>In this chunk of code we attach and activate the disk on the remote SR via the SMAPI, then locally attach and activate both the VDI we&rsquo;re copying and the base image we&rsquo;re copying deltas from (if we&rsquo;ve got one). We then call <code>sparse_dd</code> to copy the data to the remote NBD URL. There is some logic to update progress indicators and to cancel the operation if the SMAPIv2 call <code>TASK.cancel</code> is called.</p><p>Once the operation has terminated (either on success, error or cancellation), we remove the local attach and activations in the <code>with_activated_disk</code> function and the remote attach and activation by destroying the datapath on the remote SR. We then remove the persistent state relating to the copy.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;mirror.copy: copy complete local_vdi:%s dest_vdi:%s&#34;</span> vdi dest_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;setting remote=%s/%s content_id &lt;- %s&#34;</span> dest dest_vdi local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Remote.VDI.set_content_id <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>dest_vdi <span style=color:#f92672>~</span>content_id<span style=color:#f92672>:</span>local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* PR-1255: XXX: this is useful because we don&#39;t have content_ids by default *)</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;setting local=%s/%s content_id &lt;- %s&#34;</span> sr local_vdi<span style=color:#f92672>.</span>vdi local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Local.VDI.set_content_id <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>local_vdi<span style=color:#f92672>.</span>vdi <span style=color:#f92672>~</span>content_id<span style=color:#f92672>:</span>local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Vdi_info</span> remote_vdi<span style=color:#f92672>)</span></span></span></code></pre></div><p>The last thing we do is to set the local and remote content_id. The local set_content_id is there because the content_id of the VDI is constructed from the location if it is unset in the <a href=https://github.com/xapi-project/xen-api/blob/3bf897b3accfc172f365689c3c6927746e059177/ocaml/xapi/storage_access.ml#L69-L72 target=_blank>storage_access.ml</a> module of xapi (still part of the storage layer)</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    error <span style=color:#e6db74>&#34;Caught %s: performing cleanup actions&#34;</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    perform_cleanup_actions <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> e</span></span></code></pre></div><p>Here we perform the list of cleanup operations. Theoretically. It seems we don&rsquo;t ever actually set this to anything, so this is dead code.</p><h4 id=datamirrorstart>DATA.MIRROR.start</h4><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> start&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;Mirror.start sr:%s vdi:%s url:%s dest:%s&#34;</span> sr vdi url dest<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  SMPERF.debug <span style=color:#e6db74>&#34;mirror.start called sr:%s vdi:%s url:%s dest:%s&#34;</span> sr vdi url dest<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_url <span style=color:#f92672>=</span> Http.Url.of_string url <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Remote</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Client</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> rpc <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> <span style=color:#f92672>~</span>dststr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;dst_smapiv2&#34;</span> remote_url <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Find the local VDI *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> Local.SR.scan <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> vdi<span style=color:#f92672>)</span> vdis
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Not_found</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Local VDI %s not found&#34;</span> vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>As with the previous calls, we make a remote module for SMAPIv2 calls on the destination, and we find local VDI metadata via <code>SR.scan</code></p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> State.mirror_id_of <span style=color:#f92672>(</span>sr<span style=color:#f92672>,</span>local_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Mirror ids are deterministically constructed.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* A list of cleanup actions to perform if the operation should fail. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> on_fail <span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>unit</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>unit</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span> ref <span style=color:#f92672>=</span> ref [] <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This <code>on_fail</code> list is actually used.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> similar_vdis <span style=color:#f92672>=</span> Local.VDI.similar_content <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> similars <span style=color:#f92672>=</span> List.filter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x <span style=color:#f92672>&lt;&gt;</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>(</span>List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vdi <span style=color:#f92672>-&gt;</span> vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>)</span> similar_vdis<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Similar VDIs to %s = [ %s ]&#34;</span> vdi <span style=color:#f92672>(</span>String.concat <span style=color:#e6db74>&#34;; &#34;</span> <span style=color:#f92672>(</span>List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> Printf.sprintf <span style=color:#e6db74>&#34;(vdi=%s,content_id=%s)&#34;</span> x<span style=color:#f92672>.</span>vdi x<span style=color:#f92672>.</span>content_id<span style=color:#f92672>)</span> similar_vdis<span style=color:#f92672>));</span></span></span></code></pre></div><p>As with copy we look locally for similar VDIs. However, rather than use that here we actually pass this information on to the destination SR via the <code>receive_start</code> internal SMAPIv2 call:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result_ty <span style=color:#f92672>=</span> Remote.DATA.MIRROR.receive_start <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:</span>local_vdi <span style=color:#f92672>~</span>id <span style=color:#f92672>~</span>similar<span style=color:#f92672>:</span>similars <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> result_ty <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        Mirror.<span style=color:#a6e22e>Vhd_mirror</span> x <span style=color:#f92672>-&gt;</span> x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This gives the destination SR a chance to say what sort of migration it can support. We only support <code>Vhd_mirror</code> style migrations which require the destination to support the <code>compose</code> SMAPIv2 operation. The type of <code>x</code> is a record:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> mirror_receive_result_vhd_t <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	mirror_vdi <span style=color:#f92672>:</span> vdi_info<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	mirror_datapath <span style=color:#f92672>:</span> dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	copy_diffs_from <span style=color:#f92672>:</span> content_id option<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	copy_diffs_to <span style=color:#f92672>:</span> vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	dummy_vdi <span style=color:#f92672>:</span> vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p>Field descriptions:</p><ul><li><code>mirror_vdi</code> is the VDI to which new writes should be mirrored.</li><li><code>mirror_datapath</code> is the remote datapath on which the VDI has been attached and activated. This is required to construct the remote NBD url</li><li><code>copy_diffs_from</code> represents the source base VDI to be used for the non-mirrored data copy.</li><li><code>copy_diffs_to</code> is the remote VDI to copy those diffs to</li><li><code>dummy_vdi</code> exists to prevent leaf-coalesce on the <code>mirror_vdi</code></li></ul><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#75715e>(* Enable mirroring on the local machine *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mirror_dp <span style=color:#f92672>=</span> result<span style=color:#f92672>.</span>Mirror.mirror_datapath <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> uri <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;/services/SM/nbd/%s/%s/%s&#34;</span> dest result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi mirror_dp<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dest_url <span style=color:#f92672>=</span> Http.Url.set_uri remote_url uri <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> request <span style=color:#f92672>=</span> Http.Request.make <span style=color:#f92672>~</span>query<span style=color:#f92672>:(</span>Http.Url.get_query_params dest_url<span style=color:#f92672>)</span> <span style=color:#f92672>~</span>version<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;1.0&#34;</span> <span style=color:#f92672>~</span>user_agent<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> Http.<span style=color:#a6e22e>Put</span> uri <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> transport <span style=color:#f92672>=</span> Xmlrpc_client.transport_of_url dest_url <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This is where we connect to the NBD server on the destination.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Searching for data path: %s&#34;</span> dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> attach_info <span style=color:#f92672>=</span> Local.DP.attach_info <span style=color:#f92672>~</span>dbg<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;nbd&#34;</span> <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>dp <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Got it!&#34;</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>we need the local <code>attach_info</code> to find the local tapdisk so we can send it the connected NBD socket.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    on_fail <span style=color:#f92672>:=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> Remote.DATA.MIRROR.receive_cancel <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>)</span> <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span></span></span></code></pre></div><p>This should probably be set directly after the call to <code>receive_start</code></p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tapdev <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> tapdisk_of_attach_info attach_info <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> tapdev <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        debug <span style=color:#e6db74>&#34;Got tapdev&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> pid <span style=color:#f92672>=</span> Tapctl.get_tapdisk_pid tapdev <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> path <span style=color:#f92672>=</span> Printf.sprintf <span style=color:#e6db74>&#34;/var/run/blktap-control/nbdclient%d&#34;</span> pid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        with_transport transport <span style=color:#f92672>(</span>with_http request <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>response<span style=color:#f92672>,</span> s<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            debug <span style=color:#e6db74>&#34;Here inside the with_transport&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> control_fd <span style=color:#f92672>=</span> Unix.socket Unix.<span style=color:#a6e22e>PF_UNIX</span> Unix.<span style=color:#a6e22e>SOCK_STREAM</span> 0 <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            finally
</span></span><span style=display:flex><span>              <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                 debug <span style=color:#e6db74>&#34;Connecting to path: %s&#34;</span> path<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                 Unix.connect control_fd <span style=color:#f92672>(</span>Unix.<span style=color:#a6e22e>ADDR_UNIX</span> path<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>let</span> msg <span style=color:#f92672>=</span> dp <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>let</span> len <span style=color:#f92672>=</span> String.length msg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>let</span> written <span style=color:#f92672>=</span> Unixext.send_fd control_fd msg 0 len [] s <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                 debug <span style=color:#e6db74>&#34;Sent fd&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>if</span> written <span style=color:#f92672>&lt;&gt;</span> len <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>                   error <span style=color:#e6db74>&#34;Failed to transfer fd to %s&#34;</span> path<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                   failwith <span style=color:#e6db74>&#34;foo&#34;</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                 Unix.close control_fd<span style=color:#f92672>)));</span>
</span></span><span style=display:flex><span>        tapdev
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        failwith <span style=color:#e6db74>&#34;Not attached&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Here we connect to the remote NBD server, then pass that connected fd to the local tapdisk that is using the disk. This fd is passed with a name that is later used to tell tapdisk to start using it - we use the datapath name for this.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Adding to active local mirrors: id=%s&#34;</span> id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> alm <span style=color:#f92672>=</span> State.Send_state.<span style=color:#f92672>({</span>
</span></span><span style=display:flex><span>        url<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        dest_sr<span style=color:#f92672>=</span>dest<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        remote_dp<span style=color:#f92672>=</span>mirror_dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        local_dp<span style=color:#f92672>=</span>dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        mirror_vdi<span style=color:#f92672>=</span>result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        remote_url<span style=color:#f92672>=</span>url<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        tapdev<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        failed<span style=color:#f92672>=</span>false<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        watchdog<span style=color:#f92672>=</span><span style=color:#a6e22e>None</span><span style=color:#f92672>})</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    State.add id <span style=color:#f92672>(</span>State.<span style=color:#a6e22e>Send_op</span> alm<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Added&#34;</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>As for copy we persist some state to disk to say that we&rsquo;re doing a mirror so we can undo any state changes after a toolstack restart.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;About to snapshot VDI = %s&#34;</span> <span style=color:#f92672>(</span>string_of_vdi_info local_vdi<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span> add_to_sm_config local_vdi <span style=color:#e6db74>&#34;mirror&#34;</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;nbd:&#34;</span> <span style=color:#f92672>^</span> dp<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span> add_to_sm_config local_vdi <span style=color:#e6db74>&#34;base_mirror&#34;</span> id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> snapshot <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>      Local.VDI.snapshot <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:</span>local_vdi
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> Storage_interface.<span style=color:#a6e22e>Backend_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> <span style=color:#f92672>_)</span> <span style=color:#66d9ef>when</span> code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;SR_BACKEND_FAILURE_44&#34;</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.sr_source_space_insufficient<span style=color:#f92672>,</span> <span style=color:#f92672>[</span> sr <span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> e
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Done!&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;mirror.start: snapshot created, mirror initiated vdi:%s snapshot_of:%s&#34;</span>
</span></span><span style=display:flex><span>      snapshot<span style=color:#f92672>.</span>vdi local_vdi<span style=color:#f92672>.</span>vdi <span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    on_fail <span style=color:#f92672>:=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> Local.VDI.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>snapshot<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span></span></span></code></pre></div><p>This bit inserts into <code>sm_config</code> the name of the fd we passed earlier to do mirroring. This is interpreted by the python SM backends and passed on the <code>tap-ctl</code> invocation to unpause the disk. This causes all new writes to be mirrored via NBD to the file descriptor passed earlier.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> inner () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        debug <span style=color:#e6db74>&#34;tapdisk watchdog&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> alm_opt <span style=color:#f92672>=</span> State.find_active_local_mirror id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> alm_opt <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> alm <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> stats <span style=color:#f92672>=</span> Tapctl.stats <span style=color:#f92672>(</span>Tapctl.create ()<span style=color:#f92672>)</span> tapdev <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> stats<span style=color:#f92672>.</span>Tapctl.Stats.nbd_mirror_failed <span style=color:#f92672>=</span> 1 <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            Updates.add <span style=color:#f92672>(</span>Dynamic.<span style=color:#a6e22e>Mirror</span> id<span style=color:#f92672>)</span> updates<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          alm<span style=color:#f92672>.</span>State.Send_state.watchdog <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span>Scheduler.one_shot scheduler <span style=color:#f92672>(</span>Scheduler.<span style=color:#a6e22e>Delta</span> 5<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;tapdisk_watchdog&#34;</span> inner<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> ()
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>in</span> inner ()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>This is the watchdog that runs <code>tap-ctl stats</code> every 5 seconds watching <code>mirror_failed</code> for evidence of a failure in the mirroring code. If it detects one the only thing it does is to notify that the state of the mirroring has changed. This will be picked up by the thread in xapi that is monitoring the state of the mirror. It will then issue a <code>MIRROR.stat</code> call which will return the state of the mirror including the information that it has failed.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    on_fail <span style=color:#f92672>:=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> stop <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>)</span> <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* Copy the snapshot to the remote *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> new_parent <span style=color:#f92672>=</span> Storage_task.with_subtask task <span style=color:#e6db74>&#34;copy&#34;</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        copy&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>snapshot<span style=color:#f92672>.</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.copy_diffs_to<span style=color:#f92672>)</span> <span style=color:#f92672>|&gt;</span> vdi_info <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Local VDI %s == remote VDI %s&#34;</span> snapshot<span style=color:#f92672>.</span>vdi new_parent<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span></span></span></code></pre></div><p>This is where we copy the VDI returned by the snapshot invocation to the remote VDI called <code>copy_diffs_to</code>. We only copy deltas, but we rely on <code>copy'</code> to figure out which disk the deltas should be taken from, which it does via the <code>content_id</code> field.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    Remote.VDI.compose <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi1<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.copy_diffs_to <span style=color:#f92672>~</span>vdi2<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Remote.VDI.remove_from_sm_config <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi <span style=color:#f92672>~</span>key<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;base_mirror&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Local VDI %s now mirrored to remote VDI: %s&#34;</span> local_vdi<span style=color:#f92672>.</span>vdi result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span></span></span></code></pre></div><p>Once the copy has finished we invoke the <code>compose</code> SMAPIv2 call that composes the diffs from the mirror with the base image copied from the snapshot.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Destroying dummy VDI %s on remote&#34;</span> result<span style=color:#f92672>.</span>Mirror.dummy_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Remote.VDI.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.dummy_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Destroying snapshot %s on src&#34;</span> snapshot<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Local.VDI.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>snapshot<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Mirror_id</span> id<span style=color:#f92672>)</span></span></span></code></pre></div><p>we can now destroy the dummy vdi on the remote (which will cause a leaf-coalesce in due course), and we destroy the local snapshot here (which will also cause a leaf-coalesce in due course, providing we don&rsquo;t destroy it first). The return value from the function is the mirror_id that we can use to monitor the state or cancel the mirror.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Sr_not_attached</span><span style=color:#f92672>(</span>sr_uuid<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    error <span style=color:#e6db74>&#34; Caught exception %s:%s. Performing cleanup.&#34;</span> Api_errors.sr_not_attached sr_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    perform_cleanup_actions <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.sr_not_attached<span style=color:#f92672>,[</span>sr_uuid<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    error <span style=color:#e6db74>&#34;Caught %s: performing cleanup actions&#34;</span> <span style=color:#f92672>(</span>Api_errors.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    perform_cleanup_actions <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> e</span></span></code></pre></div><p>The exception handler just cleans up afterwards.</p><p>This is not the end of the story, since we need to detach the remote datapath being used for mirroring when we detach this end. The hook function is in <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/storage_migrate.ml#L775-L791 target=_blank>storage_migrate.ml</a>:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> post_detach_hook <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>dp <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> State.<span style=color:#a6e22e>Send_state</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> State.mirror_id_of <span style=color:#f92672>(</span>sr<span style=color:#f92672>,</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  State.find_active_local_mirror id <span style=color:#f92672>|&gt;</span>
</span></span><span style=display:flex><span>  Opt.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> r <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> remote_url <span style=color:#f92672>=</span> Http.Url.of_string r<span style=color:#f92672>.</span>url <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Remote</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Client</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> rpc <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> <span style=color:#f92672>~</span>dststr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;dst_smapiv2&#34;</span> remote_url <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> t <span style=color:#f92672>=</span> Thread.create <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Calling receive_finalize&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          log_and_ignore_exn
</span></span><span style=display:flex><span>            <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> Remote.DATA.MIRROR.receive_finalize <span style=color:#f92672>~</span>dbg<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;Mirror-cleanup&#34;</span> <span style=color:#f92672>~</span>id<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Finished calling receive_finalize&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          State.remove_local_mirror id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Removed active local mirror: %s&#34;</span> id
</span></span><span style=display:flex><span>        <span style=color:#f92672>)</span> () <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      Opt.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> id <span style=color:#f92672>-&gt;</span> Scheduler.cancel scheduler id<span style=color:#f92672>)</span> r<span style=color:#f92672>.</span>watchdog<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Created thread %d to call receive finalize and dp destroy&#34;</span> <span style=color:#f92672>(</span>Thread.id t<span style=color:#f92672>))</span></span></span></code></pre></div><p>This removes the persistent state and calls <code>receive_finalize</code> on the destination. The body of that functions is:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> receive_finalize <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> recv_state <span style=color:#f92672>=</span> State.find_active_receive_mirror id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> State.<span style=color:#a6e22e>Receive_state</span> <span style=color:#66d9ef>in</span> Opt.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> r <span style=color:#f92672>-&gt;</span> Local.DP.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>r<span style=color:#f92672>.</span>leaf_dp <span style=color:#f92672>~</span>allow_leak<span style=color:#f92672>:</span>false<span style=color:#f92672>)</span> recv_state<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  State.remove_receive_mirror id</span></span></code></pre></div><p>which removes the persistent state on the destination and destroys the datapath associated with the mirror.</p><p>Additionally, there is also a pre-deactivate hook. The rationale for this is that we want to detect any failures to write that occur right at the end of the SXM process. So if there is a mirror operation going on, before we deactivate we wait for tapdisk to flush its queue of outstanding requests, then we query whether there has been a mirror failure. The code is just above the detach hook in <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/storage_migrate.ml#L738-L773 target=_blank>storage_migrate.ml</a>:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> pre_deactivate_hook <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> State.<span style=color:#a6e22e>Send_state</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> State.mirror_id_of <span style=color:#f92672>(</span>sr<span style=color:#f92672>,</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> Mtime_clock.counter () <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> get_delta () <span style=color:#f92672>=</span> Mtime_clock.count start <span style=color:#f92672>|&gt;</span> Mtime.Span.to_s <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  State.find_active_local_mirror id <span style=color:#f92672>|&gt;</span>
</span></span><span style=display:flex><span>  Opt.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> s <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(* We used to pause here and then check the nbd_mirror_failed key. Now, we poll
</span></span></span><span style=display:flex><span><span style=color:#75715e>				   until the number of outstanding requests has gone to zero, then check the
</span></span></span><span style=display:flex><span><span style=color:#75715e>				   status. This avoids confusing the backend (CA-128460) *)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Tapctl</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> ctx <span style=color:#f92672>=</span> create () <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> wait () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> get_delta () <span style=color:#f92672>&gt;</span> reqs_outstanding_timeout <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Timeout</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> st <span style=color:#f92672>=</span> stats ctx s<span style=color:#f92672>.</span>tapdev <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> st<span style=color:#f92672>.</span>Stats.reqs_outstanding <span style=color:#f92672>&gt;</span> 0
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>then</span> <span style=color:#f92672>(</span>Thread.delay 1<span style=color:#f92672>.</span>0<span style=color:#f92672>;</span> wait ()<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span> st
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> st <span style=color:#f92672>=</span> wait () <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        debug <span style=color:#e6db74>&#34;Got final stats after waiting %f seconds&#34;</span> <span style=color:#f92672>(</span>get_delta ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> st<span style=color:#f92672>.</span>Stats.nbd_mirror_failed <span style=color:#f92672>=</span> 1
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>          error <span style=color:#e6db74>&#34;tapdisk reports mirroring failed&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          s<span style=color:#f92672>.</span>failed <span style=color:#f92672>&lt;-</span> true
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#a6e22e>Timeout</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        error <span style=color:#e6db74>&#34;Timeout out after %f seconds waiting for tapdisk to complete all outstanding requests&#34;</span> <span style=color:#f92672>(</span>get_delta ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        s<span style=color:#f92672>.</span>failed <span style=color:#f92672>&lt;-</span> true
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        error <span style=color:#e6db74>&#34;Caught exception while finally checking mirror state: %s&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        s<span style=color:#f92672>.</span>failed <span style=color:#f92672>&lt;-</span> true
</span></span><span style=display:flex><span>    <span style=color:#f92672>)</span></span></span></code></pre></div><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=xe-cli-architecture>XE CLI architecture</h1><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>The links in this page point to the source files of xapi
<a href=https://github.com/xapi-project/xen-api/tree/v1.132.0 target=_blank>v1.132.0</a>, not to the
latest source code. Meanwhile, the CLI server code in xapi has been moved to a
library separate from the main xapi binary, and has its own subdirectory
<code>ocaml/xapi-cli-server</code>.</p></div></div><h2 id=architecture>Architecture</h2><ul><li><p><strong>The actual CLI</strong> is a very lightweight binary in
<a href=https://github.com/xapi-project/xen-api/tree/v1.132.0/ocaml/xe-cli target=_blank>ocaml/xe-cli</a></p><ul><li>It is just a dumb client, that does everything that xapi tells
it to do</li><li>This is a security issue<ul><li>We must trust the xenserver that we connect to, because it
can tell xe to read local files, download files, &mldr;</li></ul></li><li>When it is first called, it takes the few command-line arguments
it needs, and then passes the rest to xapi in a HTTP PUT request<ul><li>Each argument is in a separate line</li></ul></li><li>Then it loops doing what xapi tells it to do, in a loop, until
xapi tells it to exit or an exception happens</li></ul></li><li><p><strong>The protocol</strong> description is in
<a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi-cli-protocol/cli_protocol.ml target=_blank>ocaml/xapi-cli-protocol/cli_protocol.ml</a></p><ul><li>The CLI has such a protocol that one binary can talk to multiple
versions of xapi as long as their CLI protocol versions are
compatible</li><li>and the CLI can be changed without updating the xe binary</li><li>and also for performance reasons, it is more efficient this way
than by having a CLI that makes XenAPI calls</li></ul></li><li><p><strong>Xapi</strong></p><ul><li>The HTTP POST request is sent to the <code>/cli</code> URL</li><li>In <code>Xapi.server_init</code>, xapi <a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/xapi.ml#L804 target=_blank>registers the appropriate function
to handle these
requests</a>,
defined in <a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/xapi.ml#L589 target=_blank>common_http_handlers in the same
file</a>:
<code>Xapi_cli.handler</code></li><li>The relevant code is in <code>ocaml/xapi/records.ml</code>,
<code>ocaml/xapi/cli_*.ml</code><ul><li>CLI object definitions are in <code>records.ml</code>, command
definitions in <code>cli_frontend.ml</code> (in
<a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/cli_frontend.ml#L72 target=_blank>cmdtable_data</a>),
implementations of commands in <code>cli_operations.ml</code></li></ul></li><li>When a command is received, it is parsed into a command name and
a parameter list of key-value pairs<ul><li>and the command table
<a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/xapi_cli.ml#L157 target=_blank>is</a>
<a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/cli_frontend.ml#L3005 target=_blank>populated
lazily</a>
from the commands defined in <code>cmdtable_data</code> in
<code>cli_frontend.ml</code>, and <a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/cli_operations.ml#L740 target=_blank>automatically
generated</a>
low-level parameter commands (the ones defined in <a href=http://docs.citrix.com/content/dam/docs/en-us/xenserver/xenserver-7-0/downloads/xenserver-7-0-administrators-guide.pdf target=_blank>section
A.3.2 of the XenServer Administrator&rsquo;s
Guide</a>)
are also added for a list of standard classes</li><li>the command table maps command names to records that contain
the implementation of the command, among other things</li></ul></li><li>Then the command name <a href=https://github.com/xapi-project/xen-api/blob/v1.132.0/ocaml/xapi/xapi_cli.ml#L86 target=_blank>is looked
up</a>
in the command table, and the corresponding operation is
executed with the parsed key-value parameter list passed to it</li></ul></li></ul><h2 id=walk-through-cli-handler-in-xapi-external-calls>Walk-through: CLI handler in xapi (external calls)</h2><h3 id=definitions-for-the-http-handler>Definitions for the HTTP handler</h3><pre><code>Constants.cli_uri = &quot;/cli&quot;

Datamodel.http_actions = [...;
  (&quot;post_cli&quot;, (Post, Constants.cli_uri, false, [], _R_READ_ONLY, []));
...]

(* these public http actions will NOT be checked by RBAC *)
(* they are meant to be used in exceptional cases where RBAC is already *)
(* checked inside them, such as in the XMLRPC (API) calls *)
Datamodel.public_http_actions_with_no_rbac_check` = [...
  &quot;post_cli&quot;;  (* CLI commands -&gt; calls XMLRPC *)
...]

Xapi.common_http_handlers = [...;
  (&quot;post_cli&quot;, (Http_svr.BufIO Xapi_cli.handler));
...]

Xapi.server_init () =
  ...
  &quot;Registering http handlers&quot;, [], (fun () -&gt; List.iter Xapi_http.add_handler common_http_handlers);
  ...
</code></pre><p>Due to there definitions, <code>Xapi_http.add_handler</code> does not perform RBAC checks for <code>post_cli</code>. This means that the CLI handler does not use <code>Xapi_http.assert_credentials_ok</code> when a request comes in, as most other handlers do. The reason is that RBAC checking is delegated to the actual XenAPI calls that are being done by the commands in <code>Cli_operations</code>.</p><p>This means that the <code>Xapi_http.add_handler call</code> so resolves to simply:</p><pre><code>Http_svr.Server.add_handler server Http.Post &quot;/cli&quot; (Http_svr.BufIO Xapi_cli.handler))
</code></pre><p>&mldr;which means that the function <code>Xapi_cli.handler</code> is called directly when an HTTP POST request with path <code>/cli</code> comes in.</p><h3 id=high-level-request-processing>High-level request processing</h3><p><code>Xapi_cli.handler</code>:</p><ul><li>Reads the body of the HTTP request, limitted to <code>Xapi_globs.http_limit_max_cli_size = 200 * 1024</code> characters.</li><li>Sends a protocol version string to the client: <code>"XenSource thin CLI protocol"</code> plus binary encoded major (0) and (2) minor numbers.</li><li>Reads the protocol version from the client and exits with an error if it does not match the above.</li><li>Calls <code>Xapi_cli.parse_session_and_args</code> with the request&rsquo;s body to extract the session ref, if there.</li><li>Calls <code>Cli_frontend.parse_commandline</code> to parse the rest of the command line from the body.</li><li>Calls <code>Xapi_cli.exec_command</code> to execute the command.</li><li>On error, calls <code>exception_handler</code>.</li></ul><p><code>Xapi_cli.parse_session_and_args</code>:</p><ul><li>Is passed the request body and reads it line by line. Each line is considered an argument.</li><li>Removes any CR chars from the end of each argument.</li><li>If the first arg starts with <code>session_id=</code>, the the bit after this prefix is considered to be a session reference.</li><li>Returns the session ref (if there) and (remaining) list of args.</li></ul><p><code>Cli_frontend.parse_commandline</code>:</p><ul><li>Returns the command name and assoc list of param names and values. It handles <code>--name</code> and <code>-flag</code> arguments by turning them into key/value string pairs.</li></ul><p><code>Xapi_cli.exec_command</code>:</p><ul><li>Finds username/password params.</li><li>Get the rpc function: this is the so-called &ldquo;<code>fake_rpc</code> callback&rdquo;, which does not use the network or HTTP at all, but goes straight to <code>Api_server.callback1</code> (the XenAPI RPC entry point). This function is used by the CLI handler to do loopback XenAPI calls.</li><li>Logs the parsed xe command, omitting sensitive data.</li><li>Continues as <code>Xapi_cli.do_rpcs</code></li><li>Looks up the command name in the command table from <code>Cli_frontend</code> (raises an error if not found).</li><li>Checks if all required params have been supplied (raises an error if not).</li><li>Checks that the host is a pool master (raises an error if not).</li><li>Depending on the command, a <code>session.login_with_password</code> or <code>session.slave_local_login_with_password</code> XenAPI call is made with the supplied username and password. If the authentication passes, then a session reference is returned for the RBAC role that belongs to the user. This session is used to do further XenAPI calls.</li><li>Next, the implementation of the command in <code>Cli_operations</code> is executed.</li></ul><h3 id=command-implementations>Command implementations</h3><p>The various commands are implemented in <code>cli_operations.ml</code>. These functions are only called after user authentication has passed (see above). However, RBAC restrictions are only enforced inside any XenAPI calls that are made, and <em>not</em> on any of the other code in <code>cli_operations.ml</code>.</p><p>The type of each command implementation function is as follows (see <code>cli_cmdtable.ml</code>):</p><pre><code>type op =
  Cli_printer.print_fn -&gt;
  (Rpc.call -&gt; Rpc.response) -&gt;
  API.ref_session -&gt; ((string*string) list) -&gt; unit
</code></pre><p>So each function receives a printer for sending text output to the xe client, and rpc function and session reference for doing XenAPI calls, and a key/value pair param list. Here is a typical example:</p><pre><code>let bond_create printer rpc session_id params =
  let network = List.assoc &quot;network-uuid&quot; params in
  let mac = List.assoc_default &quot;mac&quot; params &quot;&quot; in
  let network = Client.Network.get_by_uuid rpc session_id network in
  let pifs = List.assoc &quot;pif-uuids&quot; params in
  let uuids = String.split ',' pifs in
  let pifs = List.map (fun uuid -&gt; Client.PIF.get_by_uuid rpc session_id uuid) uuids in
  let mode = Record_util.bond_mode_of_string (List.assoc_default &quot;mode&quot; params &quot;&quot;) in
  let properties = read_map_params &quot;properties&quot; params in
  let bond = Client.Bond.create rpc session_id network pifs mac mode properties in
  let uuid = Client.Bond.get_uuid rpc session_id bond in
  printer (Cli_printer.PList [ uuid])
</code></pre><ul><li>The necessary parameters are looked up in <code>params</code> using <code>List.assoc</code> or similar.</li><li>UUIDs are translated into reference by <code>get_by_uuid</code> XenAPI calls (note that the <code>Client</code> module is the XenAPI client, and functions in there require the rpc function and session reference).</li><li>Then the main API call is made (<code>Client.Bond.create</code> in this case).</li><li>Further API calls may be made to output data for the client, and passed to the <code>printer</code>.</li></ul><p>This is the common case for CLI operations: they do API calls based on the parameters that were passed in.</p><p>However, other commands are more complicated, for example <code>vm_import/export</code> and <code>vm_migrate</code>. These contain a lot more logic in the CLI commands, and also send commands to the client to instruct it to read or write files and/or do HTTP calls.</p><p>Yet other commands do not actually do any XenAPI calls, but instead get &ldquo;helpful&rdquo; information from other places. Example: <code>diagnostic_gc_stats</code>, which displays statistics from xapi&rsquo;s OCaml GC.</p><h2 id=tutorials>Tutorials</h2><p>The following tutorials show how to extend the CLI (and XenAPI):</p><ul><li><a href=/new-docs/xapi/guides/howtos/add-field/>Adding a field</a></li><li><a href=/new-docs/xapi/guides/howtos/add-function/>Adding an operation</a></li></ul><footer class=footline></footer></article></section></div></main></div><script src=/new-docs/js/clipboard.min.js?1727189834 defer></script><script src=/new-docs/js/perfect-scrollbar.min.js?1727189834 defer></script><script src=/new-docs/js/d3/d3-color.min.js?1727189834 defer></script><script src=/new-docs/js/d3/d3-dispatch.min.js?1727189834 defer></script><script src=/new-docs/js/d3/d3-drag.min.js?1727189834 defer></script><script src=/new-docs/js/d3/d3-ease.min.js?1727189834 defer></script><script src=/new-docs/js/d3/d3-interpolate.min.js?1727189834 defer></script><script src=/new-docs/js/d3/d3-selection.min.js?1727189834 defer></script><script src=/new-docs/js/d3/d3-timer.min.js?1727189834 defer></script><script src=/new-docs/js/d3/d3-transition.min.js?1727189834 defer></script><script src=/new-docs/js/d3/d3-zoom.min.js?1727189834 defer></script><script src=/new-docs/js/js-yaml.min.js?1727189834 defer></script><script src=/new-docs/js/mermaid.min.js?1727189834 defer></script><script>window.themeUseMermaid=JSON.parse("{}")</script><script src=/new-docs/js/theme.js?1727189834 defer></script></body></html>