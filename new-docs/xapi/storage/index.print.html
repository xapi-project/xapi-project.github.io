<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.127.0"><meta name=generator content="Relearn 5.20.0+tip"><meta name=description content><title>XAPI's Storage Layers :: XAPI Toolstack Developer Documentation</title>
<link href=https://xapi-project.github.io/new-docs/xapi/storage/index.html rel=canonical type=text/html title="XAPI's Storage Layers :: XAPI Toolstack Developer Documentation"><link href=/new-docs/xapi/storage/index.xml rel=alternate type=application/rss+xml title="XAPI's Storage Layers :: XAPI Toolstack Developer Documentation"><link href=/new-docs/images/favicon.png?1723537598 rel=icon type=image/png><link href=/new-docs/css/fontawesome-all.min.css?1723537602 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/fontawesome-all.min.css?1723537602 rel=stylesheet></noscript><link href=/new-docs/css/nucleus.css?1723537602 rel=stylesheet><link href=/new-docs/css/auto-complete.css?1723537602 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/auto-complete.css?1723537602 rel=stylesheet></noscript><link href=/new-docs/css/perfect-scrollbar.min.css?1723537602 rel=stylesheet><link href=/new-docs/css/fonts.css?1723537602 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/new-docs/css/fonts.css?1723537602 rel=stylesheet></noscript><link href=/new-docs/css/theme.css?1723537602 rel=stylesheet><link href=/new-docs/css/theme-auto.css?1723537602 rel=stylesheet id=variant-style><link href=/new-docs/css/variant.css?1723537602 rel=stylesheet><link href=/new-docs/css/print.css?1723537602 rel=stylesheet media=print><link href=/new-docs/css/format-print.css?1723537602 rel=stylesheet><link href=/new-docs/css/ie.css?1723537602 rel=stylesheet><script src=/new-docs/js/url.js?1723537602></script><script src=/new-docs/js/variant.js?1723537602></script><script>window.index_js_url="/new-docs/index.search.js";var baseUriFull,root_url="/",baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copy to clipboard",window.T_Copied_to_clipboard="Copied to clipboard!",window.T_Copy_link_to_clipboard="Copy link to clipboard",window.T_Link_copied_to_clipboard="Copied link to clipboard!",window.T_No_results_found='No results found for "{0}"',window.T_N_results_found='{1} results found for "{0}"',baseUriFull="https://xapi-project.github.io/new-docs/",window.variants&&variants.init(["auto","zen-light","zen-dark","red","blue","green","learn","neon","relearn-light","relearn-bright","relearn-dark"])</script><link rel=stylesheet href=https://xapi-project.github.io/new-docs/css/misc.css></head><body class="mobile-support print" data-url=/new-docs/xapi/storage/index.html><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle class=topbar-link title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/new-docs/index.html><span itemprop=name>XAPI Toolstack Developer Guide</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/new-docs/xapi/index.html><span itemprop=name>Xapi</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>XAPI's Storage Layers</span><meta itemprop=position content="3"></li></ol></div></div></nav><main id=body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=xapis-storage-layers>XAPI's Storage Layers</h1><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>The links in this page point to the source files of xapi
<a href=https://github.com/xapi-project/xen-api/tree/v1.127.0 target=_blank>v1.127.0</a>, and xcp-idl
<a href=https://github.com/xapi-project/xcp-idl/tree/v1.62.0 target=_blank>v1.62.0</a>, not to the
latest source code.</p><p>In the beginning of 2023, significant changes have been made in the layering.
In particular, the wrapper code from <code>storage_impl.ml</code> has been pushed down the
stack, below the mux, such that it only covers the SMAPIv1 backend and not
SMAPIv3. Also, all of the code (from xcp-idl etc) is now present in this repo
(xen-api).</p></div></div><p>Xapi directly communicates only with the SMAPIv2 layer. There are no
plugins directly implementing the SMAPIv2 interface, but the plugins in
other layers are accessed through it:</p><div class="mermaid align-center">graph TD
A[xapi] --> B[SMAPIv2 interface]
B --> C[SMAPIv2 &lt;-> SMAPIv1 translation: storage_access.ml]
B --> D[SMAPIv2 &lt;-> SMAPIv3 translation: xapi-storage-script]
C --> E[SMAPIv1 plugins]
D --> F[SMAPIv3 plugins]</div><h2 id=smapiv1>SMAPIv1</h2><p>These are the files related to SMAPIv1 in <code>xen-api/ocaml/xapi/</code>:</p><ul><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/sm.ml target=_blank>sm.ml</a>:
OCaml &ldquo;bindings&rdquo; for the SMAPIv1 Python &ldquo;drivers&rdquo; (SM)</li><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/sm_exec.ml target=_blank>sm_exec.ml</a>:
support for implementing the above &ldquo;bindings&rdquo;. The
parameters are converted to XML-RPC, passed to the relevant python
script (&ldquo;driver&rdquo;), and then the standard output of the program is
parsed as an XML-RPC response (we use
<code>xen-api-libs-transitional/http-svr/xMLRPC.ml</code> for parsing XML-RPC).
When adding new functionality, we can modify <code>type call</code> to add parameters,
but when we don&rsquo;t add any common ones, we should just pass the new
parameters in the args record.</li><li><code>smint.ml</code>: Contains types, exceptions, &mldr; for the SMAPIv1 OCaml
interface</li></ul><h2 id=smapiv2>SMAPIv2</h2><p>These are the files related to SMAPIv2, which need to be modified to
implement new calls:</p><ul><li><a href=https://github.com/xapi-project/xcp-idl/blob/v1.62.0/storage/storage_interface.ml target=_blank>xcp-idl/storage/storage_interface.ml</a>:
Contains the SMAPIv2 interface</li><li><a href=https://github.com/xapi-project/xcp-idl/blob/v1.62.0/storage/storage_skeleton.ml target=_blank>xcp-idl/storage/storage_skeleton.ml</a>:
A stub SMAPIv2 storage server implementation that matches the
SMAPIv2 storage server interface (this is verified by
<a href=https://github.com/xapi-project/xcp-idl/blob/v1.62.0/storage/storage_skeleton_test.ml target=_blank>storage_skeleton_test.ml</a>),
each of its function just raise a <code>Storage_interface.Unimplemented</code>
error. This skeleton is used to automatically fill the unimplemented
methods of the below storage servers to satisfy the interface.</li><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml target=_blank>xen-api/ocaml/xapi/storage_access.ml</a>:
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml#L104 target=_blank>module SMAPIv1</a>:
a SMAPIv2 server that does SMAPIv2 -> SMAPIv1 translation.
It passes the XML-RPC requests as the first command-line argument to the
corresponding Python script, which returns an XML-RPC response on standard
output.</li><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_impl.ml target=_blank>xen-api/ocaml/xapi/storage_impl.ml</a>:
The
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_impl.ml#L302 target=_blank>Wrapper</a>
module wraps a SMAPIv2 server (Server_impl) and takes care of
locking and datapaths (in case of multiple connections (=datapaths)
from VMs to the same VDI, it will use the superstate computed by the
<a href=https://github.com/xapi-project/xcp-idl/blob/v1.62.0/storage/vdi_automaton.ml target=_blank>Vdi_automaton</a>
in xcp-idl). It also implements some functionality, like the <code>DP</code>
module, that is not implemented in lower layers.</li><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_mux.ml target=_blank>xen-api/ocaml/xapi/storage_mux.ml</a>:
A SMAPIv2 server, which multiplexes between other servers. A
different SMAPIv2 server can be registered for each SR. Then it
forwards the calls for each SR to the &ldquo;storage plugin&rdquo; registered
for that SR.</li></ul><h3 id=how-smapiv2-works>How SMAPIv2 works:</h3><p>We use <a href=https://github.com/xapi-project/message-switch target=_blank>message-switch</a> under the hood for RPC communication between
<a href=https://github.com/xapi-project/xcp-idl target=_blank>xcp-idl</a> components. The
main <code>Storage_mux.Server</code> (basically <code>Storage_impl.Wrapper(Mux)</code>) is
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml#L1279 target=_blank>registered to
listen</a>
on the &ldquo;<code>org.xen.xapi.storage</code>&rdquo; queue <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/xapi.ml#L801 target=_blank>during xapi&rsquo;s
startup</a>,
and this is the main entry point for incoming SMAPIv2 function calls.
<code>Storage_mux</code> does not really multiplex between different plugins right
now: <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/xapi.ml#L799 target=_blank>earlier during xapi&rsquo;s
startup</a>,
the same SMAPIv1 storage server module <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml#L934 target=_blank>is
registered</a>
on the various &ldquo;<code>org.xen.xapi.storage.&lt;sr type></code>&rdquo; queues for each
supported SR type. (This will change with SMAPIv3, which is accessed via
a SMAPIv2 plugin outside of xapi that translates between SMAPIv2 and
SMAPIv3.) Then, in
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml#L1531 target=_blank>Storage_access.create_sr</a>,
which is called
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/xapi_sr.ml#L326 target=_blank>during SR.create</a>,
and also
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/xapi_pbd.ml#L121 target=_blank>during PBD.plug</a>,
the relevant &ldquo;<code>org.xen.xapi.storage.&lt;sr type></code>&rdquo; queue needed for that
PBD is <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml#L1107 target=_blank>registered with Storage_mux in
Storage_access.bind</a>
for the SR of that PBD.<br>So basically what happens is that xapi registers itself as a SMAPIv2
server, and forwards incoming function calls to itself through
<code>message-switch</code>, using its <code>Storage_mux</code> module. These calls are
forwarded to xapi&rsquo;s <code>SMAPIv1</code> module doing SMAPIv2 -> SMAPIv1
translation.</p><h4 id=registration-of-the-various-storage-servers>Registration of the various storage servers</h4><div class="mermaid align-center">sequenceDiagram
participant q as message-switch
participant v1 as Storage_access.SMAPIv1
participant svr as Storage_mux.Server
Note over q, svr: xapi startup, "Starting SMAPIv1 proxies"
q ->> v1:org.xen.xapi.storage.sr_type_1
q ->> v1:org.xen.xapi.storage.sr_type_2
q ->> v1:org.xen.xapi.storage.sr_type_3
Note over q, svr: xapi startup, "Starting SM service"
q ->> svr:org.xen.xapi.storage
Note over q, svr: SR.create, PBD.plug
svr ->> q:org.xapi.storage.sr_type_2</div><h4 id=what-happens-when-a-smapiv2-function-is-called>What happens when a SMAPIv2 &ldquo;function&rdquo; is called</h4><div class="mermaid align-center">graph TD
call[SMAPIv2 call] --VDI.attach2--> org.xen.xapi.storage
subgraph message-switch
org.xen.xapi.storage
org.xen.xapi.storage.SR_type_x
end
org.xen.xapi.storage --VDI.attach2--> Storage_impl.Wrapper
subgraph xapi
subgraph Storage_mux.server
Storage_impl.Wrapper --> Storage_mux.mux
end
Storage_access.SMAPIv1
end
Storage_mux.mux --VDI.attach2--> org.xen.xapi.storage.SR_type_x
org.xen.xapi.storage.SR_type_x --VDI.attach2--> Storage_access.SMAPIv1
subgraph SMAPIv1
driver_x[SMAPIv1 driver for SR_type_x]
end
Storage_access.SMAPIv1 --vdi_attach--> driver_x</div><h3 id=interface-changes-backward-compatibility--sxm>Interface Changes, Backward Compatibility, & SXM</h3><p>During SXM, xapi calls SMAPIv2 functions on a remote xapi. Therefore it
is important to keep all those SMAPIv2 functions backward-compatible
that we call remotely (e.g. Remote.VDI.attach), otherwise SXM from an
older to a newer xapi will break.</p><h3 id=functionality-implemented-in-smapiv2-layers>Functionality implemented in SMAPIv2 layers</h3><p>The layer between SMAPIv2 and SMAPIv1 is much fatter than the one between
SMAPIv2 and SMAPIv3. The latter does not do much, apart from simple
translation. However, the former has large portions of code in its intermediate
layers, in addition to the basic SMAPIv2 &lt;-> SMAPIv1 translation in
<code>storage_access.ml</code>.</p><p>These are the three files in xapi that implement the SMAPIv2 storage interface,
from higher to lower level:</p><ul><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_impl.ml target=_blank>xen-api/ocaml/xapi/storage_impl.ml</a>:</li><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_mux.ml target=_blank>xen-api/ocaml/xapi/storage_mux.ml</a>:</li><li><a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml target=_blank>xen-api/ocaml/xapi/storage_access.ml</a>:</li></ul><p>Functionality implemented by higher layers is not implemented by the layers below it.</p><h4 id=extra-functionality-in-storage_implml>Extra functionality in <code>storage_impl.ml</code></h4><p>In addition to its usual functions, <code>Storage_impl.Wrapper</code> also implements the
<code>UPDATES</code> and <code>TASK</code> SMAPIv2 APIs, without calling the wrapped module.</p><p>These are backed by the <code>Updates</code>, <code>Task_server</code>, and <code>Scheduler</code> modules from
xcp-idl, instantiated in xapi&rsquo;s <code>Storage_task</code> module. Migration code in
<code>Storage_mux</code> will interact with these to update task progress. There is also
an event loop in xapi that keeps calling <code>UPDATES.get</code> to keep the tasks in
xapi&rsquo;s database in sync with the storage manager&rsquo;s tasks.</p><p><code>Storage_impl.Wrapper</code> also implements the legacy <code>VDI.attach</code> call by simply
calling the newer <code>VDI.attach2</code> call in the same module. In general, this is a
good place to implement a compatibility layer for deprecated functionality
removed from other layers, because this is the first module that intercepts a
SMAPIv2 call.</p><h4 id=extra-functionality-in-storage_muxml>Extra functionality in <code>storage_mux.ml</code></h4><p><code>Storage_mux</code> implements storage motion (SXM): it implements the <code>DATA</code> and
<code>DATA.MIRROR</code> modules. Migration code will use the <code>Storage_task</code> module to run
the operations and update the task&rsquo;s progress.</p><p>It also implements the <code>Policy</code> module from the SMAPIv2 interface.</p><h2 id=smapiv3>SMAPIv3</h2><p><a href=https://xapi-project.github.io/xapi-storage/ target=_blank>SMAPIv3</a> has a slightly
different interface from SMAPIv2.The
<a href=https://github.com/xapi-project/xapi-storage-script target=_blank>xapi-storage-script</a>
daemon is a SMAPIv2 plugin separate from xapi that is doing the SMAPIv2
↔ SMAPIv3 translation. It keeps the plugins registered with xcp-idl
(their message-switch queues) up to date as their files appear or
disappear from the relevant directory.</p><h3 id=smapiv3-interface>SMAPIv3 Interface</h3><p>The SMAPIv3 interface is defined using an OCaml-based IDL from the
<a href=https://github.com/mirage/ocaml-rpc target=_blank>ocaml-rpc</a> library, and is in this
repo: <a href=https://github.com/xapi-project/xapi-storage target=_blank>https://github.com/xapi-project/xapi-storage</a></p><p>From this interface we generate</p><ul><li>OCaml RPC client bindings used in
<a href=https://github.com/xapi-project/xapi-storage-script target=_blank>xapi-storage-script</a></li><li>The <a href=https://xapi-project.github.io/xapi-storage target=_blank>SMAPIv3 API
reference</a></li><li>Python bindings, used by the SM scripts that implement the SMAPIv3
interface.<ul><li>These bindings are built by running &ldquo;<code>make</code>&rdquo; in the root
<a href=https://github.com/xapi-project/xapi-storage target=_blank>xapi-storage</a>,
and appear in the<code> _build/default/python/xapi/storage/api/v5</code>
directory.</li><li>On a XenServer host, they are stored in the
<code>/usr/lib/python2.7/site-packages/xapi/storage/api/v5/</code>
directory</li></ul></li></ul><h3 id=smapiv3-plugins>SMAPIv3 Plugins</h3><p>For <a href=https://xapi-project.github.io/xapi-storage/ target=_blank>SMAPIv3</a> we have
volume plugins to manipulate SRs and volumes (=VDIs) in them, and
datapath plugins for connecting to the volumes. Volume plugins tell us
which datapath plugins we can use with each volume, and what to pass to
the plugin. Both volume and datapath plugins implement some common
functionality: the SMAPIv3 <a href=https://xapi-project.github.io/xapi-storage/#plugin target=_blank>plugin
interface</a>.</p><h3 id=how-smapiv3-works>How SMAPIv3 works:</h3><p>The <code>xapi-storage-script</code> daemon detects volume and datapath plugins
stored in subdirectories of the
<code>/usr/libexec/xapi-storage-script/volume/</code> and
<code>/usr/libexec/xapi-storage-script/datapath/</code> directories, respectively.
When it finds a new datapath plugin, it adds the plugin to a lookup table and
uses it the next time that datapath is required. When it finds a new volume
plugin, it binds a new <a href=https://github.com/xapi-project/message-switch target=_blank>message-switch</a> queue named after the plugin&rsquo;s
subdirectory to a new server instance that uses these volume scripts.</p><p>To invoke a SMAPIv3 method, it executes a program named
<code>&lt;Interface name>.&lt;function name></code> in the plugin&rsquo;s directory, for
example
<code>/usr/libexec/xapi-storage-script/volume/org.xen.xapi.storage.gfs2/SR.ls</code>.
The inputs to each script can be passed as command-line arguments and
are type-checked using the generated Python bindings, and so are the
outputs. The URIs of the SRs that xapi-storage-script knows about are
stored in the <code>/var/run/nonpersistent/xapi-storage-script/state.db</code>
file, these URIs can be used on the command line when an sr argument is
expected.<code></code></p><h4 id=registration-of-the-various-smapiv3-plugins>Registration of the various SMAPIv3 plugins</h4><div class="mermaid align-center">sequenceDiagram
participant q as message-switch
participant v1 as (Storage_access.SMAPIv1)
participant svr as Storage_mux.Server
participant vol_dir as /../volume/
participant dp_dir as /../datapath/
participant script as xapi-storage-script
Note over script, vol_dir: xapi-storage-script startup
script ->> vol_dir: new subdir org.xen.xapi.storage.sr_type_4
q ->> script: org.xen.xapi.storage.sr_type_4
script ->> dp_dir: new subdir sr_type_4_dp
Note over q, svr: xapi startup, "Starting SMAPIv1 proxies"
q -->> v1:org.xen.xapi.storage.sr_type_1
q -->> v1:org.xen.xapi.storage.sr_type_2
q -->> v1:org.xen.xapi.storage.sr_type_3
Note over q, svr: xapi startup, "Starting SM service"
q ->> svr:org.xen.xapi.storage
Note over q, svr: SR.create, PBD.plug
svr ->> q:org.xapi.storage.sr_type_4</div><h4 id=what-happens-when-a-smapiv3-function-is-called>What happens when a SMAPIv3 &ldquo;function&rdquo; is called</h4><div class="mermaid align-center">graph TD
call[SMAPIv2 call] --VDI.attach2--> org.xen.xapi.storage
subgraph message-switch
org.xen.xapi.storage
org.xen.xapi.storage.SR_type_x
end
org.xen.xapi.storage --VDI.attach2--> Storage_impl.Wrapper
subgraph xapi
subgraph Storage_mux.server
Storage_impl.Wrapper --> Storage_mux.mux
end
Storage_access.SMAPIv1
end
Storage_mux.mux --VDI.attach2--> org.xen.xapi.storage.SR_type_x
org.xen.xapi.storage.SR_type_x -."VDI.attach2".-> Storage_access.SMAPIv1
subgraph SMAPIv1
driver_x[SMAPIv1 driver for SR_type_x]
end
Storage_access.SMAPIv1 -.vdi_attach.-> driver_x
subgraph SMAPIv3
xapi-storage-script --Datapath.attach--> v3_dp_plugin_x
subgraph SMAPIv3 plugins
v3_vol_plugin_x[volume plugin for SR_type_x]
v3_dp_plugin_x[datapath plugin for SR_type_x]
end
end
org.xen.xapi.storage.SR_type_x --VDI.attach2-->xapi-storage-script</div><h2 id=error-reporting>Error reporting</h2><p>In our SMAPIv1 OCaml &ldquo;bindings&rdquo; in xapi
(<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/sm_exec.ml target=_blank>xen-api/ocaml/xapi/sm_exec.ml</a>),
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/sm_exec.ml#L199 target=_blank>when we inspect the error codes returned from a call to
SM</a>,
we translate some of the SMAPIv1/SM error codes to XenAPI errors, and
for others, we just <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/sm_exec.ml#L214 target=_blank>construct an error
code</a>
of the form <code>SR_BACKEND_FAILURE_&lt;SM error number></code>.</p><p>The file
<a href=https://github.com/xapi-project/xcp-idl/blob/v1.62.0/storage/storage_interface.ml#L362 target=_blank>xcp-idl/storage/storage_interface.ml</a>
defines a number of SMAPIv2 errors, ultimately all errors from the various
SMAPIv2 storage servers in xapi will be returned as one of these. Most of the
errors aren&rsquo;t converted into a specific exception in <code>Storage_interface</code>, but
are simply wrapped with <code>Storage_interface.Backend_error</code>.</p><p>The
<a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/storage_access.ml#L29 target=_blank>Storage_access.transform_storage_exn</a>
function is used by the client code in xapi to translate the SMAPIv2
errors into XenAPI errors again, this unwraps the errors wrapped with
<code>Storage_interface.Backend_error</code>.</p><h2 id=message-forwarding>Message Forwarding</h2><p>In the message forwarding layer, first we check the validity of VDI
operations using <code>mark_vdi</code> and <code>mark_sr</code>. These first check that the
operation is valid operations,
using <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/xapi_vdi.ml#L57 target=_blank>Xapi_vdi.check_operation_error</a>,
for <code>mark_vdi</code>, which also inspects the current operations of the VDI,
and then, if the operation is valid, it is added to the VDI&rsquo;s current
operations, and update_allowed_operations is called. Then we forward
the VDI operation to a suitable host that has a PBD plugged for the
VDI&rsquo;s SR.</p><h3 id=checking-that-the-sr-is-attached>Checking that the SR is attached</h3><p>For the VDI operations, we check at two different places whether the SR
is attached: first, at the Xapi level, <a href=https://github.com/xapi-project/xen-api/blob/v1.127.0/ocaml/xapi/xapi_vdi.ml#L98 target=_blank>in
Xapi_vdi.check_operation_error</a>,
for the resize operation, and then, at the SMAPIv1 level, in
<code>Sm.assert_pbd_is_plugged</code>. <code>Sm.assert_pbd_is_plugged</code> performs the
same checks, plus it checks that the PBD is attached to the localhost,
unlike Xapi_vdi.check_operation_error. This behaviour is correct,
because <code>Xapi_vdi.check_operation_error</code> is called from the message
forwarding layer, which forwards the call to a host that has the SR
attached.</p><h2 id=vdi-identifiers-and-storage-motion>VDI Identifiers and Storage Motion</h2><ul><li>VDI &ldquo;location&rdquo;: this is the VDI identifier used by the SM backend.
It is usually the UUID of the VDI, but for ISO SRs it is the name of
the ISO.</li><li>VDI &ldquo;content_id&rdquo;: this is used for storage motion, to reduce the
amount of data copied. When we copy over a VDI, the content_id will
initially be the same. However, when we attach a VDI as read-write,
and then detach it, then we will blank its content_id (set it to a
random UUID), because we may have written to it, so the content
could be different. .</li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of XAPI's Storage Layers</h1><article class=default><header class=headline></header><h1 id=storage-migration>Storage migration</h1><h2 id=overview>Overview</h2><div class="mermaid align-left">sequenceDiagram
participant local_tapdisk as local tapdisk
participant local_smapiv2 as local SMAPIv2
participant xapi
participant remote_xapi as remote xapi
participant remote_smapiv2 as remote SMAPIv2 (might redirect)
participant remote_tapdisk as remote tapdisk
Note over xapi: Sort VDIs increasingly by size and then age
loop VM's & snapshots' VDIs & suspend images
xapi->>remote_xapi: plug dest SR to dest host and pool master
alt VDI is not mirrored
Note over xapi: We don't mirror RO VDIs & VDIs of snapshots
xapi->>local_smapiv2: DATA.copy remote_sm_url
activate local_smapiv2
local_smapiv2-->>local_smapiv2: SR.scan
local_smapiv2-->>local_smapiv2: VDI.similar_content
local_smapiv2-->>remote_smapiv2: SR.scan
Note over local_smapiv2: Find nearest smaller remote VDI remote_base, if any
alt remote_base
local_smapiv2-->>remote_smapiv2: VDI.clone
local_smapiv2-->>remote_smapiv2: VDI.resize
else no remote_base
local_smapiv2-->>remote_smapiv2: VDI.create
end
Note over local_smapiv2: call copy'
activate local_smapiv2
local_smapiv2-->>remote_smapiv2: SR.list
local_smapiv2-->>remote_smapiv2: SR.scan
Note over local_smapiv2: create new datapaths remote_dp, base_dp, leaf_dp
Note over local_smapiv2: find local base_vdi with same content_id as dest, if any
local_smapiv2-->>remote_smapiv2: VDI.attach2 remote_dp dest
local_smapiv2-->>remote_smapiv2: VDI.activate remote_dp dest
opt base_vdi
local_smapiv2-->>local_smapiv2: VDI.attach2 base_dp base_vdi
local_smapiv2-->>local_smapiv2: VDI.activate base_dp base_vdi
end
local_smapiv2-->>local_smapiv2: VDI.attach2 leaf_dp vdi
local_smapiv2-->>local_smapiv2: VDI.activate leaf_dp vdi
local_smapiv2-->>remote_xapi: sparse_dd base_vdi vdi dest [NBD URI for dest & remote_dp]
Note over remote_xapi: HTTP handler verifies credentials
remote_xapi-->>remote_tapdisk: then passes connection to tapdisk's NBD server
local_smapiv2-->>local_smapiv2: VDI.deactivate leaf_dp vdi
local_smapiv2-->>local_smapiv2: VDI.detach leaf_dp vdi
opt base_vdi
local_smapiv2-->>local_smapiv2: VDI.deactivate base_dp base_vdi
local_smapiv2-->>local_smapiv2: VDI.detach base_dp base_vdi
end
local_smapiv2-->>remote_smapiv2: DP.destroy remote_dp
deactivate local_smapiv2
local_smapiv2-->>remote_smapiv2: VDI.snapshot remote_copy
local_smapiv2-->>remote_smapiv2: VDI.destroy remote_copy
local_smapiv2->>xapi: task(snapshot)
deactivate local_smapiv2
else VDI is mirrored
Note over xapi: We mirror RW VDIs of the VM
Note over xapi: create new datapath dp
xapi->>local_smapiv2: VDI.attach2 dp
xapi->>local_smapiv2: VDI.activate dp
xapi->>local_smapiv2: DATA.MIRROR.start dp remote_sm_url
activate local_smapiv2
Note over local_smapiv2: copy disk data & mirror local writes
local_smapiv2-->>local_smapiv2: SR.scan
local_smapiv2-->>local_smapiv2: VDI.similar_content
local_smapiv2-->>remote_smapiv2: DATA.MIRROR.receive_start similars
activate remote_smapiv2
remote_smapiv2-->>local_smapiv2: mirror_vdi,mirror_dp,copy_diffs_from,copy_diffs_to,dummy_vdi
deactivate remote_smapiv2
local_smapiv2-->>local_smapiv2: DP.attach_info dp
local_smapiv2-->>remote_xapi: connect to [NBD URI for mirror_vdi & mirror_dp]
Note over remote_xapi: HTTP handler verifies credentials
remote_xapi-->>remote_tapdisk: then passes connection to tapdisk's NBD server
local_smapiv2-->>local_tapdisk: pass socket & dp to tapdisk of dp
local_smapiv2-->>local_smapiv2: VDI.snapshot local_vdi [mirror:dp]
local_smapiv2-->>local_tapdisk: [Python] unpause disk, pass dp
local_tapdisk-->>remote_tapdisk: mirror new writes via NBD to socket
Note over local_smapiv2: call copy' snapshot copy_diffs_to
local_smapiv2-->>remote_smapiv2: VDI.compose copy_diffs_to mirror_vdi
local_smapiv2-->>remote_smapiv2: VDI.remove_from_sm_config mirror_vdi base_mirror
local_smapiv2-->>remote_smapiv2: VDI.destroy dummy_vdi
local_smapiv2-->>local_smapiv2: VDI.destroy snapshot
local_smapiv2->>xapi: task(mirror ID)
deactivate local_smapiv2
xapi->>local_smapiv2: DATA.MIRROR.stat
activate local_smapiv2
local_smapiv2->>xapi: dest_vdi
deactivate local_smapiv2
end
loop until task finished
xapi->>local_smapiv2: UPDATES.get
xapi->>local_smapiv2: TASK.stat
end
xapi->>local_smapiv2: TASK.stat
xapi->>local_smapiv2: TASK.destroy
end
opt for snapshot VDIs
xapi->>local_smapiv2: SR.update_snapshot_info_src remote_sm_url
activate local_smapiv2
local_smapiv2-->>remote_smapiv2: SR.update_snapshot_info_dest
deactivate local_smapiv2
end
Note over xapi: ...
Note over xapi: reserve resources for the new VM in dest host
loop all VDIs
opt VDI is mirrored
xapi->>local_smapiv2: DP.destroy dp
end
end
opt post_detach_hook
opt active local mirror
local_smapiv2-->>remote_smapiv2: DATA.MIRROR.receive_finalize [mirror ID]
Note over remote_smapiv2: destroy mirror dp
end
end
Note over xapi: memory image migration by xenopsd
Note over xapi: destroy the VM record</div><h3 id=receiving-sxm>Receiving SXM</h3><p>These are the remote calls in the above diagram sent from the remote host to
the receiving end of storage motion:</p><ul><li>Remote SMAPIv2 -> local SMAPIv2 RPC calls:<ul><li><code>SR.list</code></li><li><code>SR.scan</code></li><li><code>SR.update_snapshot_info_dest</code></li><li><code>VDI.attach2</code></li><li><code>VDI.activate</code></li><li><code>VDI.snapshot</code></li><li><code>VDI.destroy</code></li><li>For copying:<ul><li>For copying from base:<ul><li><code>VDI.clone</code></li><li><code>VDI.resize</code></li></ul></li><li>For copying without base:<ul><li><code>VDI.create</code></li></ul></li></ul></li><li>For mirroring:<ul><li><code>DATA.MIRROR.receive_start</code></li><li><code>VDI.compose</code></li><li><code>VDI.remove_from_sm_config</code></li><li><code>DATA.MIRROR.receive_finalize</code></li></ul></li></ul></li><li>HTTP requests to xapi:<ul><li>Connecting to NBD URI via xapi&rsquo;s HTTP handler</li></ul></li></ul><hr><p>This is how xapi coordinates storage migration. We&rsquo;ll do it as a code walkthrough through the two layers: xapi and storage-in-xapi (SMAPIv2).</p><h2 id=xapi-code>Xapi code</h2><p>The entry point is in <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/xapi_vm_migrate.ml#L786 target=_blank>xapi_vm_migration.ml</a></p><p>The function takes several arguments:</p><ul><li>a vm reference (<code>vm</code>)</li><li>a dictionary of <code>(string * string)</code> key-value pairs about the destination (<code>dest)</code>. This is the result of a previous call to the destination pool, <code>Host.migrate_receive</code></li><li><code>live</code>, a boolean of whether we should live-migrate or suspend-resume,</li><li><code>vdi_map</code>, a mapping of VDI references to destination SR references,</li><li><code>vif_map</code>, a mapping of VIF references to destination network references,</li><li><code>vgpu_map</code>, similar for VGPUs</li><li><code>options</code>, another dictionary of options</li></ul><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> migrate_send&#39;  <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>live <span style=color:#f92672>~</span>vdi_map <span style=color:#f92672>~</span>vif_map <span style=color:#f92672>~</span>vgpu_map <span style=color:#f92672>~</span>options <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  SMPERF.debug <span style=color:#e6db74>&#34;vm.migrate_send called vm:%s&#34;</span> <span style=color:#f92672>(</span>Db.VM.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Xapi_xenops</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> localhost <span style=color:#f92672>=</span> Helpers.get_localhost <span style=color:#f92672>~__</span>context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote <span style=color:#f92672>=</span> remote_of_dest dest <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Copy mode means we don&#39;t destroy the VM on the source host. We also don&#39;t
</span></span></span><span style=display:flex><span><span style=color:#75715e>     	   copy over the RRDs/messages *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> copy <span style=color:#f92672>=</span> <span style=color:#66d9ef>try</span> bool_of_string <span style=color:#f92672>(</span>List.assoc <span style=color:#e6db74>&#34;copy&#34;</span> options<span style=color:#f92672>)</span> <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> false <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>It begins by getting the local host reference, deciding whether we&rsquo;re copying or moving, and converting the input <code>dest</code> parameter from an untyped string association list to a typed record, <code>remote</code>, which is declared further up the file:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> remote <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  rpc <span style=color:#f92672>:</span> Rpc.call <span style=color:#f92672>-&gt;</span> Rpc.response<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  session <span style=color:#f92672>:</span> API.ref_session<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  sm_url <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  xenops_url <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  master_url <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  remote_ip <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span> <span style=color:#75715e>(* IP address *)</span>
</span></span><span style=display:flex><span>  remote_master_ip <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span> <span style=color:#75715e>(* IP address *)</span>
</span></span><span style=display:flex><span>  dest_host <span style=color:#f92672>:</span> API.ref_host<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p>this contains:</p><ul><li>A function, <code>rpc</code>, for calling XenAPI RPCs on the destination</li><li>A <code>session</code> valid on the destination</li><li>A <code>sm_url</code> on which SMAPIv2 APIs can be called on the destination</li><li>A <code>master_url</code> on which XenAPI commands can be called (not currently used)</li><li>The IP address, <code>remote_ip</code>, of the destination host</li><li>The IP address, <code>remote_master_ip</code>, of the master of the destination pool</li></ul><p>Next, we determine which VDIs to copy:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* The first thing to do is to create mirrors of all the disks on the remote.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     We look through the VM&#39;s VBDs and all of those of the snapshots. We then
</span></span></span><span style=display:flex><span><span style=color:#75715e>     compile a list of all of the associated VDIs, whether we mirror them or not
</span></span></span><span style=display:flex><span><span style=color:#75715e>     (mirroring means we believe the VDI to be active and new writes should be
</span></span></span><span style=display:flex><span><span style=color:#75715e>     mirrored to the destination - otherwise we just copy it)
</span></span></span><span style=display:flex><span><span style=color:#75715e>     We look at the VDIs of the VM, the VDIs of all of the snapshots, and any
</span></span></span><span style=display:flex><span><span style=color:#75715e>     suspend-image VDIs. *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vm_uuid <span style=color:#f92672>=</span> Db.VM.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vbds <span style=color:#f92672>=</span> Db.VM.get_VBDs <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vifs <span style=color:#f92672>=</span> Db.VM.get_VIFs <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> snapshots <span style=color:#f92672>=</span> Db.VM.get_snapshots <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vm_and_snapshots <span style=color:#f92672>=</span> vm <span style=color:#f92672>::</span> snapshots <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> snapshots_vbds <span style=color:#f92672>=</span> List.flatten <span style=color:#f92672>(</span>List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span> Db.VM.get_VBDs <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>)</span> snapshots<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> snapshot_vifs <span style=color:#f92672>=</span> List.flatten <span style=color:#f92672>(</span>List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span> Db.VM.get_VIFs <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>)</span> snapshots<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>we now decide whether we&rsquo;re intra-pool or not, and if we&rsquo;re intra-pool whether we&rsquo;re migrating onto the same host (localhost migrate). Intra-pool is decided by trying to do a lookup of our current host uuid on the destination pool.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> is_intra_pool <span style=color:#f92672>=</span> <span style=color:#66d9ef>try</span> ignore<span style=color:#f92672>(</span>Db.Host.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>);</span> true <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> false <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> is_same_host <span style=color:#f92672>=</span> is_intra_pool <span style=color:#f92672>&amp;&amp;</span> remote<span style=color:#f92672>.</span>dest_host <span style=color:#f92672>==</span> localhost <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> copy <span style=color:#f92672>&amp;&amp;</span> is_intra_pool <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.operation_not_allowed<span style=color:#f92672>,</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;Copy mode is disallowed on intra pool storage migration, try efficient alternatives e.g. VM.copy/clone.&#34;</span><span style=color:#f92672>]));</span></span></span></code></pre></div><p>Having got all of the VBDs of the VM, we now need to find the associated VDIs, filtering out empty CDs, and decide whether we&rsquo;re going to copy them or mirror them - read-only VDIs can be copied but RW VDIs must be mirrored.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vms_vdis <span style=color:#f92672>=</span> List.filter_map <span style=color:#f92672>(</span>vdi_filter <span style=color:#f92672>__</span>context true<span style=color:#f92672>)</span> vbds <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>where <code>vdi_filter</code> is defined earler:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* We ignore empty or CD VBDs - nothing to do there. Possible redundancy here:
</span></span></span><span style=display:flex><span><span style=color:#75715e>   I don&#39;t think any VBDs other than CD VBDs can be &#39;empty&#39; *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> vdi_filter <span style=color:#f92672>__</span>context allow_mirror vbd <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> Db.VBD.get_empty <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#f92672>||</span> Db.VBD.get_type <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#f92672>=</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>CD</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>then</span> <span style=color:#a6e22e>None</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> do_mirror <span style=color:#f92672>=</span> allow_mirror <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>(</span>Db.VBD.get_mode <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#f92672>=</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>RW</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vm <span style=color:#f92672>=</span> Db.VBD.get_VM <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vdi <span style=color:#f92672>=</span> Db.VBD.get_VDI <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span>get_vdi_mirror <span style=color:#f92672>__</span>context vm vdi do_mirror<span style=color:#f92672>)</span></span></span></code></pre></div><p>This in turn calls <code>get_vdi_mirror</code> which gathers together some important info:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> get_vdi_mirror <span style=color:#f92672>__</span>context vm vdi do_mirror <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> snapshot_of <span style=color:#f92672>=</span> Db.VDI.get_snapshot_of <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> size <span style=color:#f92672>=</span> Db.VDI.get_virtual_size <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> xenops_locator <span style=color:#f92672>=</span> Xapi_xenops.xenops_vdi_locator <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> location <span style=color:#f92672>=</span> Db.VDI.get_location <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dp <span style=color:#f92672>=</span> Storage_access.presentative_datapath_of_vbd <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> sr <span style=color:#f92672>=</span> Db.SR.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:(</span>Db.VDI.get_SR <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>{</span>vdi<span style=color:#f92672>;</span> dp<span style=color:#f92672>;</span> location<span style=color:#f92672>;</span> sr<span style=color:#f92672>;</span> xenops_locator<span style=color:#f92672>;</span> size<span style=color:#f92672>;</span> snapshot_of<span style=color:#f92672>;</span> do_mirror<span style=color:#f92672>}</span></span></span></code></pre></div><p>The record is helpfully commented above:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> vdi_mirror <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  vdi <span style=color:#f92672>:</span> <span style=color:#f92672>[</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>VDI</span> <span style=color:#f92672>]</span> API.Ref.t<span style=color:#f92672>;</span>           <span style=color:#75715e>(* The API reference of the local VDI *)</span>
</span></span><span style=display:flex><span>  dp <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>                        <span style=color:#75715e>(* The datapath the VDI will be using if the VM is running *)</span>
</span></span><span style=display:flex><span>  location <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>                  <span style=color:#75715e>(* The location of the VDI in the current SR *)</span>
</span></span><span style=display:flex><span>  sr <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>                        <span style=color:#75715e>(* The VDI&#39;s current SR uuid *)</span>
</span></span><span style=display:flex><span>  xenops_locator <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>            <span style=color:#75715e>(* The &#39;locator&#39; xenops uses to refer to the VDI on the current host *)</span>
</span></span><span style=display:flex><span>  size <span style=color:#f92672>:</span> Int64.t<span style=color:#f92672>;</span>                     <span style=color:#75715e>(* Size of the VDI *)</span>
</span></span><span style=display:flex><span>  snapshot_of <span style=color:#f92672>:</span> <span style=color:#f92672>[</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>VDI</span> <span style=color:#f92672>]</span> API.Ref.t<span style=color:#f92672>;</span>   <span style=color:#75715e>(* API&#39;s snapshot_of reference *)</span>
</span></span><span style=display:flex><span>  do_mirror <span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span><span style=color:#f92672>;</span>                   <span style=color:#75715e>(* Whether we should mirror or just copy the VDI *)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p><code>xenops_locator</code> is <code>&lt;sr uuid>/&lt;vdi uuid></code>, and <code>dp</code> is <code>vbd/&lt;domid>/&lt;device></code> if the VM is running and <code>vbd/&lt;vm_uuid>/&lt;vdi_uuid></code> if not.</p><p>So now we have a list of these records for all VDIs attached to the VM. For these we check explicitly that they&rsquo;re all defined in the <code>vdi_map</code>, the mapping of VDI references to their destination SR references.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  check_vdi_map <span style=color:#f92672>~__</span>context vms_vdis vdi_map<span style=color:#f92672>;</span></span></span></code></pre></div><p>We then figure out the VIF map:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span> <span style=color:#66d9ef>let</span> vif_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> is_intra_pool <span style=color:#66d9ef>then</span> vif_map
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> infer_vif_map <span style=color:#f92672>~__</span>context <span style=color:#f92672>(</span>vifs <span style=color:#f92672>@</span> snapshot_vifs<span style=color:#f92672>)</span> vif_map
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>More sanity checks: We can&rsquo;t do a storage migration if any of the VDIs is a reset-on-boot one - since the state will be lost on the destination when it&rsquo;s attached:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* Block SXM when VM has a VDI with on_boot=reset *)</span>
</span></span><span style=display:flex><span>  List.<span style=color:#f92672>(</span>iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vconf <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> vdi <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>Db.VDI.get_on_boot <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#f92672>==`</span>reset<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.vdi_on_boot_mode_incompatible_with_operation<span style=color:#f92672>,</span> <span style=color:#f92672>[</span>Ref.string_of vdi<span style=color:#f92672>])))</span> vms_vdis<span style=color:#f92672>)</span> <span style=color:#f92672>;</span></span></span></code></pre></div><p>We now consider all of the VDIs associated with the snapshots. As for the VM&rsquo;s VBDs above, we end up with a <code>vdi_mirror</code> list. Note we pass <code>false</code> to the <code>allow_mirror</code> parameter of the <code>get_vdi_mirror</code> function as none of these snapshot VDIs will ever require mirrorring.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> snapshots_vdis <span style=color:#f92672>=</span> List.filter_map <span style=color:#f92672>(</span>vdi_filter <span style=color:#f92672>__</span>context false<span style=color:#f92672>)</span></span></span></code></pre></div><p>Finally we get all of the suspend-image VDIs from all snapshots as well as the actual VM, since it might be suspended itself:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>snapshots_vbds <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> suspends_vdis <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    List.fold_left
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> acc vm <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span> Db.VM.get_power_state <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#f92672>=</span> <span style=color:#f92672>`</span><span style=color:#a6e22e>Suspended</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>let</span> vdi <span style=color:#f92672>=</span> Db.VM.get_suspend_VDI <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>let</span> sr <span style=color:#f92672>=</span> Db.VDI.get_SR <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>if</span> is_intra_pool <span style=color:#f92672>&amp;&amp;</span> Helpers.host_has_pbd_for_sr <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>host<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>dest_host <span style=color:#f92672>~</span>sr
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>then</span> acc
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>else</span> <span style=color:#f92672>(</span>get_vdi_mirror <span style=color:#f92672>__</span>context vm vdi false<span style=color:#f92672>)::</span> acc
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>else</span> acc<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      [] vm_and_snapshots <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Sanity check that we can see all of the suspend-image VDIs on this host:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span> <span style=color:#75715e>(* Double check that all of the suspend VDIs are all visible on the source *)</span>
</span></span><span style=display:flex><span>  List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vdi_mirror <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> sr <span style=color:#f92672>=</span> Db.VDI.get_SR <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vdi_mirror<span style=color:#f92672>.</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not <span style=color:#f92672>(</span>Helpers.host_has_pbd_for_sr <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>host<span style=color:#f92672>:</span>localhost <span style=color:#f92672>~</span>sr<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span> <span style=color:#f92672>(</span>Api_errors.suspend_image_not_accessible<span style=color:#f92672>,</span> <span style=color:#f92672>[</span> Ref.string_of vdi_mirror<span style=color:#f92672>.</span>vdi <span style=color:#f92672>])))</span> suspends_vdis<span style=color:#f92672>;</span></span></span></code></pre></div><p>Next is a fairly complex piece that determines the destination SR for all of these VDIs. We don&rsquo;t require API uses to decide destinations for all of the VDIs on snapshots and hence we have to make some decisions here:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_pool <span style=color:#f92672>=</span> List.hd <span style=color:#f92672>(</span>XenAPI.Pool.get_all remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> default_sr_ref <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    XenAPI.Pool.get_default_SR remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_pool <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> suspend_sr_ref <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pool_suspend_SR <span style=color:#f92672>=</span> XenAPI.Pool.get_suspend_image_SR remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_pool
</span></span><span style=display:flex><span>    <span style=color:#f92672>and</span> host_suspend_SR <span style=color:#f92672>=</span> XenAPI.Host.get_suspend_image_sr remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session remote<span style=color:#f92672>.</span>dest_host <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pool_suspend_SR <span style=color:#f92672>&lt;&gt;</span> Ref.null <span style=color:#66d9ef>then</span> pool_suspend_SR <span style=color:#66d9ef>else</span> host_suspend_SR <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Resolve placement of unspecified VDIs here - unspecified VDIs that
</span></span></span><span style=display:flex><span><span style=color:#75715e>            are &#39;snapshot_of&#39; a specified VDI go to the same place. suspend VDIs
</span></span></span><span style=display:flex><span><span style=color:#75715e>            that are unspecified go to the suspend_sr_ref defined above *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> extra_vdis <span style=color:#f92672>=</span> suspends_vdis <span style=color:#f92672>@</span> snapshots_vdis <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> extra_vdi_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    List.map
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vconf <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>let</span> dest_sr_ref <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>let</span> is_mapped <span style=color:#f92672>=</span> List.mem_assoc vconf<span style=color:#f92672>.</span>vdi vdi_map
</span></span><span style=display:flex><span>           <span style=color:#f92672>and</span> snapshot_of_is_mapped <span style=color:#f92672>=</span> List.mem_assoc vconf<span style=color:#f92672>.</span>snapshot_of vdi_map
</span></span><span style=display:flex><span>           <span style=color:#f92672>and</span> is_suspend_vdi <span style=color:#f92672>=</span> List.mem vconf suspends_vdis
</span></span><span style=display:flex><span>           <span style=color:#f92672>and</span> remote_has_suspend_sr <span style=color:#f92672>=</span> suspend_sr_ref <span style=color:#f92672>&lt;&gt;</span> Ref.null
</span></span><span style=display:flex><span>           <span style=color:#f92672>and</span> remote_has_default_sr <span style=color:#f92672>=</span> default_sr_ref <span style=color:#f92672>&lt;&gt;</span> Ref.null <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>let</span> log_prefix <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>             Printf.sprintf <span style=color:#e6db74>&#34;Resolving VDI-&gt;SR map for VDI %s:&#34;</span> <span style=color:#f92672>(</span>Db.VDI.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>if</span> is_mapped <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s VDI has been specified in the map&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             List.assoc vconf<span style=color:#f92672>.</span>vdi vdi_map
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> snapshot_of_is_mapped <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s Snapshot VDI has entry in map for it&#39;s snapshot_of link&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             List.assoc vconf<span style=color:#f92672>.</span>snapshot_of vdi_map
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> is_suspend_vdi <span style=color:#f92672>&amp;&amp;</span> remote_has_suspend_sr <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s Mapping suspend VDI to remote suspend SR&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             suspend_sr_ref
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> is_suspend_vdi <span style=color:#f92672>&amp;&amp;</span> remote_has_default_sr <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s Remote suspend SR not set, mapping suspend VDI to remote default SR&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             default_sr_ref
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> remote_has_default_sr <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             debug <span style=color:#e6db74>&#34;%s Mapping unspecified VDI to remote default SR&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             default_sr_ref
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>             error <span style=color:#e6db74>&#34;%s VDI not in VDI-&gt;SR map and no remote default SR is set&#34;</span> log_prefix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.vdi_not_in_map<span style=color:#f92672>,</span> <span style=color:#f92672>[</span> Ref.string_of vconf<span style=color:#f92672>.</span>vdi <span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>         <span style=color:#f92672>(</span>vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>,</span> dest_sr_ref<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>      extra_vdis <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>At the end of this we&rsquo;ve got all of the VDIs that need to be copied and destinations for all of them:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdi_map <span style=color:#f92672>=</span> vdi_map <span style=color:#f92672>@</span> extra_vdi_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> all_vdis <span style=color:#f92672>=</span> vms_vdis <span style=color:#f92672>@</span> extra_vdis <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* The vdi_map should be complete at this point - it should include all the
</span></span></span><span style=display:flex><span><span style=color:#75715e>     VDIs in the all_vdis list. *)</span></span></span></code></pre></div><p>Now we gather some final information together:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  assert_no_cbt_enabled_vdi_migrated <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vdi_map<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dbg <span style=color:#f92672>=</span> Context.string_of_task <span style=color:#f92672>__</span>context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Xapi_xenops_queue</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> queue_name <span style=color:#f92672>=</span> queue_of_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>XenopsAPI</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>val</span> make_client queue_name <span style=color:#f92672>:</span> <span style=color:#a6e22e>XENOPS</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_vdis <span style=color:#f92672>=</span> ref [] <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> ha_always_run_reset <span style=color:#f92672>=</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> Db.VM.get_ha_always_run <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> cd_vbds <span style=color:#f92672>=</span> find_cds_to_eject <span style=color:#f92672>__</span>context vdi_map vbds <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  eject_cds <span style=color:#f92672>__</span>context cd_vbds<span style=color:#f92672>;</span></span></span></code></pre></div><p>check there&rsquo;s no CBT (we can&rsquo;t currently migrate the CBT metadata), make our client to talk to Xenopsd, make a mutable list of remote VDIs (which I think is redundant right now), decide whether we need to do anything for HA (we disable HA protection for this VM on the destination until it&rsquo;s fully migrated) and eject any CDs from the VM.</p><p>Up until now this has mostly been gathering info (aside from the ejecting CDs bit), but now we&rsquo;ll start to do some actions, so we begin a <code>try-catch</code> block:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>try</span></span></span></code></pre></div><p>but we&rsquo;ve still got a bit of thinking to do: we sort the VDIs to copy based on age/size:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#75715e>(* Sort VDIs by size in principle and then age secondly. This gives better
</span></span></span><span style=display:flex><span><span style=color:#75715e>       chances that similar but smaller VDIs would arrive comparatively
</span></span></span><span style=display:flex><span><span style=color:#75715e>       earlier, which can serve as base for incremental copying the larger
</span></span></span><span style=display:flex><span><span style=color:#75715e>       ones. *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> compare_fun v1 v2 <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> Int64.compare v1<span style=color:#f92672>.</span>size v2<span style=color:#f92672>.</span>size <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> r <span style=color:#f92672>=</span> 0 <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> t1 <span style=color:#f92672>=</span> Date.to_float <span style=color:#f92672>(</span>Db.VDI.get_snapshot_time <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>v1<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> t2 <span style=color:#f92672>=</span> Date.to_float <span style=color:#f92672>(</span>Db.VDI.get_snapshot_time <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>v2<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        compare t1 t2
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> r <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> all_vdis <span style=color:#f92672>=</span> all_vdis <span style=color:#f92672>|&gt;</span> List.sort compare_fun <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> total_size <span style=color:#f92672>=</span> List.fold_left <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> acc vconf <span style=color:#f92672>-&gt;</span> Int64.add acc vconf<span style=color:#f92672>.</span>size<span style=color:#f92672>)</span> 0L all_vdis <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> so_far <span style=color:#f92672>=</span> ref 0L <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>OK, let&rsquo;s copy/mirror:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    with_many <span style=color:#f92672>(</span>vdi_copy_fun <span style=color:#f92672>__</span>context dbg vdi_map remote is_intra_pool remote_vdis so_far total_size copy<span style=color:#f92672>)</span> all_vdis <span style=color:#f92672>@@</span> <span style=color:#66d9ef>fun</span> all_map <span style=color:#f92672>-&gt;</span></span></span></code></pre></div><p>The copy functions are written such that they take continuations. This it to make the error handling simpler - each individual component function can perform its setup and execute the continuation. In the event of an exception coming from the continuation it can then unroll its bit of state and rethrow the exception for the next layer to handle.</p><p><code>with_many</code> is a simple helper function for nesting invocations of functions that take continuations. It has the delightful type:</p><div class="wrap-code highlight"><pre tabindex=0><code>(&#39;a -&gt; (&#39;b -&gt; &#39;c) -&gt; &#39;c) -&gt; &#39;a list -&gt; (&#39;b list -&gt; &#39;c) -&gt; &#39;c</code></pre></div><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* Helper function to apply a &#39;with_x&#39; function to a list *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> with_many withfn many fn <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> inner l acc <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> l <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> [] <span style=color:#f92672>-&gt;</span> fn acc
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> x<span style=color:#f92672>::</span>xs <span style=color:#f92672>-&gt;</span> withfn x <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> y <span style=color:#f92672>-&gt;</span> inner xs <span style=color:#f92672>(</span>y<span style=color:#f92672>::</span>acc<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span> inner many []</span></span></code></pre></div><p>As an example of its operation, imagine our withfn is as follows:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> withfn x c <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  Printf.printf <span style=color:#e6db74>&#34;Starting withfn: x=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> x<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    c <span style=color:#f92672>(</span>string_of_int x<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    Printf.printf <span style=color:#e6db74>&#34;Handling exception for x=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> x<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> e<span style=color:#f92672>;;</span></span></span></code></pre></div><p>applying this gives the output:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>utop <span style=color:#f92672>#</span> with_many withfn <span style=color:#f92672>[</span>1<span style=color:#f92672>;</span>2<span style=color:#f92672>;</span>3<span style=color:#f92672>;</span>4<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>String.concat <span style=color:#e6db74>&#34;,&#34;</span><span style=color:#f92672>);;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>1
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>2
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>3
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>4
</span></span><span style=display:flex><span><span style=color:#f92672>-</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;4,3,2,1&#34;</span></span></span></code></pre></div><p>whereas raising an exception in the continutation results in the following:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>utop <span style=color:#f92672>#</span> with_many with_fn <span style=color:#f92672>[</span>1<span style=color:#f92672>;</span>2<span style=color:#f92672>;</span>3<span style=color:#f92672>;</span>4<span style=color:#f92672>]</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#e6db74>&#34;error&#34;</span><span style=color:#f92672>);;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>1
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>2
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>3
</span></span><span style=display:flex><span><span style=color:#a6e22e>Starting</span> <span style=color:#66d9ef>with</span> fn<span style=color:#f92672>:</span> x<span style=color:#f92672>=</span>4
</span></span><span style=display:flex><span><span style=color:#a6e22e>Handling</span> <span style=color:#66d9ef>exception</span> <span style=color:#66d9ef>for</span> x<span style=color:#f92672>=</span>4
</span></span><span style=display:flex><span><span style=color:#a6e22e>Handling</span> <span style=color:#66d9ef>exception</span> <span style=color:#66d9ef>for</span> x<span style=color:#f92672>=</span>3
</span></span><span style=display:flex><span><span style=color:#a6e22e>Handling</span> <span style=color:#66d9ef>exception</span> <span style=color:#66d9ef>for</span> x<span style=color:#f92672>=</span>2
</span></span><span style=display:flex><span><span style=color:#a6e22e>Handling</span> <span style=color:#66d9ef>exception</span> <span style=color:#66d9ef>for</span> x<span style=color:#f92672>=</span>1
</span></span><span style=display:flex><span><span style=color:#a6e22e>Exception</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Failure</span> <span style=color:#e6db74>&#34;error&#34;</span><span style=color:#f92672>.</span></span></span></code></pre></div><p>All the real action is in <code>vdi_copy_fun</code>, which copies or mirrors a single VDI:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> vdi_copy_fun <span style=color:#f92672>__</span>context dbg vdi_map remote is_intra_pool remote_vdis so_far total_size copy vconf continuation <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Storage_access</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_sr_ref <span style=color:#f92672>=</span> List.assoc vconf<span style=color:#f92672>.</span>vdi vdi_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_sr_uuid <span style=color:#f92672>=</span> XenAPI.SR.get_uuid remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_sr_ref <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Plug the destination shared SR into destination host and pool master if unplugged.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     Plug the local SR into destination host only if unplugged *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_pool <span style=color:#f92672>=</span> List.hd <span style=color:#f92672>(</span>XenAPI.Pool.get_all remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> master_host <span style=color:#f92672>=</span> XenAPI.Pool.get_master remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_pool <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pbds <span style=color:#f92672>=</span> XenAPI.SR.get_PBDs remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_sr_ref <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pbd_host_pair <span style=color:#f92672>=</span> List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> pbd <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span>pbd<span style=color:#f92672>,</span> XenAPI.PBD.get_host remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session pbd<span style=color:#f92672>))</span> pbds <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> hosts_to_be_attached <span style=color:#f92672>=</span> <span style=color:#f92672>[</span>master_host<span style=color:#f92672>;</span> remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>]</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pbds_to_be_plugged <span style=color:#f92672>=</span> List.filter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(_,</span> host<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span>List.mem host hosts_to_be_attached<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>(</span>XenAPI.Host.get_enabled remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session host<span style=color:#f92672>))</span> pbd_host_pair <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>pbd<span style=color:#f92672>,</span> <span style=color:#f92672>_)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not <span style=color:#f92672>(</span>XenAPI.PBD.get_currently_attached remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session pbd<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        XenAPI.PBD.plug remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session pbd<span style=color:#f92672>)</span> pbds_to_be_plugged<span style=color:#f92672>;</span></span></span></code></pre></div><p>It begins by attempting to ensure the SRs we require are definitely attached on the destination host and on the destination pool master.</p><p>There&rsquo;s now a little logic to support the case where we have cross-pool SRs and the VDI is already visible to the destination pool. Since this is outside our normal support envelope there is a key in xapi_globs that has to be set (via xapi.conf) to enable this:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> dest_vdi_exists_on_sr vdi_uuid sr_ref retry <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> dest_vdi_ref <span style=color:#f92672>=</span> XenAPI.VDI.get_by_uuid remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session vdi_uuid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> dest_vdi_sr_ref <span style=color:#f92672>=</span> XenAPI.VDI.get_SR remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_vdi_ref <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> dest_vdi_sr_ref <span style=color:#f92672>=</span> sr_ref <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        true
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        false
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> retry <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>          XenAPI.SR.scan remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session sr_ref<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          dest_vdi_exists_on_sr vdi_uuid sr_ref false
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        false
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* CP-4498 added an unsupported mode to use cross-pool shared SRs - the initial
</span></span></span><span style=display:flex><span><span style=color:#75715e>     use case is for a shared raw iSCSI SR (same uuid, same VDI uuid) *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdi_uuid <span style=color:#f92672>=</span> Db.VDI.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> mirror <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>Xapi_globs.relax_xsm_sr_check <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>dest_sr_uuid <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>sr<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(* Check if the VDI uuid already exists in the target SR *)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>dest_vdi_exists_on_sr vdi_uuid dest_sr_ref true<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            false
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            failwith <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;SR UUID matches on destination but VDI does not exist&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        true
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span>not is_intra_pool<span style=color:#f92672>)</span> <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>dest_sr_uuid <span style=color:#f92672>&lt;&gt;</span> vconf<span style=color:#f92672>.</span>sr<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>The check also covers the case where we&rsquo;re doing an intra-pool migration and not copying all of the disks, in which case we don&rsquo;t need to do anything for that disk.</p><p>We now have a wrapper function that creates a new datapath and passes it to a continuation function. On error it handles the destruction of the datapath:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> with_new_dp cont <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dp <span style=color:#f92672>=</span> Printf.sprintf <span style=color:#f92672>(</span><span style=color:#66d9ef>if</span> vconf<span style=color:#f92672>.</span>do_mirror <span style=color:#66d9ef>then</span> <span style=color:#e6db74>&#34;mirror_%s&#34;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;copy_%s&#34;</span><span style=color:#f92672>)</span> vconf<span style=color:#f92672>.</span>dp <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> cont dp
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>try</span> SMAPI.DP.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>allow_leak<span style=color:#f92672>:</span>false <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> info <span style=color:#e6db74>&#34;Failed to cleanup datapath: %s&#34;</span> dp<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> e <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>and now a helper that, given a remote VDI uuid, looks up the reference on the remote host and gives it to a continuation function. On failure of the continuation it will destroy the remote VDI:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> with_remote_vdi remote_vdi cont <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Executing remote scan to ensure VDI is known to xapi&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    XenAPI.SR.scan remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session dest_sr_ref<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> query <span style=color:#f92672>=</span> Printf.sprintf <span style=color:#e6db74>&#34;(field </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>location</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>=</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>%s</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>) and (field </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>SR</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>=</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>%s</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>)&#34;</span> remote_vdi <span style=color:#f92672>(</span>Ref.string_of dest_sr_ref<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> XenAPI.VDI.get_all_records_where remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session query <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> remote_vdi_ref <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> vdis <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> [] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.vdi_location_missing<span style=color:#f92672>,</span> <span style=color:#f92672>[</span>Ref.string_of dest_sr_ref<span style=color:#f92672>;</span> remote_vdi<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> h <span style=color:#f92672>::</span> [] <span style=color:#f92672>-&gt;</span> debug <span style=color:#e6db74>&#34;Found remote vdi reference: %s&#34;</span> <span style=color:#f92672>(</span>Ref.string_of <span style=color:#f92672>(</span>fst h<span style=color:#f92672>));</span> fst h
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.location_not_unique<span style=color:#f92672>,</span> <span style=color:#f92672>[</span>Ref.string_of dest_sr_ref<span style=color:#f92672>;</span> remote_vdi<span style=color:#f92672>]))</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> cont remote_vdi_ref
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>try</span> XenAPI.VDI.destroy remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session remote_vdi_ref <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> error <span style=color:#e6db74>&#34;Failed to destroy remote VDI&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> e <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>another helper to gather together info about a mirrored VDI:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> get_mirror_record <span style=color:#f92672>?</span>new_dp remote_vdi remote_vdi_reference <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span> mr_dp <span style=color:#f92672>=</span> new_dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_mirrored <span style=color:#f92672>=</span> mirror<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_local_sr <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>sr<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_local_vdi <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>location<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_remote_sr <span style=color:#f92672>=</span> dest_sr_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_remote_vdi <span style=color:#f92672>=</span> remote_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_local_xenops_locator <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>xenops_locator<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_remote_xenops_locator <span style=color:#f92672>=</span> Xapi_xenops.xenops_vdi_locator_of_strings dest_sr_uuid remote_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_local_vdi_reference <span style=color:#f92672>=</span> vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      mr_remote_vdi_reference <span style=color:#f92672>=</span> remote_vdi_reference <span style=color:#f92672>}</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>and finally the really important function:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> mirror_to_remote new_dp <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> task <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not vconf<span style=color:#f92672>.</span>do_mirror <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        SMAPI.DATA.copy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>location <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>new_dp <span style=color:#f92672>~</span>url<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>sm_url <span style=color:#f92672>~</span>dest<span style=color:#f92672>:</span>dest_sr_uuid
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(* Though we have no intention of &#34;write&#34;, here we use the same mode as the
</span></span></span><span style=display:flex><span><span style=color:#75715e>           associated VBD on a mirrored VDIs (i.e. always RW). This avoids problem
</span></span></span><span style=display:flex><span><span style=color:#75715e>           when we need to start/stop the VM along the migration. *)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> read_write <span style=color:#f92672>=</span> true <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(* DP set up is only essential for MIRROR.start/stop due to their open ended pattern.
</span></span></span><span style=display:flex><span><span style=color:#75715e>           It&#39;s not necessary for copy which will take care of that itself. *)</span>
</span></span><span style=display:flex><span>        ignore<span style=color:#f92672>(</span>SMAPI.VDI.attach <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>new_dp <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>location <span style=color:#f92672>~</span>read_write<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        SMAPI.VDI.activate <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>new_dp <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>location<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        ignore<span style=color:#f92672>(</span>Storage_access.register_mirror <span style=color:#f92672>__</span>context vconf<span style=color:#f92672>.</span>location<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        SMAPI.DATA.MIRROR.start <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vconf<span style=color:#f92672>.</span>location <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>new_dp <span style=color:#f92672>~</span>url<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>sm_url <span style=color:#f92672>~</span>dest<span style=color:#f92672>:</span>dest_sr_uuid
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mapfn x <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> total <span style=color:#f92672>=</span> Int64.to_float total_size <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> done_ <span style=color:#f92672>=</span> Int64.to_float <span style=color:#f92672>!</span>so_far <span style=color:#f92672>/.</span> total <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> remaining <span style=color:#f92672>=</span> Int64.to_float vconf<span style=color:#f92672>.</span>size <span style=color:#f92672>/.</span> total <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      done_ <span style=color:#f92672>+.</span> x <span style=color:#f92672>*.</span> remaining <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Storage_access</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> task_result <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      task <span style=color:#f92672>|&gt;</span> register_task <span style=color:#f92672>__</span>context
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> add_to_progress_map mapfn
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> wait_for_task dbg
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> remove_from_progress_map
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> unregister_task <span style=color:#f92672>__</span>context
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> success_task dbg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mirror_id<span style=color:#f92672>,</span> remote_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not vconf<span style=color:#f92672>.</span>do_mirror <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> vdi <span style=color:#f92672>=</span> task_result <span style=color:#f92672>|&gt;</span> vdi_of_task dbg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        remote_vdis <span style=color:#f92672>:=</span> vdi<span style=color:#f92672>.</span>vdi <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>remote_vdis<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>None</span><span style=color:#f92672>,</span> vdi<span style=color:#f92672>.</span>vdi
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> mirrorid <span style=color:#f92672>=</span> task_result <span style=color:#f92672>|&gt;</span> mirror_of_task dbg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> m <span style=color:#f92672>=</span> SMAPI.DATA.MIRROR.stat <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>:</span>mirrorid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Some</span> mirrorid<span style=color:#f92672>,</span> m<span style=color:#f92672>.</span>Mirror.dest_vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    so_far <span style=color:#f92672>:=</span> Int64.add <span style=color:#f92672>!</span>so_far vconf<span style=color:#f92672>.</span>size<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Local VDI %s %s to %s&#34;</span> vconf<span style=color:#f92672>.</span>location <span style=color:#f92672>(</span><span style=color:#66d9ef>if</span> vconf<span style=color:#f92672>.</span>do_mirror <span style=color:#66d9ef>then</span> <span style=color:#e6db74>&#34;mirrored&#34;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;copied&#34;</span><span style=color:#f92672>)</span> remote_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    mirror_id<span style=color:#f92672>,</span> remote_vdi <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This is the bit that actually starts the mirroring or copying. Before the call to mirror we call <code>VDI.attach</code> and <code>VDI.activate</code> locally to ensure that if the VM is shutdown then the detach/deactivate there doesn&rsquo;t kill the mirroring process.</p><p>Note the parameters to the SMAPI call are <code>sr</code> and <code>vdi</code>, locating the local VDI and SM backend, <code>new_dp</code>, the datapath we&rsquo;re using for the mirroring, <code>url</code>, which is the remote url on which SMAPI calls work, and <code>dest</code>, the destination SR uuid. These are also the arguments to <code>copy</code> above too.</p><p>There&rsquo;s a little function to calculate the overall progress of the task, and the function waits until the completion of the task before it continues. The function <code>success_task</code> will raise an exception if the task failed. For <code>DATA.mirror</code>, completion implies both that the disk data has been copied to the destination and that all local writes are being mirrored to the destination. Hence more cleanup must be done on cancellation. In contrast, if the <code>DATA.copy</code> path had been taken then the operation at this point has completely finished.</p><p>The result of this function is an optional mirror id and the remote VDI uuid.</p><p>Next, there is a <code>post_mirror</code> function:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> post_mirror mirror_id mirror_record <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> continuation mirror_record <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>match</span> mirror_id <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> mid <span style=color:#f92672>-&gt;</span> ignore<span style=color:#f92672>(</span>Storage_access.unregister_mirror mid<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> mirror <span style=color:#f92672>&amp;&amp;</span> not <span style=color:#f92672>(</span>Xapi_fist.storage_motion_keep_vdi () <span style=color:#f92672>||</span> copy<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        Helpers.call_api_functions <span style=color:#f92672>~__</span>context <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> rpc session_id <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            XenAPI.VDI.destroy rpc session_id vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      result
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> mirror_failed <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> mirror_id <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> mid <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          ignore<span style=color:#f92672>(</span>Storage_access.unregister_mirror mid<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> m <span style=color:#f92672>=</span> SMAPI.DATA.MIRROR.stat <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>:</span>mid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span><span style=color:#66d9ef>try</span> SMAPI.DATA.MIRROR.stop <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>:</span>mid <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          m<span style=color:#f92672>.</span>Mirror.failed
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> false <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> mirror_failed <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.mirror_failed<span style=color:#f92672>,[</span>Ref.string_of vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>raise</span> e <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This is poorly named - it is post mirror <em>and</em> copy. The aim of this function is to destroy the source VDIs on successful completion of the continuation function, which will have migrated the VM to the destination. In its exception handler it will stop the mirroring, but before doing so it will check to see if the mirroring process it was looking after has itself failed, and raise <code>mirror_failed</code> if so. This is because a failed mirror can result in a range of actual errors, and we decide here that the failed mirror was probably the root cause.</p><p>These functions are assembled together at the end of the <code>vdi_copy_fun</code> function:</p><div class="wrap-code highlight"><pre tabindex=0><code>   if mirror then
    with_new_dp (fun new_dp -&gt;
        let mirror_id, remote_vdi = mirror_to_remote new_dp in
        with_remote_vdi remote_vdi (fun remote_vdi_ref -&gt;
            let mirror_record = get_mirror_record ~new_dp remote_vdi remote_vdi_ref in
            post_mirror mirror_id mirror_record))
  else
    let mirror_record = get_mirror_record vconf.location (XenAPI.VDI.get_by_uuid remote.rpc remote.session vdi_uuid) in
    continuation mirror_record</code></pre></div><p>again, <code>mirror</code> here is poorly named, and means mirror <em>or</em> copy.</p><p>Once all of the disks have been mirrored or copied, we jump back to the body of <code>migrate_send</code>. We split apart the mirror records according to the source of the VDI:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#66d9ef>let</span> was_from vmap <span style=color:#f92672>=</span> List.exists <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vconf <span style=color:#f92672>-&gt;</span> vconf<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> vmap<span style=color:#f92672>.</span>mr_local_vdi_reference<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> suspends_map<span style=color:#f92672>,</span> snapshots_map<span style=color:#f92672>,</span> vdi_map <span style=color:#f92672>=</span> List.fold_left <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>suspends<span style=color:#f92672>,</span> snapshots<span style=color:#f92672>,</span> vdis<span style=color:#f92672>)</span> vmap <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> was_from vmap suspends_vdis <span style=color:#66d9ef>then</span>  vmap <span style=color:#f92672>::</span> suspends<span style=color:#f92672>,</span> snapshots<span style=color:#f92672>,</span> vdis
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> was_from vmap snapshots_vdis <span style=color:#66d9ef>then</span> suspends<span style=color:#f92672>,</span> vmap <span style=color:#f92672>::</span> snapshots<span style=color:#f92672>,</span> vdis
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span> suspends<span style=color:#f92672>,</span> snapshots<span style=color:#f92672>,</span> vmap <span style=color:#f92672>::</span> vdis
</span></span><span style=display:flex><span>        <span style=color:#f92672>)</span> <span style=color:#f92672>(</span>[]<span style=color:#f92672>,</span>[]<span style=color:#f92672>,</span>[]<span style=color:#f92672>)</span> all_map <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>then we reassemble all_map from this, for some reason:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> all_map <span style=color:#f92672>=</span> List.concat <span style=color:#f92672>[</span>suspends_map<span style=color:#f92672>;</span> snapshots_map<span style=color:#f92672>;</span> vdi_map<span style=color:#f92672>]</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Now we need to update the snapshot-of links:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>     <span style=color:#75715e>(* All the disks and snapshots have been created in the remote SR(s),
</span></span></span><span style=display:flex><span><span style=color:#75715e>       * so update the snapshot links if there are any snapshots. *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> snapshots_map <span style=color:#f92672>&lt;&gt;</span> [] <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        update_snapshot_info <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>url<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>sm_url <span style=color:#f92672>~</span>vdi_map <span style=color:#f92672>~</span>snapshots_map<span style=color:#f92672>;</span></span></span></code></pre></div><p>I&rsquo;m not entirely sure why this is done in this layer as opposed to in the storage layer.</p><p>A little housekeeping:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>     <span style=color:#66d9ef>let</span> xenops_vdi_map <span style=color:#f92672>=</span> List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> mirror_record <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span>mirror_record<span style=color:#f92672>.</span>mr_local_xenops_locator<span style=color:#f92672>,</span> mirror_record<span style=color:#f92672>.</span>mr_remote_xenops_locator<span style=color:#f92672>))</span> all_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* Wait for delay fist to disappear *)</span>
</span></span><span style=display:flex><span>      wait_for_fist <span style=color:#f92672>__</span>context Xapi_fist.pause_storage_migrate <span style=color:#e6db74>&#34;pause_storage_migrate&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span></span></span></code></pre></div><p>the <code>fist</code> thing here simply allows tests to put in a delay at this specific point.</p><p>We also check the task to see if we&rsquo;ve been cancelled and raise an exception if so.</p><p>The VM metadata is now imported into the remote pool, with all the XenAPI level objects remapped:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> new_vm <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_intra_pool
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>then</span> vm
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(* Make sure HA replaning cycle won&#39;t occur right during the import process or immediately after *)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> ha_always_run_reset <span style=color:#66d9ef>then</span> XenAPI.Pool.ha_prevent_restarts_for <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>seconds<span style=color:#f92672>:(</span>Int64.of_float <span style=color:#f92672>!</span>Xapi_globs.ha_monitor_interval<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(* Move the xapi VM metadata to the remote pool. *)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> vms <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vdi_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>              List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> mirror_record <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    local_vdi_reference <span style=color:#f92672>=</span> mirror_record<span style=color:#f92672>.</span>mr_local_vdi_reference<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    remote_vdi_reference <span style=color:#f92672>=</span> <span style=color:#a6e22e>Some</span> mirror_record<span style=color:#f92672>.</span>mr_remote_vdi_reference<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>                all_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vif_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>              List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>vif<span style=color:#f92672>,</span> network<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    local_vif_reference <span style=color:#f92672>=</span> vif<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    remote_network_reference <span style=color:#f92672>=</span> network<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>                vif_map <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vgpu_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>              List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>vgpu<span style=color:#f92672>,</span> gpu_group<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    local_vgpu_reference <span style=color:#f92672>=</span> vgpu<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    remote_gpu_group_reference <span style=color:#f92672>=</span> gpu_group<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>                vgpu_map
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            inter_pool_metadata_transfer <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>remote <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>vdi_map
</span></span><span style=display:flex><span>              <span style=color:#f92672>~</span>vif_map <span style=color:#f92672>~</span>vgpu_map <span style=color:#f92672>~</span>dry_run<span style=color:#f92672>:</span>false <span style=color:#f92672>~</span>live<span style=color:#f92672>:</span>true <span style=color:#f92672>~</span>copy
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> vm <span style=color:#f92672>=</span> List.hd vms <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> ha_always_run_reset <span style=color:#66d9ef>then</span> XenAPI.VM.set_ha_always_run <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#f92672>~</span><span style=color:#66d9ef>value</span><span style=color:#f92672>:</span>false <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(* Reserve resources for the new VM on the destination pool&#39;s host *)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span> XenAPI.Host.allocate_resources_for_vm remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session remote<span style=color:#f92672>.</span>dest_host vm true <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          vm <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>More waiting for fist points:</p><div class="wrap-code highlight"><pre tabindex=0><code>     wait_for_fist __context Xapi_fist.pause_storage_migrate2 &#34;pause_storage_migrate2&#34;;

      (* Attach networks on remote *)
      XenAPI.Network.attach_for_vm ~rpc:remote.rpc ~session_id:remote.session ~host:remote.dest_host ~vm:new_vm;</code></pre></div><p>also make sure all the networks are plugged for the VM on the destination.
Next we create the xenopsd-level vif map, equivalent to the vdi_map above:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* Create the vif-map for xenops, linking VIF devices to bridge names on the remote *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> xenops_vif_map <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> vifs <span style=color:#f92672>=</span> XenAPI.VM.get_VIFs <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>new_vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vif <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vifr <span style=color:#f92672>=</span> XenAPI.VIF.get_record <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vif <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> bridge <span style=color:#f92672>=</span> Xenops_interface.Network.<span style=color:#a6e22e>Local</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>(</span>XenAPI.Network.get_bridge <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vifr<span style=color:#f92672>.</span>API.vIF_network<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            vifr<span style=color:#f92672>.</span>API.vIF_device<span style=color:#f92672>,</span> bridge
</span></span><span style=display:flex><span>          <span style=color:#f92672>)</span> vifs
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Now we destroy any extra mirror datapaths we set up previously:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>     <span style=color:#75715e>(* Destroy the local datapaths - this allows the VDIs to properly detach, invoking the migrate_finalize calls *)</span>
</span></span><span style=display:flex><span>      List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> mirror_record <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> mirror_record<span style=color:#f92672>.</span>mr_mirrored
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>match</span> mirror_record<span style=color:#f92672>.</span>mr_dp <span style=color:#66d9ef>with</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> dp <span style=color:#f92672>-&gt;</span>  SMAPI.DP.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>allow_leak<span style=color:#f92672>:</span>false <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> ()<span style=color:#f92672>)</span> all_map<span style=color:#f92672>;</span></span></span></code></pre></div><p>More housekeeping:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;vm.migrate_send: migration initiated vm:%s&#34;</span> vm_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* In case when we do SXM on the same host (mostly likely a VDI
</span></span></span><span style=display:flex><span><span style=color:#75715e>         migration), the VM&#39;s metadata in xenopsd will be in-place updated
</span></span></span><span style=display:flex><span><span style=color:#75715e>         as soon as the domain migration starts. For these case, there
</span></span></span><span style=display:flex><span><span style=color:#75715e>         will be no (clean) way back from this point. So we disable task
</span></span></span><span style=display:flex><span><span style=color:#75715e>         cancellation for them here.
</span></span></span><span style=display:flex><span><span style=color:#75715e>       *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> is_same_host <span style=color:#66d9ef>then</span> <span style=color:#f92672>(</span>TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span> TaskHelper.set_not_cancellable <span style=color:#f92672>~__</span>context<span style=color:#f92672>);</span></span></span></code></pre></div><p>Finally we get to the memory-image part of the migration:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#75715e>(* It&#39;s acceptable for the VM not to exist at this point; shutdown commutes with storage migrate *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>          Xapi_xenops.Events_from_xenopsd.with_suppressed queue_name dbg vm_uuid
</span></span><span style=display:flex><span>            <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>let</span> xenops_vgpu_map <span style=color:#f92672>=</span> <span style=color:#75715e>(* can raise VGPU_mapping *)</span>
</span></span><span style=display:flex><span>                 infer_vgpu_map <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>remote new_vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>               migrate_with_retry
</span></span><span style=display:flex><span>                 <span style=color:#f92672>~__</span>context queue_name dbg vm_uuid xenops_vdi_map
</span></span><span style=display:flex><span>                 xenops_vif_map xenops_vgpu_map remote<span style=color:#f92672>.</span>xenops_url<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>               Xapi_xenops.Xenopsd_metadata.delete <span style=color:#f92672>~__</span>context vm_uuid<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> Xenops_interface.<span style=color:#a6e22e>Does_not_exist</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;VM&#34;</span><span style=color:#f92672>,_)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> Xenops_interface.<span style=color:#a6e22e>Does_not_exist</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;extra&#34;</span><span style=color:#f92672>,_)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          info <span style=color:#e6db74>&#34;%s: VM %s stopped being live during migration&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;vm_migrate_send&#34;</span> vm_uuid
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>VGPU_mapping</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          info <span style=color:#e6db74>&#34;%s: VM %s - can&#39;t infer vGPU map: %s&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;vm_migrate_send&#34;</span> vm_uuid msg<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>raise</span> Api_errors.
</span></span><span style=display:flex><span>                  <span style=color:#f92672>(</span><span style=color:#a6e22e>Server_error</span>
</span></span><span style=display:flex><span>                     <span style=color:#f92672>(</span>vm_migrate_failed<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                      <span style=color:#f92672>([</span> vm_uuid
</span></span><span style=display:flex><span>                       <span style=color:#f92672>;</span> Helpers.get_localhost_uuid ()
</span></span><span style=display:flex><span>                       <span style=color:#f92672>;</span> Db.Host.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>dest_host
</span></span><span style=display:flex><span>                       <span style=color:#f92672>;</span> <span style=color:#e6db74>&#34;The VM changed its power state during migration&#34;</span>
</span></span><span style=display:flex><span>                       <span style=color:#f92672>])))</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Migration complete&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      SMPERF.debug <span style=color:#e6db74>&#34;vm.migrate_send: migration complete vm:%s&#34;</span> vm_uuid<span style=color:#f92672>;</span></span></span></code></pre></div><p>Now we tidy up after ourselves:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#75715e>(* So far the main body of migration is completed, and the rests are
</span></span></span><span style=display:flex><span><span style=color:#75715e>         updates, config or cleanup on the source and destination. There will
</span></span></span><span style=display:flex><span><span style=color:#75715e>         be no (clean) way back from this point, due to these destructive
</span></span></span><span style=display:flex><span><span style=color:#75715e>         changes, so we don&#39;t want user intervention e.g. task cancellation.
</span></span></span><span style=display:flex><span><span style=color:#75715e>       *)</span>
</span></span><span style=display:flex><span>      TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      TaskHelper.set_not_cancellable <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      XenAPI.VM.pool_migrate_complete remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session new_vm remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      detach_local_network_for_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>destination<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      Xapi_xenops.refresh_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm<span style=color:#f92672>;</span></span></span></code></pre></div><p>the function <code>pool_migrate_complete</code> is called on the destination host, and consists of a few things that ordinarily would be set up during VM.start or the like:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> pool_migrate_complete <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>host <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> Db.VM.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;VM.pool_migrate_complete %s&#34;</span> id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dbg <span style=color:#f92672>=</span> Context.string_of_task <span style=color:#f92672>__</span>context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> queue_name <span style=color:#f92672>=</span> Xapi_xenops_queue.queue_of_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> Xapi_xenops.vm_exists_in_xenopsd queue_name dbg id <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    Cpuid_helpers.update_cpu_flags <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>vm <span style=color:#f92672>~</span>host<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Xapi_xenops.set_resident_on <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Xapi_xenops.add_caches id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Xapi_xenops.refresh_vm <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Monitor_dbcalls_cache.clear_cache_for_vm <span style=color:#f92672>~</span>vm_uuid<span style=color:#f92672>:</span>id
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span></span></span></code></pre></div><p>More tidying up, remapping some remaining VBDs and clearing state on the sender:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#75715e>(* Those disks that were attached at the point the migration happened will have been
</span></span></span><span style=display:flex><span><span style=color:#75715e>         remapped by the Events_from_xenopsd logic. We need to remap any other disks at
</span></span></span><span style=display:flex><span><span style=color:#75715e>         this point here *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> is_intra_pool
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        List.iter
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vm&#39; <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>             intra_pool_vdi_remap <span style=color:#f92672>~__</span>context vm&#39; all_map<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>             intra_pool_fix_suspend_sr <span style=color:#f92672>~__</span>context remote<span style=color:#f92672>.</span>dest_host vm&#39;<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          vm_and_snapshots<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* If it&#39;s an inter-pool migrate, the VBDs will still be &#39;currently-attached=true&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>         because we supressed the events coming from xenopsd. Destroy them, so that the
</span></span></span><span style=display:flex><span><span style=color:#75715e>         VDIs can be destroyed *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> not copy
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>then</span> List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vbd <span style=color:#f92672>-&gt;</span> Db.VBD.destroy <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vbd<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>vbds <span style=color:#f92672>@</span> snapshots_vbds<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      new_vm
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>The remark about the <code>Events_from_xenopsd</code> is that we have a thread watching for events that are emitted by xenopsd, and we resynchronise xapi&rsquo;s state according to xenopsd&rsquo;s state for several fields for which xenopsd is considered the canonical source of truth. One of these is the exact VDI the VBD is associated with.</p><p>The suspend_SR field of the VM is set to the source&rsquo;s value, so we reset that.</p><p>Now we move the RRDs:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>if</span> not copy <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      Rrdd_proxy.migrate_rrd <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>remote_address<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>remote_ip <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:(</span>Ref.string_of remote<span style=color:#f92672>.</span>session<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>vm_uuid<span style=color:#f92672>:</span>vm_uuid <span style=color:#f92672>~</span>host_uuid<span style=color:#f92672>:(</span>Ref.string_of remote<span style=color:#f92672>.</span>dest_host<span style=color:#f92672>)</span> ()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>This can be done for intra- and inter- pool migrates in the same way, simplifying the logic.</p><p>However, for messages and blobs we have to only migrate them for inter-pool migrations:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>   <span style=color:#66d9ef>if</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> not copy <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* Replicate HA runtime flag if necessary *)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> ha_always_run_reset <span style=color:#66d9ef>then</span> XenAPI.VM.set_ha_always_run <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>new_vm <span style=color:#f92672>~</span><span style=color:#66d9ef>value</span><span style=color:#f92672>:</span>true<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* Send non-database metadata *)</span>
</span></span><span style=display:flex><span>      Xapi_message.send_messages <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>cls<span style=color:#f92672>:`</span><span style=color:#a6e22e>VM</span> <span style=color:#f92672>~</span>obj_uuid<span style=color:#f92672>:</span>vm_uuid
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>remote_address<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>remote_master_ip<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      Xapi_blob.migrate_push <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>rpc<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>rpc
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>remote_address<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>remote_master_ip <span style=color:#f92672>~</span>session_id<span style=color:#f92672>:</span>remote<span style=color:#f92672>.</span>session <span style=color:#f92672>~</span>old_vm<span style=color:#f92672>:</span>vm <span style=color:#f92672>~</span>new_vm <span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* Signal the remote pool that we&#39;re done *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>Lastly, we destroy the VM record on the source:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    Helpers.call_api_functions <span style=color:#f92672>~__</span>context <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> rpc session_id <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> not copy <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>          info <span style=color:#e6db74>&#34;Destroying VM ref=%s uuid=%s&#34;</span> <span style=color:#f92672>(</span>Ref.string_of vm<span style=color:#f92672>)</span> vm_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          Xapi_vm_lifecycle.force_state_reset <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#f92672>~</span><span style=color:#66d9ef>value</span><span style=color:#f92672>:`</span><span style=color:#a6e22e>Halted</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span> Db.VM.destroy <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>)</span> vm_and_snapshots
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;vm.migrate_send exiting vm:%s&#34;</span> vm_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    new_vm</span></span></code></pre></div><p>The exception handler still has to clean some state, but mostly things are handled in the CPS functions declared above:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    error <span style=color:#e6db74>&#34;Caught %s: cleaning up&#34;</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* We do our best to tidy up the state left behind *)</span>
</span></span><span style=display:flex><span>    Events_from_xenopsd.with_suppressed queue_name dbg vm_uuid <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> <span style=color:#f92672>_,</span> state <span style=color:#f92672>=</span> XenopsAPI.VM.stat dbg vm_uuid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> Xenops_interface.<span style=color:#f92672>(</span>state<span style=color:#f92672>.</span>Vm.power_state <span style=color:#f92672>=</span> <span style=color:#a6e22e>Suspended</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            debug <span style=color:#e6db74>&#34;xenops: %s: shutting down suspended VM&#34;</span> vm_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            Xapi_xenops.shutdown <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>vm <span style=color:#a6e22e>None</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> not is_intra_pool <span style=color:#f92672>&amp;&amp;</span> Db.is_valid_ref <span style=color:#f92672>__</span>context vm <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span> Db.VM.get_uuid <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>)</span> vm_and_snapshots
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> self <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vm_ref <span style=color:#f92672>=</span> XenAPI.VM.get_by_uuid remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session self <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            info <span style=color:#e6db74>&#34;Destroying stale VM uuid=%s on destination host&#34;</span> self<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            XenAPI.VM.destroy remote<span style=color:#f92672>.</span>rpc remote<span style=color:#f92672>.</span>session vm_ref
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span> error <span style=color:#e6db74>&#34;Caught %s while destroying VM uuid=%s on destination host&#34;</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>)</span> self<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> task <span style=color:#f92672>=</span> Context.get_task_id <span style=color:#f92672>__</span>context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> oc <span style=color:#f92672>=</span> Db.Task.get_other_config <span style=color:#f92672>~__</span>context <span style=color:#f92672>~</span>self<span style=color:#f92672>:</span>task <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> List.mem_assoc <span style=color:#e6db74>&#34;mirror_failed&#34;</span> oc <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> failed_vdi <span style=color:#f92672>=</span> List.assoc <span style=color:#e6db74>&#34;mirror_failed&#34;</span> oc <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> vconf <span style=color:#f92672>=</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vconf <span style=color:#f92672>-&gt;</span> vconf<span style=color:#f92672>.</span>location<span style=color:#f92672>=</span>failed_vdi<span style=color:#f92672>)</span> vms_vdis <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Mirror failed for VDI: %s&#34;</span> failed_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.mirror_failed<span style=color:#f92672>,[</span>Ref.string_of vconf<span style=color:#f92672>.</span>vdi<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    TaskHelper.exn_if_cancelling <span style=color:#f92672>~__</span>context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>begin</span> <span style=color:#66d9ef>match</span> e <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> Storage_interface.<span style=color:#a6e22e>Backend_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> Storage_interface.<span style=color:#a6e22e>Unimplemented</span><span style=color:#f92672>(</span>code<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.unimplemented_in_sm_backend<span style=color:#f92672>,</span> <span style=color:#f92672>[</span>code<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> Xenops_interface.<span style=color:#a6e22e>Cancelled</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> TaskHelper.raise_cancelled <span style=color:#f92672>~__</span>context
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>raise</span> e
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span></span></span></code></pre></div><p>Failures during the migration can result in the VM being in a suspended state. There&rsquo;s no point leaving it like this since there&rsquo;s nothing that can be done to resume it, so we force shut it down.</p><p>We also try to remove the VM record from the destination if we managed to send it there.</p><p>Finally we check for mirror failure in the task - this is set by the events thread watching for events from the storage layer, in <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_access.ml#L1169-L1207 target=_blank>storage_access.ml</a></p><h2 id=storage-code>Storage code</h2><p>The part of the code that is conceptually in the storage layer, but physically in xapi, is located in
<a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml target=_blank>storage_migrate.ml</a>. There are logically a few separate parts to this file:</p><ul><li>A <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L34-L204 target=_blank>stateful module</a> for persisting state across xapi restarts.</li><li>Some general <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L206-L281 target=_blank>helper functions</a></li><li>Some quite specific <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L206-L281 target=_blank>helper</a> <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L738-L791 target=_blank>functions</a> related to actions to be taken on deactivate/detach</li><li>An <a href=https://github.com/xapi-project/xen-api/blob/f75d51e7a3eff89d952330ec1a739df85a2895e2/ocaml/xapi/storage_migrate.ml#L793-L818 target=_blank>NBD handler</a></li><li>The implementations of the SMAPIv2 <a href=https://github.com/xapi-project/xcp-idl/blob/master/storage/storage_interface.ml#L430-L460 target=_blank>mirroring APIs</a></li></ul><p>Let&rsquo;s start by considering the way the storage APIs are intended to be used.</p><h3 id=copying-a-vdi>Copying a VDI</h3><p><code>DATA.copy</code> takes several parameters:</p><ul><li><code>dbg</code> - a debug string</li><li><code>sr</code> - the source SR (a uuid)</li><li><code>vdi</code> - the source VDI (a uuid)</li><li><code>dp</code> - <strong>unused</strong></li><li><code>url</code> - a URL on which SMAPIv2 API calls can be made</li><li><code>sr</code> - the destination SR in which the VDI should be copied</li></ul><p>and returns a parameter of type <code>Task.id</code>. The API call is intended to be called in an asynchronous fashion - ie., the caller makes the call, receives the task ID back and polls or uses the event mechanism to wait until the task has completed. The task may be cancelled via the <code>Task.cancel</code> API call. The result of the operation is obtained by calling TASK.stat, which returns a record:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>	<span style=color:#66d9ef>type</span> t <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>		id<span style=color:#f92672>:</span> id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		dbg<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		ctime<span style=color:#f92672>:</span> <span style=color:#66d9ef>float</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		state<span style=color:#f92672>:</span> state<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		subtasks<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>string</span> <span style=color:#f92672>*</span> state<span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		debug_info<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>string</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		backtrace<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span></span></span></code></pre></div><p>Where the <code>state</code> field contains the result once the task has completed:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> async_result_t <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Vdi_info</span> <span style=color:#66d9ef>of</span> vdi_info
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Mirror_id</span> <span style=color:#66d9ef>of</span> Mirror.id
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> completion_t <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	duration <span style=color:#f92672>:</span> <span style=color:#66d9ef>float</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	result <span style=color:#f92672>:</span> async_result_t option
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> state <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Pending</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>float</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Completed</span> <span style=color:#66d9ef>of</span> completion_t
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Failed</span> <span style=color:#66d9ef>of</span> Rpc.t</span></span></code></pre></div><p>Once the result has been obtained from the task, the task should be destroyed via the <code>TASK.destroy</code> API call.</p><p>The implementation uses the <code>url</code> parameter to make SMAPIv2 calls to the destination SR. This is used, for example, to invoke a VDI.create call if necessary. The URL contains an authentication token within it (valid for the duration of the XenAPI call that caused this DATA.copy API call).</p><p>The implementation tries to minimize the amount of data copied by looking for related VDIs on the destination SR. See below for more details.</p><h3 id=mirroring-a-vdi>Mirroring a VDI</h3><p><code>DATA.MIRROR.start</code> takes a similar set of parameters to that of copy:</p><ul><li><code>dbg</code> - a debug string</li><li><code>sr</code> - the source SR (a uuid)</li><li><code>vdi</code> - the source VDI (a uuid)</li><li><code>dp</code> - the datapath on which the VDI has been attached</li><li><code>url</code> - a URL on which SMAPIv2 API calls can be made</li><li><code>sr</code> - the destination SR in which the VDI should be copied</li></ul><p>Similar to copy above, this returns a task id. The task &lsquo;completes&rsquo; once the mirror has been set up - that is, at any point afterwards we can detach the disk and the destination disk will be identical to the source. Unlike for copy the operation is ongoing after the API call completes, since new writes need to be mirrored to the destination. Therefore the completion type of the mirror operation is <code>Mirror_id</code> which contains a handle on which further API calls related to the mirror call can be made. For example <a href=https://github.com/xapi-project/xcp-idl/blob/a999ef6191629c8f68377f7c412ee98fc6a39dea/storage/storage_interface.ml#L446 target=_blank>MIRROR.stat</a> whose signature is:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>MIRROR.stat<span style=color:#f92672>:</span> dbg<span style=color:#f92672>:</span>debug_info <span style=color:#f92672>-&gt;</span> id<span style=color:#f92672>:</span>Mirror.id <span style=color:#f92672>-&gt;</span> Mirror.t</span></span></code></pre></div><p>The return type of this call is a record containing information about the mirror:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> state <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Receiving</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Sending</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> <span style=color:#a6e22e>Copying</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> t <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	source_vdi <span style=color:#f92672>:</span> vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	dest_vdi <span style=color:#f92672>:</span> vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	state <span style=color:#f92672>:</span> state <span style=color:#66d9ef>list</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	failed <span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p>Note that state is a list since the initial phase of the operation requires both copying and mirroring.</p><p>Additionally the mirror can be cancelled using the <code>MIRROR.stop</code> API call.</p><h3 id=code-walkthrough>Code walkthrough</h3><p>let&rsquo;s go through the implementation of <code>copy</code>:</p><h4 id=datacopy>DATA.copy</h4><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> copy <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;copy sr:%s vdi:%s url:%s dest:%s&#34;</span> sr vdi url dest<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_url <span style=color:#f92672>=</span> Http.Url.of_string url <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Remote</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Client</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> rpc <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> <span style=color:#f92672>~</span>dststr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;dst_smapiv2&#34;</span> remote_url <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Here we are constructing a module <code>Remote</code> on which we can do SMAPIv2 calls directly on the destination.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>try</span></span></span></code></pre></div><p>Wrap the whole function in an exception handler.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#75715e>(* Find the local VDI *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> Local.SR.scan <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> vdi<span style=color:#f92672>)</span> vdis
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Not_found</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Local VDI %s not found&#34;</span> vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>We first find the metadata for our source VDI by doing a local SMAPIv2 call <code>SR.scan</code>. This returns a list of VDI metadata, out of which we extract the VDI we&rsquo;re interested in.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>try</span></span></span></code></pre></div><p>Another exception handler. This looks redundant to me right now.</p><div class="wrap-code highlight"><pre tabindex=0><code>      let similar_vdis = Local.VDI.similar_content ~dbg ~sr ~vdi in
      let similars = List.map (fun vdi -&gt; vdi.content_id) similar_vdis in
      debug &#34;Similar VDIs to %s = [ %s ]&#34; vdi (String.concat &#34;; &#34; (List.map (fun x -&gt; Printf.sprintf &#34;(vdi=%s,content_id=%s)&#34; x.vdi x.content_id) similar_vdis));</code></pre></div><p>Here we look for related VDIs locally using the <code>VDI.similar_content</code> SMAPIv2 API call. This searches for related VDIs and returns an ordered list where the most similar is first in the list. It returns both clones and snapshots, and hence is more general than simply following <code>snapshot_of</code> links.</p><div class="wrap-code highlight"><pre tabindex=0><code>      let remote_vdis = Remote.SR.scan ~dbg ~sr:dest in
      (** We drop cbt_metadata VDIs that do not have any actual data *)
      let remote_vdis = List.filter (fun vdi -&gt; vdi.ty &lt;&gt; &#34;cbt_metadata&#34;) remote_vdis in

      let nearest = List.fold_left
          (fun acc content_id -&gt; match acc with
             | Some x -&gt; acc
             | None -&gt;
               try Some (List.find (fun vdi -&gt; vdi.content_id = content_id &amp;&amp; vdi.virtual_size &lt;= local_vdi.virtual_size) remote_vdis)
               with Not_found -&gt; None) None similars in

      debug &#34;Nearest VDI: content_id=%s vdi=%s&#34;
        (Opt.default &#34;None&#34; (Opt.map (fun x -&gt; x.content_id) nearest))
        (Opt.default &#34;None&#34; (Opt.map (fun x -&gt; x.vdi) nearest));</code></pre></div><p>Here we look for VDIs on the destination with the same <code>content_id</code> as one of the locally similar VDIs. We will use this as a base image and only copy deltas to the destination. This is done by cloning the VDI on the destination and then using <code>sparse_dd</code> to find the deltas from our local disk to our local copy of the content_id disk and streaming these to the destination. Note that we need to ensure the VDI is smaller than the one we want to copy since we can&rsquo;t resize disks downwards in size.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#66d9ef>let</span> remote_base <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> nearest <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> vdi <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Cloning VDI %s&#34;</span> vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> vdi_clone <span style=color:#f92672>=</span> Remote.VDI.clone <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> vdi_clone<span style=color:#f92672>.</span>virtual_size <span style=color:#f92672>&lt;&gt;</span> local_vdi<span style=color:#f92672>.</span>virtual_size <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> new_size <span style=color:#f92672>=</span> Remote.VDI.resize <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>vdi_clone<span style=color:#f92672>.</span>vdi <span style=color:#f92672>~</span>new_size<span style=color:#f92672>:</span>local_vdi<span style=color:#f92672>.</span>virtual_size <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            debug <span style=color:#e6db74>&#34;Resize remote VDI %s to %Ld: result %Ld&#34;</span> vdi_clone<span style=color:#f92672>.</span>vdi local_vdi<span style=color:#f92672>.</span>virtual_size new_size<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          vdi_clone
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Creating a blank remote VDI&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          Remote.VDI.create <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:{</span> local_vdi <span style=color:#66d9ef>with</span> sm_config <span style=color:#f92672>=</span> [] <span style=color:#f92672>}</span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>If we&rsquo;ve found a base VDI we clone it and resize it immediately. If there&rsquo;s nothing on the destination already we can use, we just create a new VDI. Note that the calls to create and clone may well fail if the destination host is not the SRmaster. This is <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/storage_migrate.ml#L214-L229 target=_blank>handled purely in the <code>rpc</code> function</a>:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> rpc <span style=color:#f92672>~</span>srcstr <span style=color:#f92672>~</span>dststr url call <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> XMLRPC_protocol.rpc <span style=color:#f92672>~</span>transport<span style=color:#f92672>:(</span>transport_of_url url<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>~</span>srcstr <span style=color:#f92672>~</span>dststr <span style=color:#f92672>~</span>http<span style=color:#f92672>:(</span>xmlrpc <span style=color:#f92672>~</span>version<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;1.0&#34;</span> <span style=color:#f92672>?</span>auth<span style=color:#f92672>:(</span>Http.Url.auth_of url<span style=color:#f92672>)</span> <span style=color:#f92672>~</span>query<span style=color:#f92672>:(</span>Http.Url.get_query_params url<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>Http.Url.get_uri url<span style=color:#f92672>))</span> call
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> not result<span style=color:#f92672>.</span>Rpc.success <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Got failure: checking for redirect&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Call was: %s&#34;</span> <span style=color:#f92672>(</span>Rpc.string_of_call call<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;result.contents: %s&#34;</span> <span style=color:#f92672>(</span>Jsonrpc.to_string result<span style=color:#f92672>.</span>Rpc.contents<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> Storage_interface.Exception.exnty_of_rpc result<span style=color:#f92672>.</span>Rpc.contents <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> Storage_interface.Exception.<span style=color:#a6e22e>Redirect</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Some</span> ip<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> Http.<span style=color:#a6e22e>Url</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> newurl <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> url <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Http</span> h<span style=color:#f92672>,</span> d<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span><span style=color:#a6e22e>Http</span> <span style=color:#f92672>{</span>h <span style=color:#66d9ef>with</span> host<span style=color:#f92672>=</span>ip<span style=color:#f92672>},</span> d<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          remote_url ip <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Redirecting to ip: %s&#34;</span> ip<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr <span style=color:#f92672>~</span>dststr newurl call <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Successfully redirected. Returning&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      r
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Not a redirect&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      result
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> result</span></span></code></pre></div><p>Back to the copy function:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#66d9ef>let</span> remote_copy <span style=color:#f92672>=</span> copy&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi<span style=color:#f92672>:</span>remote_base<span style=color:#f92672>.</span>vdi <span style=color:#f92672>|&gt;</span> vdi_info <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This calls the actual data copy part. See below for more on that.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>      <span style=color:#66d9ef>let</span> snapshot <span style=color:#f92672>=</span> Remote.VDI.snapshot <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:</span>remote_copy <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      Remote.VDI.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>remote_copy<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Vdi_info</span> snapshot<span style=color:#f92672>)</span></span></span></code></pre></div><p>Finally we snapshot the remote VDI to ensure we&rsquo;ve got a VDI of type &lsquo;snapshot&rsquo; on the destination, and we delete the non-snapshot VDI.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      error <span style=color:#e6db74>&#34;Caught %s: copying snapshots vdi&#34;</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Internal_error</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Backend_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Backend_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> params<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Internal_error</span><span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>))</span></span></span></code></pre></div><p>The exception handler does nothing - so we leak remote VDIs if the exception happens after we&rsquo;ve done our cloning :-(</p><h4 id=datacopy_into>DATA.copy_into</h4><p>Let&rsquo;s now look at the data-copying part. This is common code shared between <code>VDI.copy</code>, <code>VDI.copy_into</code> and <code>MIRROR.start</code> and hence has some duplication of the calls made above.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> copy_into <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  copy&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi</span></span></code></pre></div><p><code>copy_into</code> is a stub and just calls <code>copy'</code></p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> copy&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_url <span style=color:#f92672>=</span> Http.Url.of_string url <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Remote</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Client</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> rpc <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> <span style=color:#f92672>~</span>dststr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;dst_smapiv2&#34;</span> remote_url <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;copy local=%s/%s url=%s remote=%s/%s&#34;</span> sr vdi url dest dest_vdi<span style=color:#f92672>;</span></span></span></code></pre></div><p>This call takes roughly the same parameters as the ``DATA.copy` call above, except it specifies the destination VDI.
Once again we construct a module to do remote SMAPIv2 calls</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* Check the remote SR exists *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> srs <span style=color:#f92672>=</span> Remote.SR.list <span style=color:#f92672>~</span>dbg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> not<span style=color:#f92672>(</span>List.mem dest srs<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>then</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Remote SR %s not found&#34;</span> dest<span style=color:#f92672>);</span></span></span></code></pre></div><p>Sanity check.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> Remote.SR.scan <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> dest_vdi<span style=color:#f92672>)</span> vdis
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Not_found</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Remote VDI %s not found&#34;</span> dest_vdi<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Find the metadata of the destination VDI</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dest_content_id <span style=color:#f92672>=</span> remote_vdi<span style=color:#f92672>.</span>content_id <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>If we&rsquo;ve got a local VDI with the same content_id as the destination, we only need copy the deltas, so we make a note of the destination content ID here.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* Find the local VDI *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> Local.SR.scan <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> vdi<span style=color:#f92672>)</span> vdis
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Not_found</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Local VDI %s not found&#34;</span> vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;copy local=%s/%s content_id=%s&#34;</span> sr vdi local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;copy remote=%s/%s content_id=%s&#34;</span> dest dest_vdi remote_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span></span></span></code></pre></div><p>Find the source VDI metadata.</p><div class="wrap-code highlight"><pre tabindex=0><code>  if local_vdi.virtual_size &gt; remote_vdi.virtual_size then begin
    (* This should never happen provided the higher-level logic is working properly *)
    error &#34;copy local=%s/%s virtual_size=%Ld &gt; remote=%s/%s virtual_size = %Ld&#34; sr vdi local_vdi.virtual_size dest dest_vdi remote_vdi.virtual_size;
    failwith &#34;local VDI is larger than the remote VDI&#34;;
  end;</code></pre></div><p>Sanity check - the remote VDI can&rsquo;t be smaller than the source.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> on_fail <span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>unit</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>unit</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span> ref <span style=color:#f92672>=</span> ref [] <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>We do some ugly error handling here by keeping a mutable list of operations to perform in the event of a failure.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> base_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>content_id <span style=color:#f92672>=</span> dest_content_id<span style=color:#f92672>)</span> vdis<span style=color:#f92672>).</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;local VDI %s has content_id = %s; we will perform an incremental copy&#34;</span> x dest_content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Some</span> x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;no local VDI has content_id = %s; we will perform a full copy&#34;</span> dest_content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>None</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>See if we can identify a local VDI with the same <code>content_id</code> as the destination. If not, no problem.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> remote_dp <span style=color:#f92672>=</span> Uuid.string_of_uuid <span style=color:#f92672>(</span>Uuid.make_uuid ()<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> base_dp <span style=color:#f92672>=</span> Uuid.string_of_uuid <span style=color:#f92672>(</span>Uuid.make_uuid ()<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> leaf_dp <span style=color:#f92672>=</span> Uuid.string_of_uuid <span style=color:#f92672>(</span>Uuid.make_uuid ()<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Construct some <code>datapaths</code> - named reasons why the VDI is attached - that we will pass to <code>VDI.attach/activate</code>.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dest_vdi_url <span style=color:#f92672>=</span> Http.Url.set_uri remote_url <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;%s/nbd/%s/%s/%s&#34;</span> <span style=color:#f92672>(</span>Http.Url.get_uri remote_url<span style=color:#f92672>)</span> dest dest_vdi remote_dp<span style=color:#f92672>)</span> <span style=color:#f92672>|&gt;</span> Http.Url.to_string <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;copy remote=%s/%s NBD URL = %s&#34;</span> dest dest_vdi dest_vdi_url<span style=color:#f92672>;</span></span></span></code></pre></div><p>Here we are constructing a URI that we use to connect to the destination xapi. The handler for this particular path will verify the credentials and then pass the connection on to tapdisk which will behave as a NBD server. The VDI has to be attached and activated for this to work, unlike the new NBD handler in <code>xapi-nbd</code> that is smarter. The handler for this URI is declared <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/storage_migrate.ml#L858-L884 target=_blank>in this file</a></p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> id<span style=color:#f92672>=</span>State.copy_id_of <span style=color:#f92672>(</span>sr<span style=color:#f92672>,</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Persisting state for copy (id=%s)&#34;</span> id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    State.add id State.<span style=color:#f92672>(</span><span style=color:#a6e22e>Copy_op</span> Copy_state.<span style=color:#f92672>({</span>
</span></span><span style=display:flex><span>        base_dp<span style=color:#f92672>;</span> leaf_dp<span style=color:#f92672>;</span> remote_dp<span style=color:#f92672>;</span> dest_sr<span style=color:#f92672>=</span>dest<span style=color:#f92672>;</span> copy_vdi<span style=color:#f92672>=</span>remote_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span> remote_url<span style=color:#f92672>=</span>url<span style=color:#f92672>}));</span></span></span></code></pre></div><p>Since we&rsquo;re about to perform a long-running operation that is stateful, we persist the state here so that if xapi is restarted we can cancel the operation and not leak VDI attaches. Normally in xapi code we would be doing VBD.plug operations to persist the state in the xapi db, but this is storage code so we have to use a different mechanism.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;mirror.copy: copy initiated local_vdi:%s dest_vdi:%s&#34;</span> vdi dest_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Pervasiveext.finally <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        debug <span style=color:#e6db74>&#34;activating RW datapath %s on remote=%s/%s&#34;</span> remote_dp dest dest_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        ignore<span style=color:#f92672>(</span>Remote.VDI.attach <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>dest_vdi <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>remote_dp <span style=color:#f92672>~</span>read_write<span style=color:#f92672>:</span>true<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        Remote.VDI.activate <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>remote_dp <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>dest_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        with_activated_disk <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>base_vdi <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>base_dp
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> base_path <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>             with_activated_disk <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:(</span><span style=color:#a6e22e>Some</span> vdi<span style=color:#f92672>)</span> <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>leaf_dp
</span></span><span style=display:flex><span>               <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> src <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                  <span style=color:#66d9ef>let</span> dd <span style=color:#f92672>=</span> Sparse_dd_wrapper.start <span style=color:#f92672>~</span>progress_cb<span style=color:#f92672>:(</span>progress_callback 0<span style=color:#f92672>.</span>05 0<span style=color:#f92672>.</span>9 task<span style=color:#f92672>)</span> <span style=color:#f92672>?</span>base<span style=color:#f92672>:</span>base_path true <span style=color:#f92672>(</span>Opt.unbox src<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                      dest_vdi_url remote_vdi<span style=color:#f92672>.</span>virtual_size <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                  Storage_task.with_cancel task
</span></span><span style=display:flex><span>                    <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> Sparse_dd_wrapper.cancel dd<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>try</span> Sparse_dd_wrapper.wait dd
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>with</span> Sparse_dd_wrapper.<span style=color:#a6e22e>Cancelled</span> <span style=color:#f92672>-&gt;</span> Storage_task.raise_cancelled task<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>               <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>         Remote.DP.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>remote_dp <span style=color:#f92672>~</span>allow_leak<span style=color:#f92672>:</span>false<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>         State.remove_copy id
</span></span><span style=display:flex><span>      <span style=color:#f92672>);</span></span></span></code></pre></div><p>In this chunk of code we attach and activate the disk on the remote SR via the SMAPI, then locally attach and activate both the VDI we&rsquo;re copying and the base image we&rsquo;re copying deltas from (if we&rsquo;ve got one). We then call <code>sparse_dd</code> to copy the data to the remote NBD URL. There is some logic to update progress indicators and to cancel the operation if the SMAPIv2 call <code>TASK.cancel</code> is called.</p><p>Once the operation has terminated (either on success, error or cancellation), we remove the local attach and activations in the <code>with_activated_disk</code> function and the remote attach and activation by destroying the datapath on the remote SR. We then remove the persistent state relating to the copy.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;mirror.copy: copy complete local_vdi:%s dest_vdi:%s&#34;</span> vdi dest_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;setting remote=%s/%s content_id &lt;- %s&#34;</span> dest dest_vdi local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Remote.VDI.set_content_id <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>dest_vdi <span style=color:#f92672>~</span>content_id<span style=color:#f92672>:</span>local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* PR-1255: XXX: this is useful because we don&#39;t have content_ids by default *)</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;setting local=%s/%s content_id &lt;- %s&#34;</span> sr local_vdi<span style=color:#f92672>.</span>vdi local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Local.VDI.set_content_id <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>local_vdi<span style=color:#f92672>.</span>vdi <span style=color:#f92672>~</span>content_id<span style=color:#f92672>:</span>local_vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Vdi_info</span> remote_vdi<span style=color:#f92672>)</span></span></span></code></pre></div><p>The last thing we do is to set the local and remote content_id. The local set_content_id is there because the content_id of the VDI is constructed from the location if it is unset in the <a href=https://github.com/xapi-project/xen-api/blob/3bf897b3accfc172f365689c3c6927746e059177/ocaml/xapi/storage_access.ml#L69-L72 target=_blank>storage_access.ml</a> module of xapi (still part of the storage layer)</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>with</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    error <span style=color:#e6db74>&#34;Caught %s: performing cleanup actions&#34;</span> <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    perform_cleanup_actions <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> e</span></span></code></pre></div><p>Here we perform the list of cleanup operations. Theoretically. It seems we don&rsquo;t ever actually set this to anything, so this is dead code.</p><h4 id=datamirrorstart>DATA.MIRROR.start</h4><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> start&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  debug <span style=color:#e6db74>&#34;Mirror.start sr:%s vdi:%s url:%s dest:%s&#34;</span> sr vdi url dest<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  SMPERF.debug <span style=color:#e6db74>&#34;mirror.start called sr:%s vdi:%s url:%s dest:%s&#34;</span> sr vdi url dest<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> remote_url <span style=color:#f92672>=</span> Http.Url.of_string url <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Remote</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Client</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> rpc <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> <span style=color:#f92672>~</span>dststr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;dst_smapiv2&#34;</span> remote_url <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Find the local VDI *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> vdis <span style=color:#f92672>=</span> Local.SR.scan <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> List.find <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x<span style=color:#f92672>.</span>vdi <span style=color:#f92672>=</span> vdi<span style=color:#f92672>)</span> vdis
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Not_found</span> <span style=color:#f92672>-&gt;</span> failwith <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;Local VDI %s not found&#34;</span> vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>As with the previous calls, we make a remote module for SMAPIv2 calls on the destination, and we find local VDI metadata via <code>SR.scan</code></p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> State.mirror_id_of <span style=color:#f92672>(</span>sr<span style=color:#f92672>,</span>local_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Mirror ids are deterministically constructed.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(* A list of cleanup actions to perform if the operation should fail. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> on_fail <span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>unit</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>unit</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span> ref <span style=color:#f92672>=</span> ref [] <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This <code>on_fail</code> list is actually used.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> similar_vdis <span style=color:#f92672>=</span> Local.VDI.similar_content <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> similars <span style=color:#f92672>=</span> List.filter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> x <span style=color:#f92672>&lt;&gt;</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>(</span>List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> vdi <span style=color:#f92672>-&gt;</span> vdi<span style=color:#f92672>.</span>content_id<span style=color:#f92672>)</span> similar_vdis<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Similar VDIs to %s = [ %s ]&#34;</span> vdi <span style=color:#f92672>(</span>String.concat <span style=color:#e6db74>&#34;; &#34;</span> <span style=color:#f92672>(</span>List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> Printf.sprintf <span style=color:#e6db74>&#34;(vdi=%s,content_id=%s)&#34;</span> x<span style=color:#f92672>.</span>vdi x<span style=color:#f92672>.</span>content_id<span style=color:#f92672>)</span> similar_vdis<span style=color:#f92672>));</span></span></span></code></pre></div><p>As with copy we look locally for similar VDIs. However, rather than use that here we actually pass this information on to the destination SR via the <code>receive_start</code> internal SMAPIv2 call:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result_ty <span style=color:#f92672>=</span> Remote.DATA.MIRROR.receive_start <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:</span>local_vdi <span style=color:#f92672>~</span>id <span style=color:#f92672>~</span>similar<span style=color:#f92672>:</span>similars <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> result_ty <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        Mirror.<span style=color:#a6e22e>Vhd_mirror</span> x <span style=color:#f92672>-&gt;</span> x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This gives the destination SR a chance to say what sort of migration it can support. We only support <code>Vhd_mirror</code> style migrations which require the destination to support the <code>compose</code> SMAPIv2 operation. The type of <code>x</code> is a record:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> mirror_receive_result_vhd_t <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	mirror_vdi <span style=color:#f92672>:</span> vdi_info<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	mirror_datapath <span style=color:#f92672>:</span> dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	copy_diffs_from <span style=color:#f92672>:</span> content_id option<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	copy_diffs_to <span style=color:#f92672>:</span> vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	dummy_vdi <span style=color:#f92672>:</span> vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p>Field descriptions:</p><ul><li><code>mirror_vdi</code> is the VDI to which new writes should be mirrored.</li><li><code>mirror_datapath</code> is the remote datapath on which the VDI has been attached and activated. This is required to construct the remote NBD url</li><li><code>copy_diffs_from</code> represents the source base VDI to be used for the non-mirrored data copy.</li><li><code>copy_diffs_to</code> is the remote VDI to copy those diffs to</li><li><code>dummy_vdi</code> exists to prevent leaf-coalesce on the <code>mirror_vdi</code></li></ul><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#75715e>(* Enable mirroring on the local machine *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mirror_dp <span style=color:#f92672>=</span> result<span style=color:#f92672>.</span>Mirror.mirror_datapath <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> uri <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Printf.sprintf <span style=color:#e6db74>&#34;/services/SM/nbd/%s/%s/%s&#34;</span> dest result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi mirror_dp<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dest_url <span style=color:#f92672>=</span> Http.Url.set_uri remote_url uri <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> request <span style=color:#f92672>=</span> Http.Request.make <span style=color:#f92672>~</span>query<span style=color:#f92672>:(</span>Http.Url.get_query_params dest_url<span style=color:#f92672>)</span> <span style=color:#f92672>~</span>version<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;1.0&#34;</span> <span style=color:#f92672>~</span>user_agent<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> Http.<span style=color:#a6e22e>Put</span> uri <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> transport <span style=color:#f92672>=</span> Xmlrpc_client.transport_of_url dest_url <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>This is where we connect to the NBD server on the destination.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Searching for data path: %s&#34;</span> dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> attach_info <span style=color:#f92672>=</span> Local.DP.attach_info <span style=color:#f92672>~</span>dbg<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;nbd&#34;</span> <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>dp <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Got it!&#34;</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>we need the local <code>attach_info</code> to find the local tapdisk so we can send it the connected NBD socket.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    on_fail <span style=color:#f92672>:=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> Remote.DATA.MIRROR.receive_cancel <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>)</span> <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span></span></span></code></pre></div><p>This should probably be set directly after the call to <code>receive_start</code></p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tapdev <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> tapdisk_of_attach_info attach_info <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> tapdev <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        debug <span style=color:#e6db74>&#34;Got tapdev&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> pid <span style=color:#f92672>=</span> Tapctl.get_tapdisk_pid tapdev <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> path <span style=color:#f92672>=</span> Printf.sprintf <span style=color:#e6db74>&#34;/var/run/blktap-control/nbdclient%d&#34;</span> pid <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        with_transport transport <span style=color:#f92672>(</span>with_http request <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>response<span style=color:#f92672>,</span> s<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            debug <span style=color:#e6db74>&#34;Here inside the with_transport&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> control_fd <span style=color:#f92672>=</span> Unix.socket Unix.<span style=color:#a6e22e>PF_UNIX</span> Unix.<span style=color:#a6e22e>SOCK_STREAM</span> 0 <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            finally
</span></span><span style=display:flex><span>              <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                 debug <span style=color:#e6db74>&#34;Connecting to path: %s&#34;</span> path<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                 Unix.connect control_fd <span style=color:#f92672>(</span>Unix.<span style=color:#a6e22e>ADDR_UNIX</span> path<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>let</span> msg <span style=color:#f92672>=</span> dp <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>let</span> len <span style=color:#f92672>=</span> String.length msg <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>let</span> written <span style=color:#f92672>=</span> Unixext.send_fd control_fd msg 0 len [] s <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                 debug <span style=color:#e6db74>&#34;Sent fd&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>if</span> written <span style=color:#f92672>&lt;&gt;</span> len <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>                   error <span style=color:#e6db74>&#34;Failed to transfer fd to %s&#34;</span> path<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                   failwith <span style=color:#e6db74>&#34;foo&#34;</span>
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                 Unix.close control_fd<span style=color:#f92672>)));</span>
</span></span><span style=display:flex><span>        tapdev
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        failwith <span style=color:#e6db74>&#34;Not attached&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span></span></span></code></pre></div><p>Here we connect to the remote NBD server, then pass that connected fd to the local tapdisk that is using the disk. This fd is passed with a name that is later used to tell tapdisk to start using it - we use the datapath name for this.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Adding to active local mirrors: id=%s&#34;</span> id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> alm <span style=color:#f92672>=</span> State.Send_state.<span style=color:#f92672>({</span>
</span></span><span style=display:flex><span>        url<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        dest_sr<span style=color:#f92672>=</span>dest<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        remote_dp<span style=color:#f92672>=</span>mirror_dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        local_dp<span style=color:#f92672>=</span>dp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        mirror_vdi<span style=color:#f92672>=</span>result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        remote_url<span style=color:#f92672>=</span>url<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        tapdev<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        failed<span style=color:#f92672>=</span>false<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        watchdog<span style=color:#f92672>=</span><span style=color:#a6e22e>None</span><span style=color:#f92672>})</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    State.add id <span style=color:#f92672>(</span>State.<span style=color:#a6e22e>Send_op</span> alm<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Added&#34;</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>As for copy we persist some state to disk to say that we&rsquo;re doing a mirror so we can undo any state changes after a toolstack restart.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;About to snapshot VDI = %s&#34;</span> <span style=color:#f92672>(</span>string_of_vdi_info local_vdi<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span> add_to_sm_config local_vdi <span style=color:#e6db74>&#34;mirror&#34;</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;nbd:&#34;</span> <span style=color:#f92672>^</span> dp<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> local_vdi <span style=color:#f92672>=</span> add_to_sm_config local_vdi <span style=color:#e6db74>&#34;base_mirror&#34;</span> id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> snapshot <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>      Local.VDI.snapshot <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi_info<span style=color:#f92672>:</span>local_vdi
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> Storage_interface.<span style=color:#a6e22e>Backend_error</span><span style=color:#f92672>(</span>code<span style=color:#f92672>,</span> <span style=color:#f92672>_)</span> <span style=color:#66d9ef>when</span> code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;SR_BACKEND_FAILURE_44&#34;</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.sr_source_space_insufficient<span style=color:#f92672>,</span> <span style=color:#f92672>[</span> sr <span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> e
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Done!&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SMPERF.debug <span style=color:#e6db74>&#34;mirror.start: snapshot created, mirror initiated vdi:%s snapshot_of:%s&#34;</span>
</span></span><span style=display:flex><span>      snapshot<span style=color:#f92672>.</span>vdi local_vdi<span style=color:#f92672>.</span>vdi <span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    on_fail <span style=color:#f92672>:=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> Local.VDI.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>snapshot<span style=color:#f92672>.</span>vdi<span style=color:#f92672>)</span> <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span></span></span></code></pre></div><p>This bit inserts into <code>sm_config</code> the name of the fd we passed earlier to do mirroring. This is interpreted by the python SM backends and passed on the <code>tap-ctl</code> invocation to unpause the disk. This causes all new writes to be mirrored via NBD to the file descriptor passed earlier.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> inner () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        debug <span style=color:#e6db74>&#34;tapdisk watchdog&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> alm_opt <span style=color:#f92672>=</span> State.find_active_local_mirror id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> alm_opt <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> alm <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> stats <span style=color:#f92672>=</span> Tapctl.stats <span style=color:#f92672>(</span>Tapctl.create ()<span style=color:#f92672>)</span> tapdev <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> stats<span style=color:#f92672>.</span>Tapctl.Stats.nbd_mirror_failed <span style=color:#f92672>=</span> 1 <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            Updates.add <span style=color:#f92672>(</span>Dynamic.<span style=color:#a6e22e>Mirror</span> id<span style=color:#f92672>)</span> updates<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          alm<span style=color:#f92672>.</span>State.Send_state.watchdog <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span>Scheduler.one_shot scheduler <span style=color:#f92672>(</span>Scheduler.<span style=color:#a6e22e>Delta</span> 5<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;tapdisk_watchdog&#34;</span> inner<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> ()
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>in</span> inner ()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span></span></span></code></pre></div><p>This is the watchdog that runs <code>tap-ctl stats</code> every 5 seconds watching <code>mirror_failed</code> for evidence of a failure in the mirroring code. If it detects one the only thing it does is to notify that the state of the mirroring has changed. This will be picked up by the thread in xapi that is monitoring the state of the mirror. It will then issue a <code>MIRROR.stat</code> call which will return the state of the mirror including the information that it has failed.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    on_fail <span style=color:#f92672>:=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> stop <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id<span style=color:#f92672>)</span> <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* Copy the snapshot to the remote *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> new_parent <span style=color:#f92672>=</span> Storage_task.with_subtask task <span style=color:#e6db74>&#34;copy&#34;</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        copy&#39; <span style=color:#f92672>~</span>task <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>snapshot<span style=color:#f92672>.</span>vdi <span style=color:#f92672>~</span>url <span style=color:#f92672>~</span>dest <span style=color:#f92672>~</span>dest_vdi<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.copy_diffs_to<span style=color:#f92672>)</span> <span style=color:#f92672>|&gt;</span> vdi_info <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Local VDI %s == remote VDI %s&#34;</span> snapshot<span style=color:#f92672>.</span>vdi new_parent<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span></span></span></code></pre></div><p>This is where we copy the VDI returned by the snapshot invocation to the remote VDI called <code>copy_diffs_to</code>. We only copy deltas, but we rely on <code>copy'</code> to figure out which disk the deltas should be taken from, which it does via the <code>content_id</code> field.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    Remote.VDI.compose <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi1<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.copy_diffs_to <span style=color:#f92672>~</span>vdi2<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Remote.VDI.remove_from_sm_config <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi <span style=color:#f92672>~</span>key<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;base_mirror&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Local VDI %s now mirrored to remote VDI: %s&#34;</span> local_vdi<span style=color:#f92672>.</span>vdi result<span style=color:#f92672>.</span>Mirror.mirror_vdi<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span></span></span></code></pre></div><p>Once the copy has finished we invoke the <code>compose</code> SMAPIv2 call that composes the diffs from the mirror with the base image copied from the snapshot.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Destroying dummy VDI %s on remote&#34;</span> result<span style=color:#f92672>.</span>Mirror.dummy_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Remote.VDI.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr<span style=color:#f92672>:</span>dest <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>result<span style=color:#f92672>.</span>Mirror.dummy_vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    debug <span style=color:#e6db74>&#34;Destroying snapshot %s on src&#34;</span> snapshot<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Local.VDI.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi<span style=color:#f92672>:</span>snapshot<span style=color:#f92672>.</span>vdi<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Mirror_id</span> id<span style=color:#f92672>)</span></span></span></code></pre></div><p>we can now destroy the dummy vdi on the remote (which will cause a leaf-coalesce in due course), and we destroy the local snapshot here (which will also cause a leaf-coalesce in due course, providing we don&rsquo;t destroy it first). The return value from the function is the mirror_id that we can use to monitor the state or cancel the mirror.</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Sr_not_attached</span><span style=color:#f92672>(</span>sr_uuid<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    error <span style=color:#e6db74>&#34; Caught exception %s:%s. Performing cleanup.&#34;</span> Api_errors.sr_not_attached sr_uuid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    perform_cleanup_actions <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#f92672>(</span>Api_errors.<span style=color:#a6e22e>Server_error</span><span style=color:#f92672>(</span>Api_errors.sr_not_attached<span style=color:#f92672>,[</span>sr_uuid<span style=color:#f92672>]))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    error <span style=color:#e6db74>&#34;Caught %s: performing cleanup actions&#34;</span> <span style=color:#f92672>(</span>Api_errors.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    perform_cleanup_actions <span style=color:#f92672>!</span>on_fail<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> e</span></span></code></pre></div><p>The exception handler just cleans up afterwards.</p><p>This is not the end of the story, since we need to detach the remote datapath being used for mirroring when we detach this end. The hook function is in <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/storage_migrate.ml#L775-L791 target=_blank>storage_migrate.ml</a>:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> post_detach_hook <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>~</span>dp <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> State.<span style=color:#a6e22e>Send_state</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> State.mirror_id_of <span style=color:#f92672>(</span>sr<span style=color:#f92672>,</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  State.find_active_local_mirror id <span style=color:#f92672>|&gt;</span>
</span></span><span style=display:flex><span>  Opt.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> r <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> remote_url <span style=color:#f92672>=</span> Http.Url.of_string r<span style=color:#f92672>.</span>url <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Remote</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Client</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>let</span> rpc <span style=color:#f92672>=</span> rpc <span style=color:#f92672>~</span>srcstr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;smapiv2&#34;</span> <span style=color:#f92672>~</span>dststr<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;dst_smapiv2&#34;</span> remote_url <span style=color:#66d9ef>end</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> t <span style=color:#f92672>=</span> Thread.create <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Calling receive_finalize&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          log_and_ignore_exn
</span></span><span style=display:flex><span>            <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> Remote.DATA.MIRROR.receive_finalize <span style=color:#f92672>~</span>dbg<span style=color:#f92672>:</span><span style=color:#e6db74>&#34;Mirror-cleanup&#34;</span> <span style=color:#f92672>~</span>id<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Finished calling receive_finalize&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          State.remove_local_mirror id<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          debug <span style=color:#e6db74>&#34;Removed active local mirror: %s&#34;</span> id
</span></span><span style=display:flex><span>        <span style=color:#f92672>)</span> () <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      Opt.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> id <span style=color:#f92672>-&gt;</span> Scheduler.cancel scheduler id<span style=color:#f92672>)</span> r<span style=color:#f92672>.</span>watchdog<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      debug <span style=color:#e6db74>&#34;Created thread %d to call receive finalize and dp destroy&#34;</span> <span style=color:#f92672>(</span>Thread.id t<span style=color:#f92672>))</span></span></span></code></pre></div><p>This removes the persistent state and calls <code>receive_finalize</code> on the destination. The body of that functions is:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> receive_finalize <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>id <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> recv_state <span style=color:#f92672>=</span> State.find_active_receive_mirror id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> State.<span style=color:#a6e22e>Receive_state</span> <span style=color:#66d9ef>in</span> Opt.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> r <span style=color:#f92672>-&gt;</span> Local.DP.destroy <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp<span style=color:#f92672>:</span>r<span style=color:#f92672>.</span>leaf_dp <span style=color:#f92672>~</span>allow_leak<span style=color:#f92672>:</span>false<span style=color:#f92672>)</span> recv_state<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  State.remove_receive_mirror id</span></span></code></pre></div><p>which removes the persistent state on the destination and destroys the datapath associated with the mirror.</p><p>Additionally, there is also a pre-deactivate hook. The rationale for this is that we want to detect any failures to write that occur right at the end of the SXM process. So if there is a mirror operation going on, before we deactivate we wait for tapdisk to flush its queue of outstanding requests, then we query whether there has been a mirror failure. The code is just above the detach hook in <a href=https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/storage_migrate.ml#L738-L773 target=_blank>storage_migrate.ml</a>:</p><div class="wrap-code highlight"><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> pre_deactivate_hook <span style=color:#f92672>~</span>dbg <span style=color:#f92672>~</span>dp <span style=color:#f92672>~</span>sr <span style=color:#f92672>~</span>vdi <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> State.<span style=color:#a6e22e>Send_state</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> State.mirror_id_of <span style=color:#f92672>(</span>sr<span style=color:#f92672>,</span>vdi<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> Mtime_clock.counter () <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> get_delta () <span style=color:#f92672>=</span> Mtime_clock.count start <span style=color:#f92672>|&gt;</span> Mtime.Span.to_s <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  State.find_active_local_mirror id <span style=color:#f92672>|&gt;</span>
</span></span><span style=display:flex><span>  Opt.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> s <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(* We used to pause here and then check the nbd_mirror_failed key. Now, we poll
</span></span></span><span style=display:flex><span><span style=color:#75715e>				   until the number of outstanding requests has gone to zero, then check the
</span></span></span><span style=display:flex><span><span style=color:#75715e>				   status. This avoids confusing the backend (CA-128460) *)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Tapctl</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> ctx <span style=color:#f92672>=</span> create () <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> wait () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> get_delta () <span style=color:#f92672>&gt;</span> reqs_outstanding_timeout <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Timeout</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>let</span> st <span style=color:#f92672>=</span> stats ctx s<span style=color:#f92672>.</span>tapdev <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> st<span style=color:#f92672>.</span>Stats.reqs_outstanding <span style=color:#f92672>&gt;</span> 0
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>then</span> <span style=color:#f92672>(</span>Thread.delay 1<span style=color:#f92672>.</span>0<span style=color:#f92672>;</span> wait ()<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span> st
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> st <span style=color:#f92672>=</span> wait () <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        debug <span style=color:#e6db74>&#34;Got final stats after waiting %f seconds&#34;</span> <span style=color:#f92672>(</span>get_delta ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> st<span style=color:#f92672>.</span>Stats.nbd_mirror_failed <span style=color:#f92672>=</span> 1
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>          error <span style=color:#e6db74>&#34;tapdisk reports mirroring failed&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          s<span style=color:#f92672>.</span>failed <span style=color:#f92672>&lt;-</span> true
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> <span style=color:#a6e22e>Timeout</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        error <span style=color:#e6db74>&#34;Timeout out after %f seconds waiting for tapdisk to complete all outstanding requests&#34;</span> <span style=color:#f92672>(</span>get_delta ()<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        s<span style=color:#f92672>.</span>failed <span style=color:#f92672>&lt;-</span> true
</span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> e <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        error <span style=color:#e6db74>&#34;Caught exception while finally checking mirror state: %s&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span>Printexc.to_string e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        s<span style=color:#f92672>.</span>failed <span style=color:#f92672>&lt;-</span> true
</span></span><span style=display:flex><span>    <span style=color:#f92672>)</span></span></span></code></pre></div><footer class=footline></footer></article></section></div></main></div><script src=/new-docs/js/clipboard.min.js?1723537602 defer></script><script src=/new-docs/js/perfect-scrollbar.min.js?1723537602 defer></script><script src=/new-docs/js/d3/d3-color.min.js?1723537602 defer></script><script src=/new-docs/js/d3/d3-dispatch.min.js?1723537602 defer></script><script src=/new-docs/js/d3/d3-drag.min.js?1723537602 defer></script><script src=/new-docs/js/d3/d3-ease.min.js?1723537602 defer></script><script src=/new-docs/js/d3/d3-interpolate.min.js?1723537602 defer></script><script src=/new-docs/js/d3/d3-selection.min.js?1723537602 defer></script><script src=/new-docs/js/d3/d3-timer.min.js?1723537602 defer></script><script src=/new-docs/js/d3/d3-transition.min.js?1723537602 defer></script><script src=/new-docs/js/d3/d3-zoom.min.js?1723537602 defer></script><script src=/new-docs/js/js-yaml.min.js?1723537602 defer></script><script src=/new-docs/js/mermaid.min.js?1723537602 defer></script><script>window.themeUseMermaid=JSON.parse("{}")</script><script src=/new-docs/js/theme.js?1723537602 defer></script></body></html>